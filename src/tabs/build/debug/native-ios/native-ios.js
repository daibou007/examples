CACHE={"resources/fonts/fontsheetSizeMap.json":"{}","resources/fonts/metadata.json":"{\"sprite\":false}","spritesheets/map.json":"{\"resources/fonts/fontsheetSizeMap.json\":{},\"resources/fonts/metadata.json\":{}}"};
// Copyright (c) 2010
// Michael Carter (cartermichael@gmail.com)
// Martin Hunt (mghunt@gmail.com)
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// Initialization of js.io occurs in a closure, preventing local variables
// from entering the global scope.  During execution, the method `jsio` is
// added to the global scope.

;(function() {
	function init(cloneFrom) {
		// We expect this code to be minified before production use, so we may
		// write code slightly more verbosely than we otherwise would.
	
		// Should we parse syntax errors in the browser?
		var DEBUG = true;
	
		// Store a reference to the slice function for converting objects of
		// type arguments to type array.
		var SLICE = Array.prototype.slice;
	
		// js.io supports multiple JavaScript environments such as node.js and
		// most web browsers (IE, Firefox, WebKit).  The ENV object wraps 
		// any utility functions that contain environment-specific code (e.g.
		// reading a file using node's `fs` library or a browser's
		// `XMLHttpRequest`).  Running js.io in other JavaScript environments
		// is as easy as implementing an environment object that conforms to 
		// the abstract interface for an environment (provided below) and 
		// calling `jsio.setEnv()`.
		var ENV;
	
		// Checks if the last character in a string is `/`.
		var rexpEndSlash = /\/$/;

		function getModuleDef (path) {
			path += '.js';
			return jsio.__modules[path] || new ModuleDef(path);
		}
	
		// Creates an object containing metadata about a module.
		function ModuleDef (path) {
			this.path = path;
			this.friendlyPath = path;
			util.splitPath(path, this);
		};

		ModuleDef.prototype.setBase = function (baseMod, basePath) {
			this.baseMod = baseMod;
			this.basePath = basePath;
		};
	
		// Utility functions
		var util = {
				// `util.bind` returns a function that, when called, will execute
				// the method passed in with the provided context and any additional
				// arguments passed to `util.bind`.
				//       util.bind(obj, 'f', a) -> function() { return obj.f(a); }
				//       util.bind(obj, g, a, b, c) -> function() { return g.call(g, a, b, c); }
				bind: function(context, method/*, args... */) {
					var args = SLICE.call(arguments, 2);
					return function() {
						method = (typeof method == 'string' ? context[method] : method);
						return method.apply(context, args.concat(SLICE.call(arguments, 0)));
					};
				},
			
				// `util.addEndSlash` accepts a string.  That string is returned with a `/`
				// appended if the string did not already end in a `/`.
				addEndSlash: function(str) {
					return rexpEndSlash.test(str) ? str : str + '/';
				},
			
				// `util.removeEndSlash` accepts a string.  It removes a trailing `/` if
				// one is found.
				removeEndSlash: function(str) {
					return str.replace(rexpEndSlash, '');
				},
			
				// `util.makeRelativePath` accepts two paths (strings) and returns the first path
				// made relative to the second.  Note: this function needs some work.  It currently
				// handles the most common use cases, but may fail in unexpected edge cases.
				// 
				//  - Simple case: if `path` starts with `relativeTo`, then we can strip `path` 
				// off the `relativeTo` part and we're done.
				//
				//         util.makeRelativePath('abc/def/', 'abc') -> 'def'
				//
				//  - Harder case: `path` starts with some substring of `relativeTo`.  We want to remove this substring and then add `../` for each remaining segment of `relativeTo`.
				//
				//         util.makeRelativePath('abc/def/', 'abc/hij') -> '../def'
				//
				makeRelativePath: function(path, relativeTo) {
					var len = relativeTo.length;
					if (path.substring(0, len) == relativeTo) {
						/* Note: we're casting a boolean to an int by adding len to it */
						return path.slice((path.charAt(len) == '/') + len);
					}
				
					var sA = util.removeEndSlash(path).split('/'),
						sB = util.removeEndSlash(relativeTo).split('/'),
						i = 0;
				
					/* Count how many segments match. */
					while(sA[i] == sB[i]) { ++i; }
				
					if (i) {
						/* If at least some segments matched, remove them.  The result is our new path. */
						path = sA.slice(i).join('/');
					
						/* Prepend `../` for each segment remaining in `relativeTo`. */
						for (var j = sB.length - i; j > 0; --j) { path = '../' + path; }
					}
				
					return path;
				},
			
				// `buildPath` accepts an arbitrary number of string arguments to concatenate into a path.
				//     util.buildPath('a', 'b', 'c/', 'd/') -> 'a/b/c/d/'
				buildPath: function() {
					var args = Array.prototype.filter.call(arguments, function (x) { return x; });
					return util.resolveRelativePath(args.join('/'));
				},
			
				// `resolveRelativePath` removes relative path indicators.  For example:
				//     util.resolveRelativePath('a/../b') -> b
				resolveRelativePath: function(path) {
					/* If the path starts with a protocol, store it and remove it (add it
					   back later) so we don't accidently modify it. */
					var protocol = path.match(/^(\w+:\/\/)(.*)$/);
					if (protocol) { path = protocol[2]; }
				
					/* Remove multiple slashes and trivial dots (`/./ -> /`). */
					path = path.replace(/\/+/g, '/').replace(/\/\.\//g, '/');
				
					/* Loop to collapse instances of `../` in the path by matching a previous
					   path segment.  Essentially, we find substrings of the form `/abc/../`
					   where abc is not `.` or `..` and replace the substrings with `/`.
					   We loop until the string no longer changes since after collapsing
					   possible instances once, we may have created more instances that can
					   be collapsed.
					*/
					var o;
					while((o = path) != (path = path.replace(/(^|\/)(?!\.?\.\/)([^\/]+)\/\.\.\//g, '$1'))) {}
					/* Don't forget to prepend any protocol we might have removed earlier. */
					return protocol ? protocol[1] + path : path;
				},
			
				resolveRelativeModule: function (modulePath, directory) {
					var result = [],
						parts = modulePath.split('.'),
						len = parts.length,
						relative = (len > 1 && !parts[0]),
						i = relative ? 0 : -1;
				
					while(++i < len) { result.push(parts[i] ? parts[i] : '..'); }
					return util.buildPath(relative ? directory : '', result.join('/'));
				},
				resolveModulePath: function (modulePath, directory) {
					// resolve relative paths
					if (modulePath.charAt(0) == '.') {
						return [getModuleDef(util.resolveRelativeModule(modulePath, directory))];
					}
				
					// resolve absolute paths with respect to jsio packages/
					var pathSegments = modulePath.split('.');
					var baseMod = pathSegments[0];
					var pathString = pathSegments.join('/');
					
					if (jsioPath.cache.hasOwnProperty(baseMod)) {
						return [getModuleDef(util.buildPath(jsioPath.cache[baseMod], pathString))];
					}
				
					var defs = [];
					var paths = jsioPath.get();
					var len = paths.length;
					for (var i = 0; i < len; ++i) {
						var moduleDef = getModuleDef(util.buildPath(paths[i], pathString));
						moduleDef.setBase(baseMod, paths[i]);
						defs.push(moduleDef);
					}
					return defs;
				},
				splitPath: function(path, result) {
					if (!result) { result = {}; }
					var i = path.lastIndexOf('/') + 1;
					result.directory = path.substring(0, i);
					result.filename = path.substring(i);
					return result;
				}
			};
		
		// construct the top-level jsio object
		var jsio = util.bind(this, importer, null, null, null);

		jsio.__util = util;
		jsio.__init__ = init;

		var srcCache;
		jsio.setCache = function(cache) { srcCache = jsio.__srcCache = cache; }
		jsio.setCache(cloneFrom && cloneFrom.__srcCache || {});

		jsio.setCachedSrc = function(path, src) { srcCache[path] = { path: path, src: src }; }
		jsio.getCachedSrc = function(path) { return srcCache[path]; }

		jsio.__filename = 'jsio.js';
		jsio.__cmds = [];
		jsio.__jsio = jsio;
		jsio.__importer = importer;
		jsio.__modules = {preprocessors:{}};
		var jsioPath = {
				set: function(path) { jsioPath.value = (typeof path == 'string' ? [path] : path); },
				get: function() { return jsioPath.value.slice(0); },
				add: function(path) {
					var v = jsioPath.value, len = v.length;
					for (var i = 0; i < len; ++i) {
						if (v[i] == path) { return; }
					}
					v.push(path);
				},
				remove: function(path) {
					var v = jsioPath.value, len = v.length;
					for (var i = 0; i < len; ++i) {
						if (v[i] == path) {
							v.splice(i, 1);
						}
					}
				},
				value: [],
				cache: {}
			};
		
		jsio.path = jsioPath;
		jsio.addPath = util.bind(jsioPath, 'add');
		jsio.addCmd = util.bind(jsio.__cmds, 'push');
		
		jsio.setEnv = function(envCtor) {
			if (!envCtor && cloneFrom) {
				ENV = new cloneFrom.__env.constructor(util);
			} else {
				if (typeof envCtor == 'string') {
					envCtor = ({
							node: ENV_node,
							browser: ENV_browser
						})[envCtor] || ENV_browser;
				}

				ENV = new envCtor(util);
			}

			this.__env = ENV;
			this.__dir = ENV.getCwd();
			this.path.set(ENV.getPath());
		}
		
		if (cloneFrom) {
			jsio.setEnv();
		} else if (typeof process !== 'undefined' && process.version) {
			jsio.setEnv('node');
		} else if (typeof XMLHttpRequest != 'undefined' || typeof ActiveXObject != 'undefined') {
			jsio.setEnv('browser');
		}

		/*
		function ENV_abstract() {
			this.global = null;
			this.getCwd = function() {};
			this.getPath = function() {};
			this.eval = function(code, path) {};
			this.fetch = function(path) { return contentsOfPath; };
			this.log = function(args...) {};
		}
		*/
	
		function ENV_node() {
			var fs = require('fs');
			var path = require('path');
			
			this.name = 'node';
			this.global = GLOBAL;
			this.getCwd = process.cwd;

			this.log = function() {
				var msg;
				try {
					msg = Array.prototype.map.call(arguments, function(a) {
							if ((a instanceof Error) && a.message) {
								return 'Error:' + a.message + '\nStack:' + a.stack + '\nArguments:' + a.arguments;
							}
							return (typeof a == 'string' ? a : JSON.stringify(a));
						}).join(' ') + '\n';
				} catch(e) {
					msg = Array.prototype.join.call(arguments, ' ') + '\n';
				}

				process.stderr.write(msg);
				return msg;
			}
			
			this.getPath = function() {
				var segments = __filename.split('/');
				segments.pop();
				return util.makeRelativePath(segments.join('/') || '.', this.getCwd());
			}
			
			if (process.compile) {
				this.eval = process.compile;
			} else {
				var vm = require('vm');
				this.eval = function (code, path) {
					try {
						return vm.runInThisContext(code, path);
					} catch (e) {
						this.log('In ' + path + ':\n' + e.message);
						throw e;
					}
				}
			}
			
			this.fetch = function (p) {
				if (p.charAt(0) != '/') { p = util.buildPath(this.getCwd(), p); }

				try {
					var dirname = path.dirname(p);
					var filename = path.basename(p);
					var lowerFilename = filename.toLowerCase();
					var files = fs.readdirSync(dirname);
				} catch (e) {
					return false;
				}

				for (var i = 0, testName; testName = files[i]; ++i) {
					if (testName.toLowerCase() == lowerFilename && testName != filename) {
						throw "Invalid case when importing [" + p + "].  You probably meant" + testName;
					}
				}

				try {
					return fs.readFileSync(p, 'utf8');
				} catch(e) {
					return false;
				}
			}
			
			this.require = require;
		}
	
		function ENV_browser() {
			var XHR = window.XMLHttpRequest || function() { return new ActiveXObject("Msxml2.XMLHTTP"); },
				cwd = null,
				path = null,
				JOIN = Array.prototype.join;
			
			this.name = 'browser';
			this.global = window;
			if (!this.global.jsio) { this.global.jsio = jsio; }
		
			if (window.console && console.log) {
				if (!console.log.apply || /Android|iPhone|iPad|iPod/.test(navigator.userAgent)) {
					this.log = function () {
						var args = JOIN.call(arguments, ' ');
						console.log(args);
						return args;
					}
				} else {
					this.log = function () {
						console.log.apply(console, arguments);
						return JOIN.call(arguments, ' ');
					}
				}
			} else {
				this.log = function () { return JOIN.call(arguments, ' '); }
			}

			this.getCwd = function() {
				if(!cwd) {
					var loc = window.location, path = loc.pathname;
					cwd = loc.protocol + '//' + loc.host + path.substring(0, path.lastIndexOf('/') + 1);
				}
				return cwd;
			}
		
			this.getPath = function() {
				if(!path) {
					try {
						var filename = new RegExp('(.*?)' + jsio.__filename + '(\\?.*)?$'),
							scripts = document.getElementsByTagName('script');
					
						for (var i = 0, script; script = scripts[i]; ++i) {
							var result = script.src.match(filename);
							if (result) {
								path = result[1];
								if (/^[A-Za-z]*:\/\//.test(path)) { path = util.makeRelativePath(path, this.getCwd()); }
								break;
							}
						}
					} catch(e) {}
				
					if(!path) { path = '.'; }
				}
				return path;
			}
		
			this.debugPath = function(path) { return path; }

			// IE6 won't return an anonymous function from eval, so use the function constructor instead
			var rawEval = typeof eval('(function(){})') == 'undefined'
				? function(src, path) { return (new Function('return ' + src))(); }
				: function(src, path) { var src = src + '\n//@ sourceURL=' + path; return window.eval(src); };

			// provide an eval with reasonable debugging
			this.eval = function(code, path, origCode) {
				try {
					return rawEval(code, this.debugPath(path));
				} catch(e) {
					if(e instanceof SyntaxError) {
						ENV.log("a syntax error is preventing execution of " + path);
						if (DEBUG && this.checkSyntax) {
							this.checkSyntax(origCode, path);
						}
					}
					throw e;
				}
			}
		
			this.checkSyntax = function(code, path) {
				try {
					var syntax = jsio('import util.syntax', {suppressErrors: true, dontExport: true}),
						result = syntax(code);
					syntax.display(result, path);
				} catch(e) {}
			}
		
			this.fetch = function(path) {
				var xhr = new XHR();
				try {
					xhr.open('GET', path, false);
					xhr.send(null);
				} catch(e) {
					ENV.log('e:', e);
					return false; // firefox file://
				}
			
				if (xhr.status == 404 || // all browsers, http://
					xhr.status == -1100 || // safari file://
					// XXX: We have no way to tell in opera if a file exists and is empty, or is 404
					// XXX: Use flash?
					//(!failed && xhr.status == 0 && !xhr.responseText && EXISTS)) // opera
					false)
				{
					return false;
				}
			
				return xhr.responseText;
			}
		};
	
		var preprocessorCheck = /^"use (.*?)"\s*;\s*\n/,
			preprocessorFunc = /^(.+)\(.+\)$/,
			failedFetch = {};
	
		function findModule(possibilities, opts) {
			var src;
			for (var i = 0, possible; possible = possibilities[i]; ++i) {
				var path = possible.path,
					cachedVersion = srcCache[path];
				
				if (cachedVersion) {
					possible.src = cachedVersion.src;
					possible.pre = true;
					return possible;
				}
			
				/*if (/^\.\//.test(path)) {
					// remove one path segment for each dot from the cwd 
					path = addEndSlash(ENV.getCwd()) + path;
				}*/
			
				src = ENV.fetch(path);
			
				if (src !== false) {
					possible.src = src;
					return possible;
				} else {
					failedFetch[path] = true;
				}
			}
		
			return false;
		}
	
		// load a module from a file
		function loadModule (fromDir, fromFile, modulePath, opts) {
			var possibilities = util.resolveModulePath(modulePath, fromDir);
			for (var i = 0, p; p = possibilities[i]; ++i) {
				var path = possibilities[i].path;
				if (!opts.reload && (path in jsio.__modules)) {
					return possibilities[i];
				}

				if (path in failedFetch) { possibilities.splice(i--, 1); }
			}
		
			if (!possibilities.length) {
				if (opts.suppressErrors) { return false; }
				var e = new Error('Module failed to load (again)');
				e.jsioLogged = true;
				throw e;
			}
		
			var moduleDef = findModule(possibilities, opts),
				match;
		
			if (!moduleDef) {
				if (opts.suppressErrors) { return false; }
				var paths = [];
				for (var i = 0, p; p = possibilities[i]; ++i) { paths.push(p.path); }
				throw new Error(
					"requested import (" + modulePath + ") not found\n"
					+ "\tlooked in:\n"
						+ "\t\t" + paths.join('\n\t\t') + "\n"
						+ "\tImport Stack:\n"
						+ "\t\t" + importStack.join("\n\t\t"));
			}
		
			// a (potentially) nicer way to refer to a module -- how it was referenced in code when it was first imported
			moduleDef.friendlyPath = modulePath;
			
			// cache the base module's path in the path cache so we don't have to
			// try out all paths the next time we see the same base module.
			if (moduleDef.baseMod && !(moduleDef.baseMod in jsioPath.cache)) {
				jsioPath.cache[moduleDef.baseMod] = moduleDef.basePath;
			}

			// don't apply the standard preprocessors to base.js.  If we're reloading
			// the source code, always apply them.  We also don't want to run them
			// if they've been run once -- moduleDef.pre is set to true already
			// if we're reading the code from the source cache.
			if (modulePath != 'base' && (opts.reload || !opts.dontPreprocess && !moduleDef.pre)) {
				moduleDef.pre = true;

				applyPreprocessors(fromDir, moduleDef, ["import", "cls"], opts);

				// the order here is somewhat arbitrary and might be overly restrictive (... or overly powerful)
				// while (moduleDef.src.charAt(0) == '"' && (match = moduleDef.src.match(preprocessorCheck))) {
				// 	moduleDef.src = moduleDef.src.substring(match[0].length - 1);
				// 	applyPreprocessors(fromDir, moduleDef, match[1].split(','), opts);
				// }
			}

			// any additional preprocessors?
			if (opts.preprocessors) {
				applyPreprocessors(fromDir, moduleDef, opts.preprocessors, opts);
			}

			return moduleDef;
		}
	
		function applyPreprocessors(path, moduleDef, names, opts) {
			for (var i = 0, len = names.length; i < len; ++i) {
				p = getPreprocessor(names[i]);

				// if we have a recursive import and p isn't a function, just
				// skip it (handles the case where a preprocessor imports
				// other modules).
				if (p && typeof p == 'function') {
					p(path, moduleDef, opts);
				}
			}
		}
		
		function getPreprocessor(name) {
			var module = jsio.__modules['preprocessors.' + name];
			return typeof name == 'function'
				? name
				: (module && module.exports
					|| jsio('import preprocessors.' + name, {dontExport: true, dontPreprocess: true}));
		}
	
		function execModuleDef(context, moduleDef) {
			var src = moduleDef.src;
			delete moduleDef.src;

			var code = "(function(_){with(_){delete _;return function $$" + moduleDef.friendlyPath.replace(/[\:\\\/.]/g, '_') + "(){" + src + "\n}}})";
			var fn = ENV.eval(code, moduleDef.path, src);
			fn = fn(context);
			fn.call(context.exports);
		};
		
		function resolveImportRequest(context, request, opts) {
			var cmds = jsio.__cmds,
				imports = [],
				result = false;
		
			for (var i = 0, imp; imp = cmds[i]; ++i) {
				if ((result = imp(context, request, opts, imports))) { break; }
			}
		
			if (result !== true) {
				throw new (typeof SyntaxError != 'undefined' ? SyntaxError : Error)(String(result || 'invalid jsio command: jsio(\'' + request + '\')'));
			}
		
			return imports;
		};
	
		function makeContext(ctx, modulePath, moduleDef, dontAddBase) {
			if (!ctx) { ctx = {}; }
			if (!ctx.exports) { ctx.exports = {}; }

			ctx.jsio = util.bind(this, importer, ctx, moduleDef.directory, moduleDef.filename);
			ctx.require = function(request, opts) {
				if (!opts) { opts = {}; }
				opts.dontExport = true;
				// opts.suppressErrors = true;
				
				try {
					var ret = ctx.jsio(request, opts);
					if (ret === false) {
						// need this to trigger require attempt due to suppresserrors = true
						throw "module failed to load";
					} else {
						return ret;
					}
				} catch(e) {
					ENV.log('Error loading request ' + request + ':');
					ENV.log(e);
				}
			};
			
			ctx.module = {id: modulePath, exports: ctx.exports};
			if (!dontAddBase && modulePath != 'base') {
				ctx.jsio('from base import *', {dontPreprocess: true});
				ctx.logging.__create(modulePath, ctx);
			}
		
			// TODO: FIX for "trailing ." case
			ctx.jsio.__jsio = jsio;
			ctx.jsio.__env = jsio.__env;
			ctx.jsio.__dir = moduleDef.directory;
			ctx.jsio.__filename = moduleDef.filename;
			ctx.jsio.path = jsioPath;
			return ctx;
		};
		
		var importStack = [];
		function importer(boundContext, fromDir, fromFile, request, opts) {
			opts = opts || {};
			fromDir = fromDir || './';
			fromFile = fromFile || '<initial file>';
		
			// importer is bound to a module's (or global) context -- we can override this
			// by using opts.exportInto
			var exportInto = opts.exportInto || boundContext || ENV.global;
		
			// parse the import request(s)
			var imports = resolveImportRequest(exportInto, request, opts),
				numImports = imports.length,
				retVal = numImports > 1 ? {} : null;
		
			// import each requested item
			for (var i = 0; i < numImports; ++i) {
				var item = imports[i];
				var modulePath = item.from;
				var modules = jsio.__modules;
				var path;
				var moduleDef;
				var err;
				
				try {
					moduleDef = loadModule(fromDir, fromFile, modulePath, opts);
				} catch(e) {
					err = e;
				}

				if (moduleDef) {
					path = moduleDef.path;
				} else if (jsio.__env.require) {
					path = modulePath;
					try {
						modules[path] = {exports: jsio.__env.require(modulePath)};
						err = null;
					} catch (e2) {
						if (!err) { err = e2; }
					}
				} else if (moduleDef == false) {
					return false;
				}

				if (err) {
					if (opts.suppressErrors) { return false; }
					if (!err.jsioLogged) {
						ENV.log(
							'\nError loading module:\n',
							'\t[[', request, ']]\n',
							'\trequested by:', fromDir + fromFile, '\n',
							'\tcurrent directory:', jsio.__env.getCwd(), '\n',
							'\t' + err, '\n',
							'\t' + err.stack);
						err.jsioLogged = true;
					}

					throw err;
				}
				
				if (moduleDef) {
					importStack.push(importStack.length + ' : ' + moduleDef.friendlyPath + ' (' + moduleDef.path + ')');
				}
				
				// eval any packages that we don't know about already
				if (!(path in modules)) {
					var newContext = makeContext(opts.context, modulePath, moduleDef, item.dontAddBase);

					modules[path] = moduleDef;

					moduleDef.exports = newContext.exports;
					if (item.dontUseExports) {
						var src = [';(function(){'], k = 1;
						for (var j in item['import']) {
							newContext.exports[j] = undefined;
							src[k++] = 'if(typeof '+j+'!="undefined"&&exports.'+j+'==undefined)exports.'+j+'='+j+';';
						}
						src[k] = '})();';
						moduleDef.src += src.join('');
					}

					execModuleDef(newContext, moduleDef);
					moduleDef.exports = newContext.exports;
				}
				
				importStack.pop();
			
				var module = modules[path].exports;
			
				// return the module if we're only importing one module
				if (numImports == 1) { retVal = module; }
			
				if (!opts.dontExport) {
					// add the module to the current context
					if (item.as) {
						// remove trailing/leading dots
						var as = item.as.match(/^\.*(.*?)\.*$/)[1],
							segments = as.split('.'),
							kMax = segments.length - 1,
							c = exportInto;
				
						// build the object in the context
						for(var k = 0; k < kMax; ++k) {
							var segment = segments[k];
							if (!segment) continue;
							if (!c[segment]) { c[segment] = {}; }
							c = c[segment];
						}
					
						c[segments[kMax]] = module;
				
						// there can be multiple module imports with this syntax (import foo, bar)
						if (numImports > 1) {
							retVal[as] = module;
						}
					} else if (item['import']) {
						// there can only be one module import with this syntax 
						// (from foo import bar), so retVal will already be set here
						if (item['import']['*']) {
							for (var k in modules[path].exports) { exportInto[k] = module[k]; }
						} else {
							for (var k in item['import']) { exportInto[item['import'][k]] = module[k]; }
						}
					}
				}
			}
		
			return retVal;
		}
	
		// DEFINE SYNTAX FOR JSIO('cmd')
	
		// from myPackage import myFunc
		// external myPackage import myFunc
		jsio.addCmd(function(context, request, opts, imports) {
			var match = request.match(/^\s*(from|external)\s+([\w.$]+)\s+(import|grab)\s+(.*)$/);
			if(match) {
				imports.push({
					from: match[2],
					dontAddBase: match[1] == 'external',
					dontUseExports: match[3] == 'grab' || match[1] == 'external',
					'import': {}
				});
			
				match[4].replace(/\s*([\w.$*]+)(?:\s+as\s+([\w.$]+))?/g, function(_, item, as) {
					imports[0]['import'][item] = as || item;
				});
				return true;
			}
		});

		// import myPackage
		jsio.addCmd(function(context, request, opts, imports) {
			var match = request.match(/^\s*import\s+(.*)$/);
			if (match) {
				match[1].replace(/\s*([\w.$]+)(?:\s+as\s+([\w.$]+))?,?/g, function(_, fullPath, as) {
					imports.push(
						as ? {
							from: fullPath,
							as: as
						} : {
							from: fullPath,
							as: fullPath
						});
				});
				return true;
			}
		});

		// CommonJS syntax
		jsio.addCmd(function(context, request, opts, imports) {
		
			//		./../b -> ..b
			// 		../../b -> ...b
			// 		../b -> ..b
			// 		./b -> .b
		
			var match = request.match(/^\s*[\w.0-9$\/\-]+\s*$/);
			if (match) {
			
				var req = util.resolveRelativePath(match[0]),
					isRelative = req.charAt(0) == '.';
			
				req = req
					// .replace(/^\//, '') // remove any leading slash
					.replace(/\.\.\//g, '.') // replace relative path indicators with dots
					.replace(/\.\//g, '')
					.replace(/\//g, '.'); // any remaining slashes are path separators

				imports[0] = { from: (isRelative ? '.' : '') + req };
				return true;
			}
		});
		
		jsio.install = function() {
			jsio('from base import *');
			GLOBAL['logger'] = logging.get('jsiocore');
		};

		jsio.eval = function (src, path) {
			path = ENV.getCwd() || '/';
			var moduleDef = new ModuleDef(path);
			moduleDef.src = src;
			applyPreprocessors(path, moduleDef, ["import", "cls"], {});
			execModuleDef(ENV.global, moduleDef);
		};
		
		jsio.clone = util.bind(null, init, jsio);

		return jsio;
	}

	var J = init(null, {});
	if (typeof exports != 'undefined') {
		module.exports = J;
	} else {
		jsio = J;
	}
})();
jsio.path.set(["/Users/arnovandervegt/gameclosure/basil/sdk/jsio",".","../../../../sdk/api","../../../../sdk","../../../../sdk/timestep","../../../browser/lib","../../../native/lib","../../../social/lib"]);jsio.path.cache={"preprocessors":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio","base":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio","util":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio","runtimeBrowser":"../../../browser/lib","std":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio","lib":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio","device":"../../../../sdk/timestep","event":"../../../../sdk/timestep","ui":"../../../../sdk/timestep","math":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio","timer":"../../../../sdk/timestep","animate":"../../../../sdk/timestep","Sound":"../../../../sdk/timestep","_api":"../../../../sdk","api":"../../../../sdk","net":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio","GCDataSource":"../../../../sdk/api","squill":"../../../../sdk","GCSocial":"../../../social/lib","src":"."};jsio.setCache({"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/base.js":{"path":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/base.js","friendlyPath":"base","directory":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/","filename":"base.js","baseMod":"base","basePath":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio","src":"/**\n * base.js\n * This file contains all global functions provided by js.io.\n */\n\nexports.log = jsio.__env.log;\nexports.GLOBAL = jsio.__env.global;\n\n/**\n * Various polyfill methods to ensure js.io implementations provide\n * a baseline of JavaScript functionality. Feature compatibility (localStorage,\n * etc.) should be provided elsewhere.\n */\n\n// Array.isArray\n// Not available before ECMAScript 5.\n// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray\n\nif (!Array.isArray) {\n\tArray.isArray = function (arg) {\n\t\treturn Object.prototype.toString.call(arg) === '[object Array]';\n\t}\n};\n\n// Function.prototype.bind\n// Not available before ECMAScript 5.\n// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind\n\nif (!Function.prototype.bind) {\n  Function.prototype.bind = function (oThis) {\n    if (typeof this !== \"function\") {\n      // closest thing possible to the ECMAScript 5 internal IsCallable function\n      throw new TypeError(\"Function.prototype.bind - what is trying to be bound is not callable\");\n    }\n\n    var aArgs = Array.prototype.slice.call(arguments, 1), \n        fToBind = this, \n        fNOP = function () {},\n        fBound = function () {\n          return fToBind.apply(this instanceof fNOP\n                                 ? this\n                                 : oThis,\n                               aArgs.concat(Array.prototype.slice.call(arguments)));\n        };\n\n    fNOP.prototype = this.prototype;\n    fBound.prototype = new fNOP();\n\n    return fBound;\n  };\n}\n\n/**\n * DEPRECATED. Old js.io polyfills.\n */\n\nvar SLICE = Array.prototype.slice;\n\n/* Use native isArray if available\n */\nif (typeof Array.isArray === 'function') {\n\texports.isArray = Array.isArray;\n} else {\n\texports.isArray = function (obj) {\n\t\treturn Object.prototype.toString.call(obj) === '[object Array]';\n\t}\n}\n\nexports.bind = function(context, method /*, VARGS*/) {\n\tif(arguments.length > 2) {\n\t\tvar args = SLICE.call(arguments, 2);\n\t\treturn typeof method == 'string'\n\t\t\t? function __bound() {\n\t\t\t\tif (context[method]) {\n\t\t\t\t\treturn context[method].apply(context, args.concat(SLICE.call(arguments, 0)));\n\t\t\t\t} else {\n\t\t\t\t\tthrow logger.error('No method:', method, 'for context', context);\n\t\t\t\t}\n\t\t\t}\n\t\t\t: function __bound() { return method.apply(context, args.concat(SLICE.call(arguments, 0))); }\n\t} else {\n\t\treturn typeof method == 'string'\n\t\t\t? function __bound() {\n\t\t\t\tif (context[method]) {\n\t\t\t\t\treturn context[method].apply(context, arguments);\n\t\t\t\t} else {\n\t\t\t\t\tthrow logger.error('No method:', method, 'for context', context);\n\t\t\t\t}\n\t\t\t}\n\t\t\t: function __bound() { return method.apply(context, arguments); }\n\t}\n}\n\n/**\n * Class constructor.\n */\n\nexports.Class = function(name, parent, proto) {\n\treturn exports.__class__(function() { return this.init && this.init.apply(this, arguments); }, name, parent, proto);\n}\n\nexports.__class__ = function (cls, name, parent, proto) {\n\tvar clsProto = function () {};\n\tvar logger;\n\n\tif (typeof name != 'string') {\n\t\tproto = parent;\n\t\tparent = name;\n\t\tname = null;\n\t}\n\n\tif (name) {\n\t\tlogger = exports.logging.get(name);\n\t}\n\n\tif (!parent) { throw new Error('parent or prototype not provided'); }\n\tif (!proto) { proto = parent; parent = null; }\n\n\tif (parent) {\n\t\tif (exports.isArray(parent)) { // multiple inheritance, use at your own risk =)\n\t\t\tclsProto.prototype = {};\n\t\t\tfor(var i = 0, p; p = parent[i]; ++i) {\n\t\t\t\tif (p == Error && ErrorParentClass) { p = ErrorParentClass; }\n\t\t\t\tfor (var item in p.prototype) {\n\t\t\t\t\tif (!(item in clsProto.prototype)) {\n\t\t\t\t\t\tclsProto.prototype[item] = p.prototype[item];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tparent = parent[0];\n\t\t} else {\n\t\t\tif (parent == Error && ErrorParentClass) { parent = ErrorParentClass; }\n\t\t\tclsProto.prototype = parent.prototype;\n\t\t}\n\t}\n\t\n\tvar supr = parent ? function(context, method, args) {\n\t\t\tvar f = parent.prototype[method];\n\t\t\tif (!f) { throw new Error('method ' + method + ' does not exist'); }\n\t\t\treturn f.apply(context, args || []);\n\t\t} : null;\n\t\n\tvar p = cls.prototype = new clsProto();\n\tp.constructor = cls;\n\tp.__parentClass__ = parent;\n\tif (name) { p.__class__ = name; }\n\tproto.call(p, logger || supr, logger && supr);\n\treturn cls;\n}\n\nvar ErrorParentClass = exports.__class__(function ErrorCls() {\n\t\tvar err = Error.prototype.constructor.apply(this, arguments);\n\t\tfor (var prop in err) {\n\t\t\tif (err.hasOwnProperty(prop)) {\n\t\t\t\tthis[prop] = err[prop];\n\t\t\t}\n\t\t}\n\t}, function() {});\n\n/**\n * Merge two objects together.\n */\n\nexports.Class.defaults = \nexports.merge = function(base, extra) {\n\tbase = base || {};\n\t\n\tfor (var i = 1, len = arguments.length; i < len; ++i) {\n\t\tvar copyFrom = arguments[i];\n\t\tfor (var key in copyFrom) {\n\t\t\tif (copyFrom.hasOwnProperty(key) && !base.hasOwnProperty(key)) {\n\t\t\t\tbase[key] = copyFrom[key];\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn base;\n}\n\n/**\n * Create a timer delay.\n */\n\nexports.delay = function(orig, timeout) {\n\tvar _timer = null;\n\tvar ctx, args;\n\tvar f = function() { orig.apply(ctx, args); }\n\treturn function() {\n\t\tctx = this;\n\t\targs = arguments;\n\t\tif (_timer) { clearTimeout(_timer); }\n\t\t_timer = setTimeout(f, timeout || 0);\n\t}\n}\n\n/**\n * Log constructor and default \"logger\".\n */\n\nexports.logging = (function() {\n\t\n\t// logging namespace, this is what is exported\n\tvar logging = {\n\t\t\tDEBUG: 1,\n\t\t\tLOG: 2,\n\t\t\tINFO: 3,\n\t\t\tWARN: 4,\n\t\t\tERROR: 5,\n\t\t\tNONE: 10\n\t\t},\n\t\tloggers = {}, // effectively globals - all loggers and a global production state\n\t\tproduction = false;\n\tvar gPrefix = '';\n\tlogging.setPrefix = function(prefix) { gPrefix = prefix + ' '; }\n\tlogging.setProduction = function(prod) { production = !!prod; }\n\tlogging.get = function(name) {\n\t\treturn loggers.hasOwnProperty(name) ? loggers[name]\n\t\t\t: (loggers[name] = new Logger(name));\n\t}\n\tlogging.set = function(name, _logger) {\n\t\tloggers[name] = _logger;\n\t}\n\t\n\tlogging.getAll = function() { return loggers; }\n\n\tlogging.__create = function(pkg, ctx) { ctx.logger = logging.get(pkg); }\n\t\n\tvar Logger = exports.__class__(\n\t\tfunction Logger(name, level) {\n\t\t\tthis._name = name;\n\t\t\tthis._level = level || logging.LOG;\n\t\t},\n\t\tfunction () {\n\t\t\tthis.setLevel = function(level) { this._level = level; }\n\t\t\n\t\t\tfunction makeLogFunction(level, type) {\n\t\t\t\treturn function() {\n\t\t\t\t\tif (!production && level >= this._level) {\n\t\t\t\t\t\tvar prefix = type + ' ' + gPrefix + this._name,\n\t\t\t\t\t\t\tlistener = this._listener || exports.log;\n\t\t\t\t\t\t\n\t\t\t\t\t\treturn listener && listener.apply(this._listener, [prefix].concat(SLICE.call(arguments)));\n\t\t\t\t\t}\n\t\t\t\t\treturn arguments[0];\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tthis.setListener = function(listener) { this._listener = listener; }\n\t\t\tthis.debug = makeLogFunction(logging.DEBUG, \"DEBUG\");\n\t\t\tthis.log = makeLogFunction(logging.LOG, \"LOG\");\n\t\t\tthis.info = makeLogFunction(logging.INFO, \"INFO\");\n\t\t\tthis.warn = makeLogFunction(logging.WARN, \"WARN\");\n\t\t\tthis.error = makeLogFunction(logging.ERROR, \"ERROR\");\n\t\t});\n\n\treturn logging;\n})();\n\nvar logger = exports.logging.get('jsiocore');\n"},"../../../browser/lib/runtimeBrowser/launchClient.js":{"path":"../../../browser/lib/runtimeBrowser/launchClient.js","friendlyPath":"runtimeBrowser.launchClient","directory":"../../../browser/lib/runtimeBrowser/","filename":"launchClient.js","baseMod":"runtimeBrowser","basePath":"../../../browser/lib","src":"if (DEBUG) {\n\t// prefix filenames in the debugger\n\tjsio.__env.debugPath = function(path) { return 'http://' + window.location.host + '/' + path; }\n}\n\n// shims\n\nif (!window.JSON) {\n\tjsio('import std.JSON').createGlobal();\n}\n\nif (!window.localStorage) {\n\twindow.localStorage = {\n\t\tgetItem: function() {},\n\t\tsetItem: function() {},\n\t\tremoveItem: function() {}\n\t}\n}\n\n// device simulation\n\nif (DEBUG) {\n\t// parsing options\n\tjsio(\"import std.uri\");\n\tvar uri = new std.uri(window.location);\n\n\t// simulate device chrome, input, and userAgent\n\tvar sim_device = uri.query('device') || uri.hash('device');\n\tif (sim_device) {\n\t\t// hack to access SDK static resolutions file from a debug device\n\t\ttry {\n\t\t\tjsio(\"import preprocessors.import\");\n\t\t\tjsio(\"import preprocessors.cls\");\n\n\t\t\tjsio(\"import .simulateDevice\");\n\t\t\tjsio.__jsio(\"import ..util.resolutions\");\n\t\t\tjsio(\"import _api.client.nativeShim\"); \n\t\t\tsimulateDevice.simulate(util.resolutions.get(sim_device));\n\t\t} catch (e) {\n\t\t\tlogger.error(e);\n\t\t}\n\t}\n}\n\n// setup timestep device API\n\njsio(\"import device\");\ndevice.registerDevice('browser', 'runtimeBrowser.device');\ndevice.init();\n\n// logging\n\nif (DEBUG) {\n\t// logging\n\tvar initLogging = function (type, setPrefix) {\n\t\tif (setPrefix) {\n\t\t\t//once chrome stable upgrades to chrome 24, we can actually style this stuff with CSS!\n\t\t\tlogging.setPrefix(window._name + ': ', type);\n\t\t}\n\t\t\n\t\tjsio(\"import _api.client.debugLogger as debugLogger\");\n\n\t\tif (window.parent != window) { // are we in an iframe?\n\t\t\tdebugLogger.initLocalInspector();\n\t\t} else if (device.isMobileBrowser) {\n\t\t\tjsio(\"import net.env.browser.csp as csp\");\n\t\t\tdebugLogger.connect(csp.Connector, {url: 'http://' + window.location.host + '/plugins/native_debugger/mobile_csp'});\n\t\t}\n\t};\n\n\tvar initDebugging = function () {\n\t\tvar env = jsio.__env;\n\t\t\n\t\tvar originalSyntax = bind(env, env.checkSyntax);\n\t\tvar originalFetch = bind(env, env.fetch);\n\n\t\tenv.fetch = function(filename) {\n\t\t\tlogging.get('jsiocore').warn('LOADING EXTERNAL FILE:', filename);\n\t\t\treturn originalFetch.apply(this, arguments);\n\t\t}\n\t\t\n\t\tenv.checkSyntax = function(code, filename) {\n\t\t\tvar xhr = new XMLHttpRequest();\n\t\t\txhr.open('POST', '/.syntax', false);\n\t\t\txhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");\n\t\t\txhr.onreadystatechange = function() {\n\t\t\t\tif (xhr.readyState != 4) { return; }\n\t\t\t\n\t\t\t\tif (xhr.status == 200 && xhr.responseText) {\n\t\t\t\t\tvar err;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvar response = JSON.parse(xhr.responseText);\n\t\t\t\t\t\terr = response[1].stderr.replace(/^stdin:(\\d+):/mg, filename + ' line $1:');\n\t\t\t\t\t} catch(e) {\n\t\t\t\t\t\terr = xhr.responseText;\n\t\t\t\t\t}\n\n\t\t\t\t\tconsole.log(err);\n\t\t\t\t\t\n\t\t\t\t\tdocument.body.innerHTML = '<pre style=\\'font: bold 12px Monaco, \"Bitstream Vera Sans Mono\", \"Lucida Console\", Terminal, monospace; color: #FFF;\\'>' + err + '</err>';\n\t\t\t\t} else if (xhr.status > 0) {\n\t\t\t\t\toriginalSyntax(code, filename);\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\txhr.send('javascript=' + encodeURIComponent(code));\n\t\t}\n\t};\n\n\tvar displayName = uri.hash('displayName');\n\tinitLogging(displayName, true);\n\tinitDebugging();\n}\n\n// init sets up the GC object\njsio(\"import _api.client.init\");\nGC.__init__({ui: true, overlay: true});\n\nGC.buildApp('launchUI');\n","pre":true},"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/std/JSON.js":{"path":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/std/JSON.js","friendlyPath":"std.JSON","directory":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/std/","filename":"JSON.js","baseMod":"std","basePath":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio","src":"// Based on json2.js (version 2009-09-29) http://www.JSON.org/json2.js\n// exports createGlobal, stringify, parse, stringifyDate\n\n/**\n * if a global JSON object doesn't exist, create one\n */\nexports.createGlobal = function() {\n\tif(typeof JSON == 'undefined') { JSON = {}; }\n\tif(typeof JSON.stringify !== 'function') {\n\t\tJSON.stringify = exports.stringify;\n\t}\n\tif(typeof JSON.parse !== 'function') {\n\t\tJSON.parse = exports.parse;\n\t}\n};\n\n;(function() {\n\tvar cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n\t\tescapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n\t\tgap,\n\t\tindent,\n\t\tmeta = {\t// table of character substitutions\n\t\t\t'\\b': '\\\\b',\n\t\t\t'\\t': '\\\\t',\n\t\t\t'\\n': '\\\\n',\n\t\t\t'\\f': '\\\\f',\n\t\t\t'\\r': '\\\\r',\n\t\t\t'\"' : '\\\\\"',\n\t\t\t'\\\\': '\\\\\\\\'\n\t\t},\n\t\trep;\n\t\n\tfunction quote(string) {\n\t\t// quote the string if it doesn't contain control characters, quote characters, and backslash characters\n\t\t// otherwise, replace those characters with safe escape sequences\n\t\tescapable.lastIndex = 0;\n\t\treturn escapable.test(string)\n\t\t\t? '\"' + string.replace(escapable, function (a) {\n\t\t\t\t\tvar c = meta[a];\n\t\t\t\t\treturn typeof c === 'string' ? c : '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n\t\t\t\t}) + '\"'\n\t\t\t: '\"' + string + '\"';\n\t}\n\t\n\t// Produce a string from holder[key].\n\tfunction str(key, holder) {\n\t\tvar mind = gap, value = holder[key];\n\t\t\n\t\t// If the value has a toJSON method, call it to obtain a replacement value.\n\t\tif (value && typeof value === 'object' && typeof value.toJSON === 'function') {\n\t\t\tvalue = value.toJSON(key);\n\t\t}\n\t\t\n\t\t// If we were called with a replacer function, then call the replacer to\n\t\t// obtain a replacement value.\n\t\tif (typeof rep === 'function') { value = rep.call(holder, key, value); }\n\t\t\n\t\tswitch (typeof value) {\n\t\t\tcase 'string':\n\t\t\t\treturn quote(value);\n\t\t\tcase 'number':\n\t\t\t\t// JSON numbers must be finite\n\t\t\t\treturn isFinite(value) ? String(value) : 'null';\n\t\t\tcase 'boolean':\n\t\t\t\treturn String(value);\n\t\t\tcase 'object': // object, array, date, null\n\t\t\t\tif (value === null) { return 'null'; } // typeof null == 'object'\n\t\t\t\tif (value.constructor === Date) { return exports.stringifyDate(value); }\n\t\t\t\n\t\t\t\tgap += indent;\n\t\t\t\tvar partial = [];\n\t\t\t\t\n\t\t\t\t// Is the value an array?\n\t\t\t\tif (value.constructor === Array) {\n\t\t\t\t\tvar length = value.length;\n\t\t\t\t\tfor (var i = 0; i < length; i += 1) {\n\t\t\t\t\t\tpartial[i] = str(i, value) || 'null';\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Join all of the elements together, separated with commas, and wrap them in brackets.\n\t\t\t\t\tvar v = partial.length === 0 ? '[]' :\n\t\t\t\t\t\tgap ? '[\\n' + gap +\n\t\t\t\t\t\t\t\tpartial.join(',\\n' + gap) + '\\n' +\n\t\t\t\t\t\t\t\t\tmind + ']' :\n\t\t\t\t\t\t\t  '[' + partial.join(',') + ']';\n\t\t\t\t\tgap = mind;\n\t\t\t\t\treturn v;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (rep && typeof rep === 'object') { // rep is an array\n\t\t\t\t\tvar length = rep.length;\n\t\t\t\t\tfor (var i = 0; i < length; i += 1) {\n\t\t\t\t\t\tvar k = rep[i];\n\t\t\t\t\t\tif (typeof k === 'string') {\n\t\t\t\t\t\t\tvar v = str(k, value);\n\t\t\t\t\t\t\tif (v) {\n\t\t\t\t\t\t\t\tpartial.push(quote(k) + (gap ? ': ' : ':') + v);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else { // iterate through all of the keys in the object.\n\t\t\t\t\tfor (var k in value) {\n\t\t\t\t\t\tif (Object.hasOwnProperty.call(value, k)) {\n\t\t\t\t\t\t\tvar v = str(k, value);\n\t\t\t\t\t\t\tif (v) {\n\t\t\t\t\t\t\t\tpartial.push(quote(k) + (gap ? ': ' : ':') + v);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Join all of the member texts together, separated with commas,\n\t\t\t\t// and wrap them in braces.\n\t\t\t\tvar v = partial.length === 0 ? '{}' :\n\t\t\t\t\tgap ? '{\\n' + gap + partial.join(',\\n' + gap) + '\\n' +\n\t\t\t\t\t\t\tmind + '}' : '{' + partial.join(',') + '}';\n\t\t\t\tgap = mind;\n\t\t\t\treturn v;\n\t\t}\n\t}\n\n\n\t/**\n\t * The stringify method takes a value and an optional replacer, and an optional\n\t * space parameter, and returns a JSON text. The replacer can be a function\n\t * that can replace values, or an array of strings that will select the keys.\n \t * A default replacer method can be provided. Use of the space parameter can\n\t * produce text that is more easily readable.\n\t */\n\texports.stringify = function (value, replacer, space) {\n\t\tgap = '';\n\t\tindent = '';\n\t\t\n\t\t// If the space parameter is a number, make an indent string containing that many spaces.\n\t\tif (typeof space === 'number') {\n\t\t\tfor (var i = 0; i < space; i += 1) {\n\t\t\t\tindent += ' ';\n\t\t\t}\n\t\t} else if (typeof space === 'string') {\n\t\t\tindent = space;\n\t\t}\n\t\t\n\t\t// If there is a replacer, it must be a function or an array.\n\t\trep = replacer;\n\t\tif (replacer && typeof replacer !== 'function' &&\n\t\t\t\t(typeof replacer !== 'object' ||\n\t\t\t\t typeof replacer.length !== 'number')) {\n\t\t\tthrow new Error('JSON stringify: invalid replacer');\n\t\t}\n\t\t\n\t\t// Make a fake root object containing our value under the key of ''.\n\t\t// Return the result of stringifying the value.\n\t\treturn str('', {'': value});\n\t};\n\t\n\texports.stringifyDate = function(d) {\n\t\tvar year = d.getUTCFullYear(),\n\t\t\tmonth = d.getUTCMonth() + 1,\n\t\t\tday = d.getUTCDate(),\n\t\t\thours = d.getUTCHours(),\n\t\t\tminutes = d.getUTCMinutes(),\n\t\t\tseconds = d.getUTCSeconds(),\n\t\t\tms = d.getUTCMilliseconds();\n\t\t\n\t\tif (month < 10) { month = '0' + month; }\n\t\tif (day < 10) { day = '0' + day; }\n\t\tif (hours < 10) { hours = '0' + hours; }\n\t\tif (minutes < 10) { minutes = '0' + minutes; }\n\t\tif (seconds < 10) { seconds = '0' + seconds; }\n\t\tif (ms < 10) { ms = '00' + ms; }\n\t\telse if (ms < 100) { ms = '0' + ms; }\n\n\t\treturn '\"' + year\n\t\t\t+ '-' + month\n\t\t\t+ '-' + day\n\t\t\t+ 'T' + hours\n\t\t\t+ ':' + minutes\n\t\t\t+ ':' + seconds\n\t\t\t+ '.' + ms\n\t\t\t+ 'Z\"';\n\t}\n\t\n\t/**\n\t * The parse method takes a text and an optional reviver function, and returns\n\t * a JavaScript value if the text is a valid JSON text.\n\t */\n\texports.parse = function (text, reviver) {\n\t\t// Parsing happens in four stages. In the first stage, we replace certain\n\t\t// Unicode characters with escape sequences. JavaScript handles many characters\n\t\t// incorrectly, either silently deleting them, or treating them as line endings.\n\t\tcx.lastIndex = 0;\n\t\tif (cx.test(text)) {\n\t\t\ttext = text.replace(cx, function (a) {\n\t\t\t\treturn '\\\\u' +\n\t\t\t\t\t('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n\t\t\t});\n\t\t}\n\t\t\n\t\t// In the second stage, we run the text against regular expressions that look\n\t\t// for non-JSON patterns. We are especially concerned with '()' and 'new'\n\t\t// because they can cause invocation, and '=' because it can cause mutation.\n\t\t// But just to be safe, we want to reject all unexpected forms.\n\n\t\t// We split the second stage into 4 regexp operations in order to work around\n\t\t// crippling inefficiencies in IE's and Safari's regexp engines. First we\n\t\t// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we\n\t\t// replace all simple value tokens with ']' characters. Third, we delete all\n\t\t// open brackets that follow a colon or comma or that begin the text. Finally,\n\t\t// we look to see that the remaining characters are only whitespace or ']' or\n\t\t// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.\n\n\t\tif (/^[\\],:{}\\s]*$/\n\t\t\t\t.test(text.replace(/\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')\n\t\t\t\t.replace(/\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g, ']')\n\t\t\t\t.replace(/(?:^|:|,)(?:\\s*\\[)+/g, '')))\n\t\t{\n\t\t\tvar j = eval('(' + text + ')');\n\t\t\tif(!reviver) {\n\t\t\t\treturn j;\n\t\t\t} else {\n\t\t\t\t// In the optional fourth stage, we recursively walk the new structure, passing\n\t\t\t\t// each name/value pair to a reviver function for possible transformation.\n\t\t\t\tvar walk = function(holder, key) {\n\t\t\t\t\t// The walk method is used to recursively walk the resulting structure so\n\t\t\t\t\t// that modifications can be made.\n\t\t\t\t\tvar k, v, value = holder[key];\n\t\t\t\t\tif (value && typeof value === 'object') {\n\t\t\t\t\t\tfor (k in value) {\n\t\t\t\t\t\t\tif (Object.hasOwnProperty.call(value, k)) {\n\t\t\t\t\t\t\t\tv = walk(value, k);\n\t\t\t\t\t\t\t\tif (v !== undefined) {\n\t\t\t\t\t\t\t\t\tvalue[k] = v;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tdelete value[k];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn reviver.call(holder, key, value);\n\t\t\t\t}\n\t\t\t\treturn walk({'': j}, '');\n\t\t\t}\n\t\t}\n\n\t\t// If the text is not JSON parseable, then a SyntaxError is thrown.\n\t\tthrow new SyntaxError('JSON.parse');\n\t};\n}());","pre":true},"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/std/uri.js":{"path":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/std/uri.js","friendlyPath":"std.uri","directory":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/std/","filename":"uri.js","src":"var attrs = [ \n\t\"source\",\n\t\"protocol\",\n\t\"authority\",\n\t\"userInfo\",\n\t\"user\",\n\t\"password\",\n\t\"host\",\n\t\"port\",\n\t\"relative\",\n\t\"path\",\n\t\"directory\",\n\t\"file\",\n\t\"query\",\n\t\"anchor\"\n];\n\nvar Users_arnovandervegt_gameclosure_basil_sdk_jsio_std_uri=__class__;var URI = exports=Users_arnovandervegt_gameclosure_basil_sdk_jsio_std_uri(function Users_arnovandervegt_gameclosure_basil_sdk_jsio_std_uri(){return this.init&&this.init.apply(this,arguments)},function(supr) {\n\tthis.init = function(url, isStrict) {\n\t\tif (url instanceof URI) {\n\t\t\tfor (var i = 0, attr; attr = attrs[i]; ++i) {\n\t\t\t\tthis['_' + attr] = url['_' + attr];\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tthis._isStrict = isStrict;\n\t\t\n\t\tvar uriData = exports.parse(url, isStrict);\n\t\tfor (var attr in uriData) {\n\t\t\tthis['_' + attr] = uriData[attr];\n\t\t};\n\t}\n  \n\tfor (var i = 0, attr; attr = attrs[i]; ++i) {\n\t\t(function(attr) {\n\t\t\tvar fNameSuffix = attr.charAt(0).toUpperCase() + attr.slice(1);\n\t\t\tthis['get' + fNameSuffix] = function() {\n\t\t\t\treturn this['_' + attr];\n\t\t\t};\n\t\t\tthis['set' + fNameSuffix] = function(val) {\n\t\t\t\tthis['_' + attr] = val;\n\t\t\t\treturn this;\n\t\t\t};\n\t\t}).call(this, attr);\n\t};\n\t\n\tthis.query = function(key) { return exports.parseQuery(this._query)[key]; }\n\tthis.hash = function(key) { return exports.parseQuery(this._anchor)[key]; }\n\t\n\tthis.addHash = function(kvp) {\n\t\tvar hash = exports.parseQuery(this._anchor);\n\t\tfor (var i in kvp) { hash[i] = kvp[i]; }\n\t\tthis._anchor = exports.buildQuery(hash);\n\t\treturn this;\n\t}\n\t\n\tthis.push = function(path) {\n\t\tif (path) {\n\t\t\tthis._path = (this._path + '/' + path).replace(/\\/\\/+/g, '/');\n\t\t}\n\t\treturn this;\n\t}\n\t\n\tthis.addQuery = function(kvp) {\n\t\tvar query = exports.parseQuery(this._query);\n\t\tfor (var i in kvp) { query[i] = kvp[i]; }\n\t\tthis._query = exports.buildQuery(query);\n\t\treturn this;\n\t}\n\t\n\tthis.removeQuery = function(keys) {\n\t\tvar query = exports.parseQuery(this._query);\n\t\tif (isArray(keys)) {\n\t\t\tfor (var i = 0, n = keys.length; i < n; ++i) {\n\t\t\t\tdelete query[keys[i]];\n\t\t\t}\n\t\t} else {\n\t\t\tdelete query[keys];\n\t\t}\n\t\tthis._query = exports.buildQuery(query);\n\t\treturn this;\n\t}\n\n\tthis.toJSON = function() { return this.toString(false); }\n\n\tthis.toString = function(onlyBase) {\n\t\t// XXX TODO: This is vaguely reasonable, but not complete. fix it...\n\t\tvar a = this._protocol ? this._protocol + \"://\" : \"\"\n\t\tvar b = this._host ? this._host + ((this._port || 80) == 80 ? \"\" : \":\" + this._port) : \"\";\n\t\t\n\t\tif (onlyBase) {\n\t\t\treturn a + b;\n\t\t}\n\t\t\n\t\tvar c = this._path;\n\t\tvar d = this._query ? '?' + this._query : '';\n\t\tvar e = this._anchor ? '#' + this._anchor : '';\n\t\treturn a + b + c + d + e;\n\t};\n});\n\nexports.relativeTo = function(url, base) {\n\tvar url = String(url);\n\tif (base && !/^http(s?):\\/\\//.test(url)) {\n\t\tvar baseURI = new exports(base)\n\t\t\t.setAnchor('')\n\t\t\t.setQuery('')\n\t\t\t.setFile('')\n\t\t\t.toString(url.charAt(0) == '/');\n\n\t\turl = exports.resolveRelative(baseURI + url);\n\t}\n\n\treturn new URI(url);\n}\n\nexports.resolveRelative = function(url) {\n\tvar prevUrl;\n\t\n\t// remove ../ with preceeding folder\n\twhile((prevUrl = url) != (url = url.replace(/(^|\\/)([^\\/]+)\\/\\.\\.\\//g, '/'))) {};\n\t\n\t// remove ./ if it isn't preceeded by a .\n\treturn url.replace(/[^.]\\.\\//g, '');\n}\n\nexports.buildQuery = function(kvp) {\n\tvar pairs = [];\n\tfor (var key in kvp) {\n\t\tpairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(kvp[key]));\n\t}\n\treturn pairs.join('&');\n}\n\nexports.parseQuery = function(str) {\n\tvar pairs = str.split('&'),\n\t\tn = pairs.length,\n\t\tdata = {};\n\tfor (var i = 0; i < n; ++i) {\n\t\tvar pair = pairs[i].split('='),\n\t\t\tkey = decodeURIComponent(pair[0]);\n\t\tif (key) { data[key] = decodeURIComponent(pair[1]); }\n\t}\n\treturn data;\n}\n\n// Regexs are based on parseUri 1.2.2\n// Original: (c) Steven Levithan <stevenlevithan.com>\n// Original: MIT License\n\nvar strictRegex = /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?))?((((?:[^?#\\/]*\\/)*)([^?#]*))(?:\\?([^#]*))?(?:#(.*))?)/;\nvar looseRegex = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\nvar queryStringRegex = /(?:^|&)([^&=]*)=?([^&]*)/g;\n\nexports.parse = function(str, isStrict) {\n\tvar regex = isStrict ? strictRegex : looseRegex;\n\tvar result = {};\n\tvar match = regex.exec(str);\n\tfor (var i = 0, attr; attr = attrs[i]; ++i) {\n\t\tresult[attr] = match[i] || \"\";\n\t}\n\t\n\tvar qs = result['queryKey'] = {};\n\tresult['query'].replace(queryStringRegex, function(check, key, val) {\n\t\tif (check) {\n\t\t\tqs[key] = val;\n\t\t}\n\t});\n\t\n\treturn result;\n}\n\nexports.isSameDomain = function(urlA, urlB) {\n\tvar a = exports.parse(urlA);\n\tvar b = exports.parse(urlB);\n\treturn ((a.port == b.port ) && (a.host == b.host) && (a.protocol == b.protocol));\n};\n","pre":true},"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/preprocessors/import.js":{"path":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/preprocessors/import.js","friendlyPath":"preprocessors.import","directory":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/preprocessors/","filename":"import.js","src":"var importExpr = /^(\\s*)(import\\s+[^=+*\"'\\r\\n;\\/]+|from\\s+[^=+\"'\\r\\n;\\/]+)(;|\\/|$)/gm;\n\nfunction replace(raw, p1, p2, p3) {\n\tif (!/\\/\\//.test(p1)) {\n\t\treturn p1 + 'jsio(\"' + p2 + '\")' + p3;\n\t}\n\treturn raw;\n}\n\nexports = function (path, moduleDef, opts) {\n\tmoduleDef.src = moduleDef.src.replace(importExpr, replace);\n}\n","pre":true},"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/preprocessors/cls.js":{"path":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/preprocessors/cls.js","friendlyPath":"preprocessors.cls","directory":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/preprocessors/","filename":"cls.js","src":"\n// var F = exports = Class\n// exports = Class\nvar classExport = /^(.*?)exports[ \\t]*=[ \\t]*Class\\(/gm;\n\n// var F = Class\n// exports.F = Class\n// var F = exports.F = Class\nvar class2Export = /^(.*?[ \\t]+)?([a-zA-Z0-9\\.$]+)[ \\t]*=[ \\t]*Class\\(/gm;\n\nfunction replacer(base, prefix, name) {\n\treturn name + '=__class__;' + (prefix || '') + name + '=' + name + '(function ' + name.replace(/[\\.]/g, '_') + '(){return this.init&&this.init.apply(this,arguments)},';\n}\n\nexports = function(path, moduleDef, opts) {\n\tvar moduleCtor = moduleDef.path.replace(/(^[.\\/]+|\\.([^.]+?)$)/g, '').replace(/[\\:\\\\\\/\\-\\.]/g, '_');\n\tmoduleDef.src = moduleDef.src\n\t\t.replace(classExport, 'var ' + moduleCtor + '=__class__;$1exports=' + moduleCtor + '(function ' + moduleCtor + '(){return this.init&&this.init.apply(this,arguments)},')\n\t\t.replace(class2Export, replacer);\n}\n","pre":true},"../../../browser/lib/runtimeBrowser/simulateDevice.js":{"path":"../../../browser/lib/runtimeBrowser/simulateDevice.js","friendlyPath":".simulateDevice","directory":"../../../browser/lib/runtimeBrowser/","filename":"simulateDevice.js","src":"jsio(\"import lib.Enum\");\n\n// TODO: add isMobileNative and isMobileBrowser into resolutions.js (don't need to do a lookup) and remove these Enums\nvar mobile = new lib.Enum('ipad', 'iphone', 'ios', 'nexus');\nvar mobileBrowser = new lib.Enum('iphone-browser', 'ipad-browser', 'nexus-s-browser');\n\nexports.simulate = function(params) {\n\tif (params.userAgent) {\n\t\tvar navigator = window.navigator;\n\t\tvar shim = window.navigator = {};\n\t\tfor (var i in navigator) {\n\t\t\tshim[i] = navigator[i];\n\t\t}\n\n\t\tshim.userAgent = params.userAgent;\n\t}\n\n\tif (params.devicePixelRatio) {\n\t\twindow.devicePixelRatio = params.devicePixelRatio;\n\t}\n\n\tjsio(\"import device\");\n\n\tvar deviceName = params.name.toLowerCase();\n\t\n\tdevice.simulating = params;\n\tdevice.simulatingMobileNative = deviceName in mobile;\n\tdevice.simulatingMobileBrowser = deviceName in mobileBrowser;\n\t\n\tif (device.simulatingMobileBrowser) {\n\t\tdevice.isMobileBrowser = true;\n\t\tdevice.setUseDOM(true);\n\t}\n\n\tif (device.simulatingMobileNative) {\n\t\tdevice.setUseDOM(false);\n\t}\n\n}\n","pre":true},"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/lib/Enum.js":{"path":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/lib/Enum.js","friendlyPath":"lib.Enum","directory":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/lib/","filename":"Enum.js","baseMod":"lib","basePath":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio","src":"exports = function() {\n\tif (arguments.length == 1) {\n\t\tif (typeof arguments[0] == 'object') {\n\t\t\tvar obj = arguments[0];\n\t\t\tfor (var i in obj) {\n\t\t\t\tif (!(obj[i] in obj)) {\n\t\t\t\t\tobj[obj[i]] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn obj;\n\t\t} else if (typeof arguments[0] != 'string') {\n\t\t\tkeys = arguments[0];\n\t\t}\n\t}\n\t\n\tif (!keys) { var keys = arguments; }\n\tvar obj = {};\n\tfor(var i = 0, len = keys.length; i < len; ++i) {\n\t\tif (keys[i]) {\n\t\t\tobj[keys[i]] = i + 1;\n\t\t}\n\t\tobj[i + 1] = keys[i];\n\t}\n\treturn obj;\n}","pre":true},"../../../../sdk/timestep/device.js":{"path":"../../../../sdk/timestep/device.js","friendlyPath":"device","directory":"../../../../sdk/timestep/","filename":"device.js","baseMod":"device","basePath":"../../../../sdk/timestep","src":"/**\n * @module device;\n *\n * Namespace for the current device. Determines what device we're running using\n * navigator.userAgent. This namespace exposes various properties about the\n * current device, such as screen size, mobile/browser, pixel ratios, etc.\n *\n * Using device.get('...') imports device-specific implementations from\n *   timestep.env.* by default, or from packages registered using\n *   registerDevice().\n * Using device.importUI('...') imports rendering classes for DOM or canvas.\n *\n * @doc http://doc.gameclosure.com/api/device.html\n * @docsrc https://github.com/gameclosure/doc/blob/master/api/device.md\n */\n\njsio(\"import event.Emitter as Emitter\");\n\nif (typeof navigator == 'undefined' || !navigator.userAgent) {\n\tlogger.warn('> Timestep was unable to determine your device! Please check that navigator.userAgent is defined.');\n\texports = {isUnknown: true};\n}\n\nvar ua = navigator.userAgent;\n\n/**\n * @namespace\n */\n\nvar _devices = {}\nexports.registerDevice = function(name, path) {\n\t_devices[name] = path;\n}\n\nexports.get = function (module) {\n\tvar path = _devices[exports.name] || 'runtimeBrowser.device';\n\treturn jsio('import ' + path + '.' + module, {dontExport: true, suppressErrors: true});\n};\n\nexports.importUI = function (module) {\n\treturn jsio('import ui.backend.' + (exports.useDOM ? 'dom' : 'canvas') + '.' + module, {dontExport: true, suppressErrors: true});\n};\n\nexports.isMobileNative = exports.isMobile = /TeaLeaf/.test(ua);\n\nlogger.log(exports.isMobile ? 'on mobile device' : 'in web browser');\n\nexports.screen = new Emitter();\n\nvar devicePixelRatio = window.devicePixelRatio || 1;\n\n// @deprecated\nexports.devicePixelRatio = devicePixelRatio;\n\nexports.screen.devicePixelRatio = devicePixelRatio;\nexports.screen.width = window.screen.width * devicePixelRatio;\nexports.screen.height = window.screen.height * devicePixelRatio;\n\n// This is stubbed out unless available on the current device.\nexports.hideAddressBar = function() {};\n\nexports.defaultFontFamily = 'Helvetica';\n\nif ('ontouchstart' in window && (!/BlackBerry/.test(ua))) {\n\texports.events = {\n\t\tstart: 'touchstart',\n\t\tmove: 'touchmove',\n\t\tend: 'touchend'\n\t};\n} else {\n\texports.events = {\n\t\tstart: 'mousedown',\n\t\tmove: 'mousemove',\n\t\tend: 'mouseup'\n\t};\n}\n\nexports.isMobileBrowser = false;\nexports.isUIWebView = false;\nexports.isSafari = /Safari/.test(ua);\n\nif (exports.isMobile) {\n\texports.name = 'tealeaf';\n\texports.width = navigator.width;\n\texports.height = navigator.height;\n\texports.isIOS = /iPhone OS/.test(ua);\n\texports.isAndroid = /Android/.test(ua);\n} else {\n\tif (/(iPod|iPhone|iPad)/i.test(ua)) {\n\t\texports.name = 'browser';\n\t\texports.isMobileBrowser = true;\n\t\texports.isIOS = true;\n\t\texports.isUIWebView = !exports.isSafari;\n\n\t\texports.screen.defaultOrientation = 'portrait';\n\t\texports.screen.browserChrome = {\n\t\t\tportrait: {top: 20 * devicePixelRatio, bottom: 44 * devicePixelRatio},\n\t\t\tlandscape: {top: 20 * devicePixelRatio, bottom: 32 * devicePixelRatio}\n\t\t};\n\n\t} else if (/Mobile Safari/.test(ua) || /Android/.test(ua) || /BlackBerry/.test(ua)) {\n\t\texports.name = 'browser';\n\t\texports.isMobileBrowser = true;\n\t\texports.isAndroid = true;\n\n\t\texports.screen.width = window.outerWidth;\n\t\texports.screen.height = window.outerHeight - 1;\n\n\t\texports.screen.defaultOrientation = 'portrait';\n\t\texports.screen.browserChrome = {\n\t\t\tportrait: {top: 0, bottom: 0},\n\t\t\tlandscape: {top: 0, bottom: 0}\n\t\t};\n\t} else {\n\t\t// All other browsers\n\t\texports.height = 600;\n\t\texports.width = 800;\n\n\t\texports.name = 'browser';\n\t\texports.canResize = false;\n\t}\n}\n\nexports.useDOM = false;\nexports.setUseDOM = function (useDOM) {\n\tif (exports.useDOM != useDOM) {\n\t\texports.useDOM = useDOM;\n\n\t\tjsio(\"import ui.View as View\");\n\t\tvar backing = exports.importUI('ViewBacking');\n\t\tView.setDefaultViewBacking(backing);\n\t}\n}\n\nexports.getDimensions = function(isLandscape) {\n\tvar dMin = Math.min(exports.width, exports.height),\n\t\tdMax = Math.max(exports.width, exports.height);\n\n\treturn isLandscape\n\t\t? {height: dMin, width: dMax}\n\t\t: {height: dMax, width: dMin};\n}\n\n/**\n * Initialize the device. Called from somewhere else.\n */\n\nexports.init = function() {\n\tjsio(\"import ui.init\");\n\texports.get('initialize');\n\texports.screen.width = exports.width;\n\texports.screen.height = exports.height;\n}\n\n/**\n * Global device accessibility controls. Muting, click, color, font changing, etc.\n */\n\nGLOBAL.ACCESSIBILITY = new (Class(Emitter, function (supr) {\n\tthis.muted = false;\n\n\tthis.mute = function (flag) {\n\t\tthis.muted = flag;\n\t\tthis.publish('MuteChange');\n\t};\n}));\n\nif (GLOBAL.ONACCESSIBLE) {\n\tGLOBAL.ONACCESSIBLE();\n}","pre":true},"../../../../sdk/timestep/event/Emitter.js":{"path":"../../../../sdk/timestep/event/Emitter.js","friendlyPath":"event.Emitter","directory":"../../../../sdk/timestep/event/","filename":"Emitter.js","baseMod":"event","basePath":"../../../../sdk/timestep","src":"/**\n * @class event.Emitter;\n * Namespace shim to bring in PubSub from jsio.\n *\n * @doc http://doc.gameclosure.com/api/event.html#class-event.emitter\n * @docsrc https://github.com/gameclosure/doc/blob/master/api/event.md\n */\n\njsio(\"import lib.PubSub as exports\");\n","pre":true},"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/lib/PubSub.js":{"path":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/lib/PubSub.js","friendlyPath":"lib.PubSub","directory":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/lib/","filename":"PubSub.js","src":"/**\n * Summary: inherit from lib.PubSub if a class wants publish/subscribe ability\n * Methods:\n *  - publish(signal, args...) - all subscribers to signal will be called\n *     with the list of arguments provided.\n *  - subscribe(signal, ctx, method, args...) - register a bound method\n *     to a signal.  Any args that are passed in will be the first args\n *     when the method is invoked during a publish.\n *  Usage notes: There is one special signal '__any'.  Any subscribers to\n *     '__any' will be called on every publish with the first publish\n *     argument being the signal itself (after any args passed in during\n *     the corresponding subscribe).\n *     Calling the super constructor is not required for descendants of\n *     lib.PubSub.\n */\n\nvar ctx = jsio.__env.global,\n\tSLICE = Array.prototype.slice;\n\nvar Users_arnovandervegt_gameclosure_basil_sdk_jsio_lib_PubSub=__class__;exports=Users_arnovandervegt_gameclosure_basil_sdk_jsio_lib_PubSub(function Users_arnovandervegt_gameclosure_basil_sdk_jsio_lib_PubSub(){return this.init&&this.init.apply(this,arguments)},function () {\n\n\tthis.init = function () {};\n\n\tthis.publish = function (signal) {\n\t\tif (this._subscribers) {\n\t\t\tvar args = SLICE.call(arguments, 1);\n\t\t\tif (this._subscribers.__any) {\n\t\t\t\tvar anyArgs = [signal].concat(args),\n\t\t\t\t\tsubs = this._subscribers.__any.slice(0);\n\t\t\t\tfor(var i = 0, sub; sub = subs[i]; ++i) {\n\t\t\t\t\tsub.apply(ctx, anyArgs);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!this._subscribers[signal]) {\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tvar subs = this._subscribers[signal].slice(0);\n\t\t\tfor (var i = 0, sub; sub = subs[i]; ++i) {\n\t\t\t\tsub.apply(ctx, args);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t};\n\n\tthis.subscribe = function (signal, ctx, method) {\n\t\tvar cb;\n\t\tif (arguments.length == 2) {\n\t\t\tcb = ctx;\n\t\t} else {\n\t\t\tcb = bind.apply(GLOBAL, SLICE.call(arguments, 1));\n\t\t\tcb._ctx = ctx; // references for unsubscription\n\t\t\tcb._method = method;\n\t\t}\n\n\t\tvar s = this._subscribers || (this._subscribers = {});\n\t\t(s[signal] || (s[signal] = [])).push(cb);\n\t\treturn this;\n\t};\n\n\tthis.subscribeOnce = function (signal, ctx, method) {\n\t\tvar args = arguments,\n\t\t\tcb = bind(this, function () {\n\t\t\t\tthis.unsubscribe(signal, cb);\n\t\t\t\tif (args.length == 2) {\n\t\t\t\t\tctx.apply(GLOBAL, arguments);\n\t\t\t\t} else {\n\t\t\t\t\tbind.apply(GLOBAL, SLICE.call(args, 1))\n\t\t\t\t\t\t.apply(GLOBAL, arguments);\n\t\t\t\t}\n\t\t\t});\n\n\t\tif (args.length === 3) {\n\t\t\tcb._ctx = ctx;\n\t\t\tcb._method = method;\n\t\t}\n\n\t\treturn this.subscribe(signal, cb);\n\t};\n\n\t// If no method is specified, all subscriptions with a callback context\n\t// of ctx will be removed.\n\n\tthis.unsubscribe = function (signal, ctx, method) {\n\t\tif (!this._subscribers || !this._subscribers[signal]) {\n\t\t\treturn this;\n\t\t}\n\t\tvar subs = this._subscribers[signal];\n\t\tfor (var i = 0, c; c = subs[i]; ++i) {\n\t\t\tif (c == ctx || c._ctx == ctx && (!method || c._method == method)) {\n\t\t\t\tsubs.splice(i--, 1);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t * EventEmitter-style API\n\t * http://nodejs.org/api/events.html\n\t */\n\n\tthis.listeners = function (type) {\n\t\tthis._subscribers = (this._subscribers ? this._subscribers : {});\n\t\treturn (this.hasOwnProperty.call(this._subscribers, type))\n\t\t\t? this._subscribers[type]\n\t\t\t: (this._subscribers[type] = []);\n\t};\n\n\tthis.addListener = this.on = function (type, f) {\n\t\tif (this.listeners(type).length + 1 > this._maxListeners && this._maxListeners !== 0) {\n\t\t\tif (typeof console !== \"undefined\") {\n\t\t\t\tconsole.warn(\"Possible EventEmitter memory leak detected. \" + this._subscribers[type].length + \" listeners added. Use emitter.setMaxListeners() to increase limit.\");\n\t\t\t\tconsole.warn(\"stack trace:\", new Error().stack);\n\t\t\t}\n\t\t}\n\t\tthis.emit(\"newListener\", type, f);\n\t\treturn this.subscribe(type, f);\n\t};\n\n\tthis.once = function (type, f) {\n\t\treturn this.subscribeOnce(type, this, f);\n\t};\n\n\tthis.removeListener = function (type, f) {\n\t\tthis.unsubscribe(type, f);\n\t\treturn this;\n\t};\n\n\tthis.removeAllListeners = function (type) {\n\t\tif (this._subscribers) {\n\t\t\tfor (var k in this._subscribers) {\n\t\t\t\tif (type == null || type == k) {\n\t\t\t\t\tdelete this._subscribers[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t};\n\n\tthis.emit = function (type) {\n\t\tthis.publish.apply(this, arguments);\n\t\treturn this.listeners(type).length > 0;\n\t};\n\n\tthis._maxListeners = 10;\n\n\tthis.setMaxListeners = function (_maxListeners) {\n\t\tthis._maxListeners = _maxListeners;\n\t};\n\n\tthis.hasListeners = function (type) {\n\t\treturn this._subscribers && this._subscribers[type] && this._subscribers[type].length;\n\t};\n});\n\n","pre":true},"../../../browser/lib/runtimeBrowser/device/doc.js":{"path":"../../../browser/lib/runtimeBrowser/device/doc.js","friendlyPath":".doc","directory":"../../../browser/lib/runtimeBrowser/device/","filename":"doc.js","src":"jsio(\"import lib.PubSub\");\njsio(\"import lib.Enum as Enum\");\njsio(\"import std.js as JS\");\njsio(\"from util.browser import $\");\n\njsio(\"import device\");\njsio(\"import ..simulateDevice\");\n\nvar SCALING = Enum('FIXED', 'RESIZE', 'MANUAL');\nvar defaultScalingMode = device.isMobileBrowser || device.simulating ? SCALING.RESIZE : SCALING.FIXED;\n\n/**\n * @extends lib.PubSub\n */\nDocument=__class__;var Document=Document(function Document(){return this.init&&this.init.apply(this,arguments)},lib.PubSub, function() {\n\tthis.init = function() {\n\t\tif (!$) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tvar doc = GLOBAL.document,\n\t\t\tbody = doc && doc.body;\n\t\t\n\t\tthis._el = $({\n\t\t\tparent: body,\n\t\t\tstyle: {\n \t\t\t\tposition: 'absolute',\n\t\t\t\toverflow: 'hidden',\n\t\t\t\twidth: '100%',\n\t\t\t\theight: '100%'\n\t\t\t}\n\t\t});\n\t\t\n\t\tdevice.screen.subscribe('Resize', this, 'onResize');\n\t\t\n\t\tif (exports.postCreateHook) { exports.postCreateHook(this); }\n\t\tthis.setScalingMode(defaultScalingMode);\n\t}\n\t\n\tthis.unsubscribeResize = function () {\n\t\tdevice.screen.unsubscribe('Resize', this, 'onResize');\n\t}\n\t\n\tthis.setEngine = function (engine) {\n\t\tif (engine == this._engine) { return; }\n\t\t\n\t\tthis._engine = engine;\n\t\tthis._canvas = this._engine.getCanvas();\n\t\tthis.appendChild(this._canvas);\n\n\t\tif (this._canvas.getContext) {\n\t\t\tvar ctx = this._canvas.getContext(window.WebGLRenderingContext ? 'webgl' : '2d');\n\t\t\tif (ctx.setParentNode) {\n\t\t\t\tctx.setParentNode(this._el);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tthis.getElement = function () {\n\t\treturn this._el;\n\t};\n\t\n\tthis.setScalingMode = function(scalingMode, opts) {\n\t\tthis._scalingMode = scalingMode;\n\t\t\n\t\tvar el = this._el,\n\t\t\ts = el.style;\n\t\t\n\t\tswitch (scalingMode) {\n\t\t\tcase SCALING.FIXED:\n\t\t\t\topts = merge(opts, {\n\t\t\t\t\t\twidth: device.width,\n\t\t\t\t\t\theight: device.height\n\t\t\t\t\t});\n\t\t\t\ts.width = opts.width + 'px';\n\t\t\t\ts.height = opts.height + 'px';\n\t\t\t\tbreak;\n\t\t\tcase SCALING.RESIZE:\n\t\t\t\topts = merge(opts, {\n\t\t\t\t\t\tresizeCanvas: true\n\t\t\t\t\t});\n\t\t\t\t// fall through:\n\t\t\tcase SCALING.MANUAL:\n\t\t\t\ts.margin = '0px';\n\t\t\t\ts.width = '100%';\n\t\t\t\ts.height = '100%';\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\tthis._scalingOpts = opts;\n\t\tthis.onResize();\n\t\tsetTimeout(bind(this, 'onResize'), 1000);\n\t}\n\t\n\tthis.onResize = function() {\n\t\tvar el = this._el;\n\t\tvar s = this._el.style;\n\t\t\n\t\tel.className = device.screen.orientation;\n\t\tlogger.log('resize', device.width, device.height);\n\t\t\n\t\tvar width = device.width;\n\t\tvar height = device.height;\n\t\tvar mode = this._scalingMode;\n\t\tvar opts = this._scalingOpts;\n\t\t\n\t\tif (mode == SCALING.FIXED) {\n\t\t\twidth = opts.width;\n\t\t\theight = opts.height;\n\t\t}\n\t\t\n\t\t// enforce maxWidth/maxHeight\n\t\t// if maxWidth/maxHeight is met, switch a RESIZE scaling mode to FIXED (center the document on the screen)\n\t\tif (opts.maxWidth && width > opts.maxWidth) {\n\t\t\twidth = opts.maxWidth;\n\t\t\tif (mode == SCALING.RESIZE) { mode = SCALING.FIXED; }\n\t\t}\n\t\t\n\t\tif (opts.maxHeight && height > opts.maxHeight) {\n\t\t\theight = opts.maxHeight;\n\t\t\tif (mode == SCALING.RESIZE) { mode = SCALING.FIXED; }\n\t\t}\n\t\t\n\t\tswitch (mode) {\n\t\t\tcase SCALING.MANUAL:\n\t\t\t\tbreak; // do nothing\n\t\t\tcase SCALING.FIXED:\n\t\t\t\t// try to center the container\n\t\t\t\tel.style.top = Math.round(Math.max(0, (window.innerHeight - height) / 2)) + 'px';\n\t\t\t\tel.style.left = Math.round(Math.max(0, (window.innerWidth - width) / 2)) + 'px';\n\t\t\t\t\n\t\t\t\ts.width = width + 'px';\n\t\t\t\ts.height = height + 'px';\n\t\t\t\tbreak;\n\t\t\tcase SCALING.RESIZE:\n\t\t\t\t// if we have a canvas element, scale it\n\t\t\t\tif (opts.resizeCanvas && this._canvas\n\t\t\t\t\t\t&& (this._canvas.width != width || this._canvas.height != height)) {\n\t\t\t\t\tthis._canvas.width = width;\n\t\t\t\t\tthis._canvas.height = height;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ts.width = width + 'px';\n\t\t\t\ts.height = height + 'px';\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\t// make sure to force a render immediately (should we use needsRepaint instead?)\n\t\tthis._setDim(width, height);\n\t\tif (this._engine) { this._engine.render(); }\n\t}\n\t\n\tthis._setDim = function(width, height) {\n\t\tif (this.width != width || this.height != height) {\n\t\t\tthis.width = width;\n\t\t\tthis.height = height;\n\t\t\tthis.publish('Resize', width, height);\n\t\t}\n\t}\n\t\n\tthis.setColors = function(bgColor, engineColor) {\n\t\tif (this._el) {\n\t\t\tthis._el.style.background = engineColor;\n\t\t\tdocument.documentElement.style.background = document.body.style.background = bgColor;\n\t\t}\n\t}\n\t\n\tthis.appendChild = function(el) {\n\t\tthis._el.appendChild(el);\n\t}\n\t\n\tthis.getOffset = function() {\n\t\treturn {\n\t\t\tx: this._el.offsetLeft,\n\t\t\ty: this._el.offsetTop\n\t\t};\n\t}\n});\n\nexports = new Document();\nexports.SCALING = SCALING;\n\nexports.setDocStyle = function() {\n\tvar doc = GLOBAL.document,\n\t\tbody = doc && doc.body;\n\t\n\tif (body) {\n\t\tvar docStyle = {\n\t\t\theight: '100%',\n\t\t\tmargin: '0px',\n\t\t\tpadding: '0px'\n\t\t};\n\t\n\t\t$.style(document.documentElement, docStyle);\n\t\t$.style(document.body, docStyle);\n\t}\n}\n\nexports.defaultParent = null;\nexports.postCreateHook = null;\n","pre":true},"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/std/js.js":{"path":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/std/js.js","friendlyPath":"std.js","directory":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/std/","filename":"js.js","src":"var SLICE = Array.prototype.slice;\n\nexports.vargs = function(args, n) { return SLICE.call(args, n || 0); }\nexports.isArray = function(input) { return Object.prototype.toString.call(input) === '[object Array]'; }\n\nexports.shallowCopy = function(input) {\n\tif (exports.isArray(input)) {\n\t\treturn input.slice(0);\n\t} else {\n\t\tvar out = {};\n\t\tfor (var key in input) {\n\t\t\tif (input.hasOwnProperty(key)) {\n\t\t\t\tout[key] = input[key];\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn out;\n}\n\nexports.merge = function(base, extra) {\n\tbase = base || {};\n\t\n\tfor (var i = 1, len = arguments.length; i < len; ++i) {\n\t\tvar copyFrom = arguments[i];\n\t\tfor (var key in copyFrom) {\n\t\t\tif (copyFrom.hasOwnProperty(key) && !base.hasOwnProperty(key)) {\n\t\t\t\tbase[key] = copyFrom[key];\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn base;\n}\n\nexports.curry = function(method /*, VARGS*/) {\n\tvar args = SLICE.call(arguments, 1),\n\t\tf = typeof method == 'string'\n\t\t\t\t? function() { this[method].apply(ctx, args.concat(SLICE.call(arguments))); }\n\t\t\t\t: function() { method.apply(this, args.concat(SLICE.call(arguments))); }\n\tf.curried = true;\n\treturn f;\n}\n\nexports.unbind = function(method /*, VARGS*/) {\n\tvar args = SLICE.call(arguments, 1),\n\t\tf = typeof method == 'string'\n\t\t\t\t? function(ctx) { ctx[method].apply(ctx, args.concat(SLICE.call(arguments, 1))); }\n\t\t\t\t: function(ctx) { method.apply(ctx, args.concat(SLICE.call(arguments, 1))); }\n\tf.unbound = true;\n\treturn f;\n}\n\n","pre":true},"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/util/browser.js":{"path":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/util/browser.js","friendlyPath":"util.browser","directory":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/util/","filename":"browser.js","src":"if (jsio.__env.name == 'browser') {\n\tjsio('external .sizzle import Sizzle');\n\tjsio('import math.geom.Rect');\n\t\n\tfunction isWindow(el) {\n\t\treturn el && !$.isElement(el) && $.isElement(el.document);\n\t}\n\t\n\tvar singleId = /^#([\\w-]+)$/;\n\t\n\tvar $ = exports.$ = function(selector, win) {\n\t\tswitch(typeof selector) {\n\t\t\tcase 'object':\n\t\t\t\tif ($.isElement(selector)) {\n\t\t\t\t\treturn $.remove(selector);\n\t\t\t\t} else if ($.isElement(selector.document && selector.document.body)) {\n\t\t\t\t\treturn $.size(selector);\n\t\t\t\t}\n\t\t\t\treturn $.create(selector);\n\t\t\tcase 'string':\n\t\t\t\tif (singleId.test(selector)) { return $.id(selector.substring(1), win); }\n\t\t\t\treturn Sizzle.apply(GLOBAL, arguments);\n\t\t}\n\t}\n\t\n\tvar DOM2 = typeof HTMLElement === \"object\";\n\t$.isElement = DOM2\n\t\t? function(el) { return el && el instanceof HTMLElement; }\n\t\t: function(el) { return el && typeof el.nodeType == 'number' && typeof el.nodeName == 'string' };\n\t\n\t$.id = function(id, win) { return typeof id == 'string' ? (win || window).document.getElementById(id) : id; }\n\n\t$.apply = function(el, params) {\n\t\tif (params.attrs) {\n\t\t\tfor(attr in params.attrs) {\n\t\t\t\tel.setAttribute(attr, params.attrs[attr]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (params.id) { el.id = params.id; }\n\t\tif (params.style) { $.style(el, params.style); }\n\t\tif (params.src) { el.src = params.src; }\n\t\tif (params['class'] || params['className']) {\n\t\t\tel.className = params['class'] || params['className'];\n\t\t}\n\t\t\n\t\tvar parent = params.parent || params.parentNode;\n\t\tif (parent && params.first) {\n\t\t\t$.insertBefore(parent, el, parent.firstChild);\n\t\t} else if (params.before) {\n\t\t\t$.insertBefore(params.before.parentNode || parent, el, params.before);\n\t\t} else if (params.after) {\n\t\t\t$.insertAfter(params.after.parentNode || parent, el, params.after);\n\t\t} else if (parent) {\n\t\t\tparent.appendChild(el);\n\t\t}\n\t\t\n\t\tif ('html' in params) { el.innerHTML = params.html; }\n\t\tif ('text' in params) { $.setText(el, params.text); }\n\t\t\n\t\tif (params.children) {\n\t\t\tvar c = params.children;\n\t\t\tfor (var i = 0, n = c.length; i < n; ++i) {\n\t\t\t\tel.appendChild($.isElement(c[i]) ? c[i] : $(c[i]));\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn el;\n\t}\n\t\n\t$.insertBefore = function(parentNode, el, beforeNode) {\n\t\tif (!parentNode || !el) { return; }\n\t\tif (beforeNode && beforeNode.parentNode == parentNode) {\n\t\t\tparentNode.insertBefore(el, beforeNode);\n\t\t} else {\n\t\t\tparentNode.appendChild(el);\n\t\t}\n\t}\n\t\n\t$.insertAfter = function(parentNode, el, afterNode) {\n\t\tif (!parentNode || !el) { return; }\n\t\tif (!afterNode || afterNode.parentNode != parentNode) {\n\t\t\t$.insertBefore(parentNode, el, parentNode.firstChild);\n\t\t} else if (!afterNode.nextSibling) {\n\t\t\tparentNode.appendChild(el);\n\t\t} else {\n\t\t\tparentNode.insertBefore(el, afterNode.nextSibling);\n\t\t}\n\t}\n\n\t$.create = function(params) {\n\t\tvar doc = ((params && params.win) || window).document;\n\t\tif (!params || typeof params == 'string') {\n\t\t\treturn doc.createElement(params || 'div');\n\t\t};\n\n\t\treturn $.apply(params.el || doc.createElement(params.tag || params.tagName || 'div'), params);\n\t}\n\n\t$.show = function(el, how) { $.id(el).style.display = how || 'block'; }\n\t$.hide = function(el) { $.id(el).style.display = 'none'; }\n\n\t// accepts an array or a space-delimited string of classNames\n\t$.addClass = function(el, classNames) {\n\t\tif (!el) { return; }\n\t\tvar el = $.id(el);\n\t\tif (typeof classNames == \"string\") {\n\t\t\tclassNames = classNames.split(' ');\n\t\t}\n\t\n\t\tvar current = ' ' + el.className + ' ';\n\t\tfor (var i = 0, len = classNames.length; i < len; ++i) {\n\t\t\tvar c = classNames[i];\n\t\t\tif (current.indexOf(' ' + c + ' ') == -1) {\n\t\t\t\tcurrent += c + ' ';\n\t\t\t}\n\t\t}\n\t\t\n\t\tel.className = current.replace(/^\\s+|\\s+$/g, '');\n\t\treturn $;\n\t}\n\t\n\t$.getTag = function(from, tag) { return from.getElementsByTagName(tag); }\n\n\t$.removeClass = function(el, classNames) {\n\t\tif (!el) { return; }\n\t\tvar el = $.id(el);\n\t\tel.className = (' ' + el.className + ' ')\n\t\t\t.replace(' ', '  ')\n\t\t\t.replace(new RegExp('( ' + classNames.replace('\\s+', ' | ').replace('-','\\-') + ' )', 'g'), ' ')\n\t\t\t.replace(/\\s+/, ' ')\n\t\t\t.replace(/^\\s+|\\s+$/g, '');\n\t}\n\n\tfunction ieGetAlpha(el) {\n\t\ttry {\n\t\t\treturn el.filters.item(\"alpha\");\n\t\t} catch(e) {}\n\t\n\t\ttry {\n\t\t\treturn el.filters.item(\"progid:DXImageTransform.Microsoft.Alpha\");\n\t\t} catch(e) {}\n\t\n\t\treturn null;\n\t}\n\n\t$.style = function(el, style) {\n\t\tif(el instanceof Array) {\n\t\t\tfor(var i = 0, o; o = el[i]; ++i) { $.style(o, style); }\n\t\t\treturn;\n\t\t}\n\t\n\t\tel = $.id(el);\n\t\tvar s = el.style;\n\t\tfor(prop in style) {\n\t\t\tswitch(prop) {\n\t\t\t\tcase 'styleFloat':\n\t\t\t\tcase 'cssFloat':\n\t\t\t\tcase 'float':\n\t\t\t\t\ts.styleFloat = s.cssFloat = style[prop];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'opacity':\n\t\t\t\t\ts.opacity = style[prop];\n\t\t\t\t\tif(el.filters) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tvar alpha = ieGetAlpha();\n\t\t\t\t\t\t\tvar opacity = style[prop] == 1 ? 99.99 : style[prop] * 100;\n\t\t\t\t\t\t\tif(!alpha) {\n\t\t\t\t\t\t\t\t// TODO: this might destroy any existing filters?\n\t\t\t\t\t\t\t\ts.filter = \"alpha(opacity=\" + opacity + \")\";\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\talpha.Opacity = opacity;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch(e) {}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'borderRadius':\n\t\t\t\t\ts.borderRadius = s.MozBorderRadius = style[prop];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'boxSizing':\n\t\t\t\t\ts.MsBoxSizing = s.MozBoxSizing = s.WebkitBoxSizing = style[prop];\n\t\t\t\tdefault:\n\t\t\t\t\ts[prop] = style[prop];\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t};\n\n\t$.onEvent = function(el, name, f) {\n\t\tif (typeof f != 'function') {\n\t\t\tf = bind.apply(GLOBAL, Array.prototype.slice.call(arguments, 2));\n\t\t}\n\t\n\t\tvar handler = f;\n\t\n\t\tel = $.id(el);\n\t\tif(el.addEventListener) { \n\t\t\tel.addEventListener(name, handler, false);\n\t\t} else {\n\t\t\thandler = function(e) {\n\t\t\t\tvar evt = e || window.event;\n\t\t\t\t// TODO: normalize the event object\n\t\t\t\tf(evt);\n\t\t\t};\n\t\t\n\t\t\tel.attachEvent('on' + name, handler);\n\t\t}\n\t\n\t\treturn bind($, 'removeEvent', el, name, handler);\n\t};\n\n\t$.removeEvent = function(el, name, f) {\n\t\tel = $.id(el);\n\t\tif (el.addEventListener) {\n\t\t\tel.removeEventListener(name, f, false);\n\t\t} else {\n\t\t\tel.detachEvent('on' + name, f);\n\t\t}\n\t}\n\n\t$.stopEvent = function(e) {\n\t\tif (e) {\n\t\t\te.cancelBubble = true;\n\t\t\tif(e.stopPropagation) e.stopPropagation();\n\t\t\tif(e.preventDefault) e.preventDefault();\n\t\t}\n\t}\n\n\t$.setText = function(el, text) {\n\t\tel = $.id(el);\n\t\ttext = String(text);\n\t\tif ('textContent' in el) {\n\t\t\tel.textContent = text;\n\t\t} else if ('innerText' in el) {\n\t\t\tel.innerText = text.replace(/\\n/g, ' ');\n\t\t} else {\n\t\t\tel.innerHTML = '';\n\t\t\tel.appendChild(document.createTextNode(text));\n\t\t}\n\t}\n\n\t$.setValue = function(el, value) {\n\t\tel = $.id(el);\n\t\tif ('value' in el) {\n\t\t\tel.value = value;\n\t\t} else if ('value' in el.firstChild) {\n\t\t\tel.firstChild.value = value;\n\t\t}\n\t};\n\n\t$.remove = function(el) {\n\t\tel = $.id(el);\n\t\tif(el && el.parentNode) {\n\t\t\tel.parentNode.removeChild(el);\n\t\t}\n\t}\n\n\t$.cursorPos = function(ev, el) {\n\t\tvar offset = $.pos(el);\n\t\toffset.top = ev.clientY - offset.top + (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop);\n\t\toffset.left = ev.clientX - offset.left + (window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft);\n\t\treturn offset;\n\t}\n\n\t$.pos = function(el) {\n\t\tvar parent = el;\n\t\tvar offset = {top: 0, left: 0};\n\t\twhile(parent && parent != document.body) {\n\t\t\toffset.left += parent.offsetLeft;\n\t\t\toffset.top += parent.offsetTop;\n\t\t\twhile(parent.offsetParent != parent.parentNode) {\n\t\t\t\toffset.top -= parent.scrollTop; offset.left -= parent.scrollLeft;\n\t\t\t\tparent = parent.parentNode;\n\t\t\t}\n\t\t\tparent = parent.offsetParent;\n\t\t}\n\t\treturn offset;\n\t}\n\t\n\t$.size = function(el) {\n\t\tif ($.isElement(el)) {\n\t\t\treturn {width: el.offsetWidth, height: el.offsetHeight};\n\t\t} else if (el.document) {\n\t\t\tvar doc = el.document.documentElement || el.document.body;\n\t\t\treturn new math.geom.Rect(\n\t\t\t\tdoc.offsetTop,\n\t\t\t\tdoc.offsetLeft,\n\t\t\t\tel.innerWidth || (doc.clientWidth || doc.clientWidth),\n\t\t\t\tel.innerHeight || (doc.clientHeight || doc.clientHeight)\n\t\t\t);\n\t\t}\n\t}\n\t\n\t$.insertCSSFile = function(filename) {\n\t\tdocument.getElementsByTagName('head')[0].appendChild($({\n\t\t\ttag: 'link',\n\t\t\tattrs: {\n\t\t\t\trel: 'stylesheet',\n\t\t\t\ttype: 'text/css',\n\t\t\t\thref: filename\n\t\t\t}\n\t\t}));\n\t}\n}\n","pre":true},"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/util/sizzle.js":{"path":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/util/sizzle.js","friendlyPath":".sizzle","directory":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/util/","filename":"sizzle.js","src":"/*!\n * Sizzle CSS Selector Engine - v1.0\n *  Copyright 2009, The Dojo Foundation\n *  Released under the MIT, BSD, and GPL Licenses.\n *  More information: http://sizzlejs.com/\n */\n\nSizzle = (function(){\n\nvar chunker = /((?:\\((?:\\([^()]+\\)|[^()]+)+\\)|\\[(?:\\[[^[\\]]*\\]|['\"][^'\"]*['\"]|[^[\\]'\"]+)+\\]|\\\\.|[^ >+~,(\\[\\\\]+)+|[>+~])(\\s*,\\s*)?/g,\n\tdone = 0,\n\ttoString = Object.prototype.toString,\n\thasDuplicate = false;\n\nvar Sizzle = function(selector, context, results, seed) {\n\tresults = results || [];\n\tvar origContext = context = context || document;\n\n\tif ( context.nodeType !== 1 && context.nodeType !== 9 ) {\n\t\treturn [];\n\t}\n\t\n\tif ( !selector || typeof selector !== \"string\" ) {\n\t\treturn results;\n\t}\n\n\tvar parts = [], m, set, checkSet, check, mode, extra, prune = true, contextXML = isXML(context);\n\t\n\t// Reset the position of the chunker regexp (start from head)\n\tchunker.lastIndex = 0;\n\t\n\twhile ( (m = chunker.exec(selector)) !== null ) {\n\t\tparts.push( m[1] );\n\t\t\n\t\tif ( m[2] ) {\n\t\t\textra = RegExp.rightContext;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ( parts.length > 1 && origPOS.exec( selector ) ) {\n\t\tif ( parts.length === 2 && Expr.relative[ parts[0] ] ) {\n\t\t\tset = posProcess( parts[0] + parts[1], context );\n\t\t} else {\n\t\t\tset = Expr.relative[ parts[0] ] ?\n\t\t\t\t[ context ] :\n\t\t\t\tSizzle( parts.shift(), context );\n\n\t\t\twhile ( parts.length ) {\n\t\t\t\tselector = parts.shift();\n\n\t\t\t\tif ( Expr.relative[ selector ] )\n\t\t\t\t\tselector += parts.shift();\n\n\t\t\t\tset = posProcess( selector, set );\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Take a shortcut and set the context if the root selector is an ID\n\t\t// (but not if it'll be faster if the inner selector is an ID)\n\t\tif ( !seed && parts.length > 1 && context.nodeType === 9 && !contextXML &&\n\t\t\t\tExpr.match.ID.test(parts[0]) && !Expr.match.ID.test(parts[parts.length - 1]) ) {\n\t\t\tvar ret = Sizzle.find( parts.shift(), context, contextXML );\n\t\t\tcontext = ret.expr ? Sizzle.filter( ret.expr, ret.set )[0] : ret.set[0];\n\t\t}\n\n\t\tif ( context ) {\n\t\t\tvar ret = seed ?\n\t\t\t\t{ expr: parts.pop(), set: makeArray(seed) } :\n\t\t\t\tSizzle.find( parts.pop(), parts.length === 1 && (parts[0] === \"~\" || parts[0] === \"+\") && context.parentNode ? context.parentNode : context, contextXML );\n\t\t\tset = ret.expr ? Sizzle.filter( ret.expr, ret.set ) : ret.set;\n\n\t\t\tif ( parts.length > 0 ) {\n\t\t\t\tcheckSet = makeArray(set);\n\t\t\t} else {\n\t\t\t\tprune = false;\n\t\t\t}\n\n\t\t\twhile ( parts.length ) {\n\t\t\t\tvar cur = parts.pop(), pop = cur;\n\n\t\t\t\tif ( !Expr.relative[ cur ] ) {\n\t\t\t\t\tcur = \"\";\n\t\t\t\t} else {\n\t\t\t\t\tpop = parts.pop();\n\t\t\t\t}\n\n\t\t\t\tif ( pop == null ) {\n\t\t\t\t\tpop = context;\n\t\t\t\t}\n\n\t\t\t\tExpr.relative[ cur ]( checkSet, pop, contextXML );\n\t\t\t}\n\t\t} else {\n\t\t\tcheckSet = parts = [];\n\t\t}\n\t}\n\n\tif ( !checkSet ) {\n\t\tcheckSet = set;\n\t}\n\n\tif ( !checkSet ) {\n\t\tthrow \"Syntax error, unrecognized expression: \" + (cur || selector);\n\t}\n\n\tif ( toString.call(checkSet) === \"[object Array]\" ) {\n\t\tif ( !prune ) {\n\t\t\tresults.push.apply( results, checkSet );\n\t\t} else if ( context && context.nodeType === 1 ) {\n\t\t\tfor ( var i = 0; checkSet[i] != null; i++ ) {\n\t\t\t\tif ( checkSet[i] && (checkSet[i] === true || checkSet[i].nodeType === 1 && contains(context, checkSet[i])) ) {\n\t\t\t\t\tresults.push( set[i] );\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor ( var i = 0; checkSet[i] != null; i++ ) {\n\t\t\t\tif ( checkSet[i] && checkSet[i].nodeType === 1 ) {\n\t\t\t\t\tresults.push( set[i] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tmakeArray( checkSet, results );\n\t}\n\n\tif ( extra ) {\n\t\tSizzle( extra, origContext, results, seed );\n\t\tSizzle.uniqueSort( results );\n\t}\n\n\treturn results;\n};\n\nSizzle.uniqueSort = function(results){\n\tif ( sortOrder ) {\n\t\thasDuplicate = false;\n\t\tresults.sort(sortOrder);\n\n\t\tif ( hasDuplicate ) {\n\t\t\tfor ( var i = 1; i < results.length; i++ ) {\n\t\t\t\tif ( results[i] === results[i-1] ) {\n\t\t\t\t\tresults.splice(i--, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nSizzle.matches = function(expr, set){\n\treturn Sizzle(expr, null, null, set);\n};\n\nSizzle.find = function(expr, context, isXML){\n\tvar set, match;\n\n\tif ( !expr ) {\n\t\treturn [];\n\t}\n\n\tfor ( var i = 0, l = Expr.order.length; i < l; i++ ) {\n\t\tvar type = Expr.order[i], match;\n\t\t\n\t\tif ( (match = Expr.match[ type ].exec( expr )) ) {\n\t\t\tvar left = RegExp.leftContext;\n\n\t\t\tif ( left.substr( left.length - 1 ) !== \"\\\\\" ) {\n\t\t\t\tmatch[1] = (match[1] || \"\").replace(/\\\\/g, \"\");\n\t\t\t\tset = Expr.find[ type ]( match, context, isXML );\n\t\t\t\tif ( set != null ) {\n\t\t\t\t\texpr = expr.replace( Expr.match[ type ], \"\" );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( !set ) {\n\t\tset = context.getElementsByTagName(\"*\");\n\t}\n\n\treturn {set: set, expr: expr};\n};\n\nSizzle.filter = function(expr, set, inplace, not){\n\tvar old = expr, result = [], curLoop = set, match, anyFound,\n\t\tisXMLFilter = set && set[0] && isXML(set[0]);\n\n\twhile ( expr && set.length ) {\n\t\tfor ( var type in Expr.filter ) {\n\t\t\tif ( (match = Expr.match[ type ].exec( expr )) != null ) {\n\t\t\t\tvar filter = Expr.filter[ type ], found, item;\n\t\t\t\tanyFound = false;\n\n\t\t\t\tif ( curLoop == result ) {\n\t\t\t\t\tresult = [];\n\t\t\t\t}\n\n\t\t\t\tif ( Expr.preFilter[ type ] ) {\n\t\t\t\t\tmatch = Expr.preFilter[ type ]( match, curLoop, inplace, result, not, isXMLFilter );\n\n\t\t\t\t\tif ( !match ) {\n\t\t\t\t\t\tanyFound = found = true;\n\t\t\t\t\t} else if ( match === true ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( match ) {\n\t\t\t\t\tfor ( var i = 0; (item = curLoop[i]) != null; i++ ) {\n\t\t\t\t\t\tif ( item ) {\n\t\t\t\t\t\t\tfound = filter( item, match, i, curLoop );\n\t\t\t\t\t\t\tvar pass = not ^ !!found;\n\n\t\t\t\t\t\t\tif ( inplace && found != null ) {\n\t\t\t\t\t\t\t\tif ( pass ) {\n\t\t\t\t\t\t\t\t\tanyFound = true;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcurLoop[i] = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if ( pass ) {\n\t\t\t\t\t\t\t\tresult.push( item );\n\t\t\t\t\t\t\t\tanyFound = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( found !== undefined ) {\n\t\t\t\t\tif ( !inplace ) {\n\t\t\t\t\t\tcurLoop = result;\n\t\t\t\t\t}\n\n\t\t\t\t\texpr = expr.replace( Expr.match[ type ], \"\" );\n\n\t\t\t\t\tif ( !anyFound ) {\n\t\t\t\t\t\treturn [];\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Improper expression\n\t\tif ( expr == old ) {\n\t\t\tif ( anyFound == null ) {\n\t\t\t\tthrow \"Syntax error, unrecognized expression: \" + expr;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\told = expr;\n\t}\n\n\treturn curLoop;\n};\n\nvar Expr = Sizzle.selectors = {\n\torder: [ \"ID\", \"NAME\", \"TAG\" ],\n\tmatch: {\n\t\tID: /#((?:[\\w\\u00c0-\\uFFFF_-]|\\\\.)+)/,\n\t\tCLASS: /\\.((?:[\\w\\u00c0-\\uFFFF_-]|\\\\.)+)/,\n\t\tNAME: /\\[name=['\"]*((?:[\\w\\u00c0-\\uFFFF_-]|\\\\.)+)['\"]*\\]/,\n\t\tATTR: /\\[\\s*((?:[\\w\\u00c0-\\uFFFF_-]|\\\\.)+)\\s*(?:(\\S?=)\\s*(['\"]*)(.*?)\\3|)\\s*\\]/,\n\t\tTAG: /^((?:[\\w\\u00c0-\\uFFFF\\*_-]|\\\\.)+)/,\n\t\tCHILD: /:(only|nth|last|first)-child(?:\\((even|odd|[\\dn+-]*)\\))?/,\n\t\tPOS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\\((\\d*)\\))?(?=[^-]|$)/,\n\t\tPSEUDO: /:((?:[\\w\\u00c0-\\uFFFF_-]|\\\\.)+)(?:\\((['\"]*)((?:\\([^\\)]+\\)|[^\\2\\(\\)]*)+)\\2\\))?/\n\t},\n\tattrMap: {\n\t\t\"class\": \"className\",\n\t\t\"for\": \"htmlFor\"\n\t},\n\tattrHandle: {\n\t\thref: function(elem){\n\t\t\treturn elem.getAttribute(\"href\");\n\t\t}\n\t},\n\trelative: {\n\t\t\"+\": function(checkSet, part, isXML){\n\t\t\tvar isPartStr = typeof part === \"string\",\n\t\t\t\tisTag = isPartStr && !/\\W/.test(part),\n\t\t\t\tisPartStrNotTag = isPartStr && !isTag;\n\n\t\t\tif ( isTag && !isXML ) {\n\t\t\t\tpart = part.toUpperCase();\n\t\t\t}\n\n\t\t\tfor ( var i = 0, l = checkSet.length, elem; i < l; i++ ) {\n\t\t\t\tif ( (elem = checkSet[i]) ) {\n\t\t\t\t\twhile ( (elem = elem.previousSibling) && elem.nodeType !== 1 ) {}\n\n\t\t\t\t\tcheckSet[i] = isPartStrNotTag || elem && elem.nodeName === part ?\n\t\t\t\t\t\telem || false :\n\t\t\t\t\t\telem === part;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( isPartStrNotTag ) {\n\t\t\t\tSizzle.filter( part, checkSet, true );\n\t\t\t}\n\t\t},\n\t\t\">\": function(checkSet, part, isXML){\n\t\t\tvar isPartStr = typeof part === \"string\";\n\n\t\t\tif ( isPartStr && !/\\W/.test(part) ) {\n\t\t\t\tpart = isXML ? part : part.toUpperCase();\n\n\t\t\t\tfor ( var i = 0, l = checkSet.length; i < l; i++ ) {\n\t\t\t\t\tvar elem = checkSet[i];\n\t\t\t\t\tif ( elem ) {\n\t\t\t\t\t\tvar parent = elem.parentNode;\n\t\t\t\t\t\tcheckSet[i] = parent.nodeName === part ? parent : false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( var i = 0, l = checkSet.length; i < l; i++ ) {\n\t\t\t\t\tvar elem = checkSet[i];\n\t\t\t\t\tif ( elem ) {\n\t\t\t\t\t\tcheckSet[i] = isPartStr ?\n\t\t\t\t\t\t\telem.parentNode :\n\t\t\t\t\t\t\telem.parentNode === part;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( isPartStr ) {\n\t\t\t\t\tSizzle.filter( part, checkSet, true );\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"\": function(checkSet, part, isXML){\n\t\t\tvar doneName = done++, checkFn = dirCheck;\n\n\t\t\tif ( !/\\W/.test(part) ) {\n\t\t\t\tvar nodeCheck = part = isXML ? part : part.toUpperCase();\n\t\t\t\tcheckFn = dirNodeCheck;\n\t\t\t}\n\n\t\t\tcheckFn(\"parentNode\", part, doneName, checkSet, nodeCheck, isXML);\n\t\t},\n\t\t\"~\": function(checkSet, part, isXML){\n\t\t\tvar doneName = done++, checkFn = dirCheck;\n\n\t\t\tif ( typeof part === \"string\" && !/\\W/.test(part) ) {\n\t\t\t\tvar nodeCheck = part = isXML ? part : part.toUpperCase();\n\t\t\t\tcheckFn = dirNodeCheck;\n\t\t\t}\n\n\t\t\tcheckFn(\"previousSibling\", part, doneName, checkSet, nodeCheck, isXML);\n\t\t}\n\t},\n\tfind: {\n\t\tID: function(match, context, isXML){\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && !isXML ) {\n\t\t\t\tvar m = context.getElementById(match[1]);\n\t\t\t\treturn m ? [m] : [];\n\t\t\t}\n\t\t},\n\t\tNAME: function(match, context, isXML){\n\t\t\tif ( typeof context.getElementsByName !== \"undefined\" ) {\n\t\t\t\tvar ret = [], results = context.getElementsByName(match[1]);\n\n\t\t\t\tfor ( var i = 0, l = results.length; i < l; i++ ) {\n\t\t\t\t\tif ( results[i].getAttribute(\"name\") === match[1] ) {\n\t\t\t\t\t\tret.push( results[i] );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn ret.length === 0 ? null : ret;\n\t\t\t}\n\t\t},\n\t\tTAG: function(match, context){\n\t\t\treturn context.getElementsByTagName(match[1]);\n\t\t}\n\t},\n\tpreFilter: {\n\t\tCLASS: function(match, curLoop, inplace, result, not, isXML){\n\t\t\tmatch = \" \" + match[1].replace(/\\\\/g, \"\") + \" \";\n\n\t\t\tif ( isXML ) {\n\t\t\t\treturn match;\n\t\t\t}\n\n\t\t\tfor ( var i = 0, elem; (elem = curLoop[i]) != null; i++ ) {\n\t\t\t\tif ( elem ) {\n\t\t\t\t\tif ( not ^ (elem.className && (\" \" + elem.className + \" \").indexOf(match) >= 0) ) {\n\t\t\t\t\t\tif ( !inplace )\n\t\t\t\t\t\t\tresult.push( elem );\n\t\t\t\t\t} else if ( inplace ) {\n\t\t\t\t\t\tcurLoop[i] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn false;\n\t\t},\n\t\tID: function(match){\n\t\t\treturn match[1].replace(/\\\\/g, \"\");\n\t\t},\n\t\tTAG: function(match, curLoop){\n\t\t\tfor ( var i = 0; curLoop[i] === false; i++ ){}\n\t\t\treturn curLoop[i] && isXML(curLoop[i]) ? match[1] : match[1].toUpperCase();\n\t\t},\n\t\tCHILD: function(match){\n\t\t\tif ( match[1] == \"nth\" ) {\n\t\t\t\t// parse equations like 'even', 'odd', '5', '2n', '3n+2', '4n-1', '-n+6'\n\t\t\t\tvar test = /(-?)(\\d*)n((?:\\+|-)?\\d*)/.exec(\n\t\t\t\t\tmatch[2] == \"even\" && \"2n\" || match[2] == \"odd\" && \"2n+1\" ||\n\t\t\t\t\t!/\\D/.test( match[2] ) && \"0n+\" + match[2] || match[2]);\n\n\t\t\t\t// calculate the numbers (first)n+(last) including if they are negative\n\t\t\t\tmatch[2] = (test[1] + (test[2] || 1)) - 0;\n\t\t\t\tmatch[3] = test[3] - 0;\n\t\t\t}\n\n\t\t\t// TODO: Move to normal caching system\n\t\t\tmatch[0] = done++;\n\n\t\t\treturn match;\n\t\t},\n\t\tATTR: function(match, curLoop, inplace, result, not, isXML){\n\t\t\tvar name = match[1].replace(/\\\\/g, \"\");\n\t\t\t\n\t\t\tif ( !isXML && Expr.attrMap[name] ) {\n\t\t\t\tmatch[1] = Expr.attrMap[name];\n\t\t\t}\n\n\t\t\tif ( match[2] === \"~=\" ) {\n\t\t\t\tmatch[4] = \" \" + match[4] + \" \";\n\t\t\t}\n\n\t\t\treturn match;\n\t\t},\n\t\tPSEUDO: function(match, curLoop, inplace, result, not){\n\t\t\tif ( match[1] === \"not\" ) {\n\t\t\t\t// If we're dealing with a complex expression, or a simple one\n\t\t\t\tif ( chunker.exec(match[3]).length > 1 || /^\\w/.test(match[3]) ) {\n\t\t\t\t\tmatch[3] = Sizzle(match[3], null, null, curLoop);\n\t\t\t\t} else {\n\t\t\t\t\tvar ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not);\n\t\t\t\t\tif ( !inplace ) {\n\t\t\t\t\t\tresult.push.apply( result, ret );\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else if ( Expr.match.POS.test( match[0] ) || Expr.match.CHILD.test( match[0] ) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\treturn match;\n\t\t},\n\t\tPOS: function(match){\n\t\t\tmatch.unshift( true );\n\t\t\treturn match;\n\t\t}\n\t},\n\tfilters: {\n\t\tenabled: function(elem){\n\t\t\treturn elem.disabled === false && elem.type !== \"hidden\";\n\t\t},\n\t\tdisabled: function(elem){\n\t\t\treturn elem.disabled === true;\n\t\t},\n\t\tchecked: function(elem){\n\t\t\treturn elem.checked === true;\n\t\t},\n\t\tselected: function(elem){\n\t\t\t// Accessing this property makes selected-by-default\n\t\t\t// options in Safari work properly\n\t\t\telem.parentNode.selectedIndex;\n\t\t\treturn elem.selected === true;\n\t\t},\n\t\tparent: function(elem){\n\t\t\treturn !!elem.firstChild;\n\t\t},\n\t\tempty: function(elem){\n\t\t\treturn !elem.firstChild;\n\t\t},\n\t\thas: function(elem, i, match){\n\t\t\treturn !!Sizzle( match[3], elem ).length;\n\t\t},\n\t\theader: function(elem){\n\t\t\treturn /h\\d/i.test( elem.nodeName );\n\t\t},\n\t\ttext: function(elem){\n\t\t\treturn \"text\" === elem.type;\n\t\t},\n\t\tradio: function(elem){\n\t\t\treturn \"radio\" === elem.type;\n\t\t},\n\t\tcheckbox: function(elem){\n\t\t\treturn \"checkbox\" === elem.type;\n\t\t},\n\t\tfile: function(elem){\n\t\t\treturn \"file\" === elem.type;\n\t\t},\n\t\tpassword: function(elem){\n\t\t\treturn \"password\" === elem.type;\n\t\t},\n\t\tsubmit: function(elem){\n\t\t\treturn \"submit\" === elem.type;\n\t\t},\n\t\timage: function(elem){\n\t\t\treturn \"image\" === elem.type;\n\t\t},\n\t\treset: function(elem){\n\t\t\treturn \"reset\" === elem.type;\n\t\t},\n\t\tbutton: function(elem){\n\t\t\treturn \"button\" === elem.type || elem.nodeName.toUpperCase() === \"BUTTON\";\n\t\t},\n\t\tinput: function(elem){\n\t\t\treturn /input|select|textarea|button/i.test(elem.nodeName);\n\t\t}\n\t},\n\tsetFilters: {\n\t\tfirst: function(elem, i){\n\t\t\treturn i === 0;\n\t\t},\n\t\tlast: function(elem, i, match, array){\n\t\t\treturn i === array.length - 1;\n\t\t},\n\t\teven: function(elem, i){\n\t\t\treturn i % 2 === 0;\n\t\t},\n\t\todd: function(elem, i){\n\t\t\treturn i % 2 === 1;\n\t\t},\n\t\tlt: function(elem, i, match){\n\t\t\treturn i < match[3] - 0;\n\t\t},\n\t\tgt: function(elem, i, match){\n\t\t\treturn i > match[3] - 0;\n\t\t},\n\t\tnth: function(elem, i, match){\n\t\t\treturn match[3] - 0 == i;\n\t\t},\n\t\teq: function(elem, i, match){\n\t\t\treturn match[3] - 0 == i;\n\t\t}\n\t},\n\tfilter: {\n\t\tPSEUDO: function(elem, match, i, array){\n\t\t\tvar name = match[1], filter = Expr.filters[ name ];\n\n\t\t\tif ( filter ) {\n\t\t\t\treturn filter( elem, i, match, array );\n\t\t\t} else if ( name === \"contains\" ) {\n\t\t\t\treturn (elem.textContent || elem.innerText || \"\").indexOf(match[3]) >= 0;\n\t\t\t} else if ( name === \"not\" ) {\n\t\t\t\tvar not = match[3];\n\n\t\t\t\tfor ( var i = 0, l = not.length; i < l; i++ ) {\n\t\t\t\t\tif ( not[i] === elem ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t},\n\t\tCHILD: function(elem, match){\n\t\t\tvar type = match[1], node = elem;\n\t\t\tswitch (type) {\n\t\t\t\tcase 'only':\n\t\t\t\tcase 'first':\n\t\t\t\t\twhile ( (node = node.previousSibling) )  {\n\t\t\t\t\t\tif ( node.nodeType === 1 ) return false;\n\t\t\t\t\t}\n\t\t\t\t\tif ( type == 'first') return true;\n\t\t\t\t\tnode = elem;\n\t\t\t\tcase 'last':\n\t\t\t\t\twhile ( (node = node.nextSibling) )  {\n\t\t\t\t\t\tif ( node.nodeType === 1 ) return false;\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\tcase 'nth':\n\t\t\t\t\tvar first = match[2], last = match[3];\n\n\t\t\t\t\tif ( first == 1 && last == 0 ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tvar doneName = match[0],\n\t\t\t\t\t\tparent = elem.parentNode;\n\t\n\t\t\t\t\tif ( parent && (parent.sizcache !== doneName || !elem.nodeIndex) ) {\n\t\t\t\t\t\tvar count = 0;\n\t\t\t\t\t\tfor ( node = parent.firstChild; node; node = node.nextSibling ) {\n\t\t\t\t\t\t\tif ( node.nodeType === 1 ) {\n\t\t\t\t\t\t\t\tnode.nodeIndex = ++count;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} \n\t\t\t\t\t\tparent.sizcache = doneName;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tvar diff = elem.nodeIndex - last;\n\t\t\t\t\tif ( first == 0 ) {\n\t\t\t\t\t\treturn diff == 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn ( diff % first == 0 && diff / first >= 0 );\n\t\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tID: function(elem, match){\n\t\t\treturn elem.nodeType === 1 && elem.getAttribute(\"id\") === match;\n\t\t},\n\t\tTAG: function(elem, match){\n\t\t\treturn (match === \"*\" && elem.nodeType === 1) || elem.nodeName === match;\n\t\t},\n\t\tCLASS: function(elem, match){\n\t\t\treturn (\" \" + (elem.className || elem.getAttribute(\"class\")) + \" \")\n\t\t\t\t.indexOf( match ) > -1;\n\t\t},\n\t\tATTR: function(elem, match){\n\t\t\tvar name = match[1],\n\t\t\t\tresult = Expr.attrHandle[ name ] ?\n\t\t\t\t\tExpr.attrHandle[ name ]( elem ) :\n\t\t\t\t\telem[ name ] != null ?\n\t\t\t\t\t\telem[ name ] :\n\t\t\t\t\t\telem.getAttribute( name ),\n\t\t\t\tvalue = result + \"\",\n\t\t\t\ttype = match[2],\n\t\t\t\tcheck = match[4];\n\n\t\t\treturn result == null ?\n\t\t\t\ttype === \"!=\" :\n\t\t\t\ttype === \"=\" ?\n\t\t\t\tvalue === check :\n\t\t\t\ttype === \"*=\" ?\n\t\t\t\tvalue.indexOf(check) >= 0 :\n\t\t\t\ttype === \"~=\" ?\n\t\t\t\t(\" \" + value + \" \").indexOf(check) >= 0 :\n\t\t\t\t!check ?\n\t\t\t\tvalue && result !== false :\n\t\t\t\ttype === \"!=\" ?\n\t\t\t\tvalue != check :\n\t\t\t\ttype === \"^=\" ?\n\t\t\t\tvalue.indexOf(check) === 0 :\n\t\t\t\ttype === \"$=\" ?\n\t\t\t\tvalue.substr(value.length - check.length) === check :\n\t\t\t\ttype === \"|=\" ?\n\t\t\t\tvalue === check || value.substr(0, check.length + 1) === check + \"-\" :\n\t\t\t\tfalse;\n\t\t},\n\t\tPOS: function(elem, match, i, array){\n\t\t\tvar name = match[2], filter = Expr.setFilters[ name ];\n\n\t\t\tif ( filter ) {\n\t\t\t\treturn filter( elem, i, match, array );\n\t\t\t}\n\t\t}\n\t}\n};\n\nvar origPOS = Expr.match.POS;\n\nfor ( var type in Expr.match ) {\n\tExpr.match[ type ] = new RegExp( Expr.match[ type ].source + /(?![^\\[]*\\])(?![^\\(]*\\))/.source );\n}\n\nvar makeArray = function(array, results) {\n\tarray = Array.prototype.slice.call( array, 0 );\n\n\tif ( results ) {\n\t\tresults.push.apply( results, array );\n\t\treturn results;\n\t}\n\t\n\treturn array;\n};\n\n// Perform a simple check to determine if the browser is capable of\n// converting a NodeList to an array using builtin methods.\ntry {\n\tArray.prototype.slice.call( document.documentElement.childNodes, 0 );\n\n// Provide a fallback method if it does not work\n} catch(e){\n\tmakeArray = function(array, results) {\n\t\tvar ret = results || [];\n\n\t\tif ( toString.call(array) === \"[object Array]\" ) {\n\t\t\tArray.prototype.push.apply( ret, array );\n\t\t} else {\n\t\t\tif ( typeof array.length === \"number\" ) {\n\t\t\t\tfor ( var i = 0, l = array.length; i < l; i++ ) {\n\t\t\t\t\tret.push( array[i] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( var i = 0; array[i]; i++ ) {\n\t\t\t\t\tret.push( array[i] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t};\n}\n\nvar sortOrder;\n\nif ( document.documentElement.compareDocumentPosition ) {\n\tsortOrder = function( a, b ) {\n\t\tvar ret = a.compareDocumentPosition(b) & 4 ? -1 : a === b ? 0 : 1;\n\t\tif ( ret === 0 ) {\n\t\t\thasDuplicate = true;\n\t\t}\n\t\treturn ret;\n\t};\n} else if ( \"sourceIndex\" in document.documentElement ) {\n\tsortOrder = function( a, b ) {\n\t\tvar ret = a.sourceIndex - b.sourceIndex;\n\t\tif ( ret === 0 ) {\n\t\t\thasDuplicate = true;\n\t\t}\n\t\treturn ret;\n\t};\n} else if ( document.createRange ) {\n\tsortOrder = function( a, b ) {\n\t\tvar aRange = a.ownerDocument.createRange(), bRange = b.ownerDocument.createRange();\n\t\taRange.selectNode(a);\n\t\taRange.collapse(true);\n\t\tbRange.selectNode(b);\n\t\tbRange.collapse(true);\n\t\tvar ret = aRange.compareBoundaryPoints(Range.START_TO_END, bRange);\n\t\tif ( ret === 0 ) {\n\t\t\thasDuplicate = true;\n\t\t}\n\t\treturn ret;\n\t};\n}\n\n// Check to see if the browser returns elements by name when\n// querying by getElementById (and provide a workaround)\n(function(){\n\t// We're going to inject a fake input element with a specified name\n\tvar form = document.createElement(\"div\"),\n\t\tid = \"script\" + (new Date).getTime();\n\tform.innerHTML = \"<a name='\" + id + \"'/>\";\n\n\t// Inject it into the root element, check its status, and remove it quickly\n\tvar root = document.documentElement;\n\troot.insertBefore( form, root.firstChild );\n\n\t// The workaround has to do additional checks after a getElementById\n\t// Which slows things down for other browsers (hence the branching)\n\tif ( !!document.getElementById( id ) ) {\n\t\tExpr.find.ID = function(match, context, isXML){\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && !isXML ) {\n\t\t\t\tvar m = context.getElementById(match[1]);\n\t\t\t\treturn m ? m.id === match[1] || typeof m.getAttributeNode !== \"undefined\" && m.getAttributeNode(\"id\").nodeValue === match[1] ? [m] : undefined : [];\n\t\t\t}\n\t\t};\n\n\t\tExpr.filter.ID = function(elem, match){\n\t\t\tvar node = typeof elem.getAttributeNode !== \"undefined\" && elem.getAttributeNode(\"id\");\n\t\t\treturn elem.nodeType === 1 && node && node.nodeValue === match;\n\t\t};\n\t}\n\n\troot.removeChild( form );\n\troot = form = null; // release memory in IE\n})();\n\n(function(){\n\t// Check to see if the browser returns only elements\n\t// when doing getElementsByTagName(\"*\")\n\n\t// Create a fake element\n\tvar div = document.createElement(\"div\");\n\tdiv.appendChild( document.createComment(\"\") );\n\n\t// Make sure no comments are found\n\tif ( div.getElementsByTagName(\"*\").length > 0 ) {\n\t\tExpr.find.TAG = function(match, context){\n\t\t\tvar results = context.getElementsByTagName(match[1]);\n\n\t\t\t// Filter out possible comments\n\t\t\tif ( match[1] === \"*\" ) {\n\t\t\t\tvar tmp = [];\n\n\t\t\t\tfor ( var i = 0; results[i]; i++ ) {\n\t\t\t\t\tif ( results[i].nodeType === 1 ) {\n\t\t\t\t\t\ttmp.push( results[i] );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tresults = tmp;\n\t\t\t}\n\n\t\t\treturn results;\n\t\t};\n\t}\n\n\t// Check to see if an attribute returns normalized href attributes\n\tdiv.innerHTML = \"<a href='#'></a>\";\n\tif ( div.firstChild && typeof div.firstChild.getAttribute !== \"undefined\" &&\n\t\t\tdiv.firstChild.getAttribute(\"href\") !== \"#\" ) {\n\t\tExpr.attrHandle.href = function(elem){\n\t\t\treturn elem.getAttribute(\"href\", 2);\n\t\t};\n\t}\n\n\tdiv = null; // release memory in IE\n})();\n\nif ( document.querySelectorAll ) (function(){\n\tvar oldSizzle = Sizzle, div = document.createElement(\"div\");\n\tdiv.innerHTML = \"<p class='TEST'></p>\";\n\n\t// Safari can't handle uppercase or unicode characters when\n\t// in quirks mode.\n\tif ( div.querySelectorAll && div.querySelectorAll(\".TEST\").length === 0 ) {\n\t\treturn;\n\t}\n\t\n\tSizzle = function(query, context, extra, seed){\n\t\tcontext = context || document;\n\n\t\t// Only use querySelectorAll on non-XML documents\n\t\t// (ID selectors don't work in non-HTML documents)\n\t\tif ( !seed && context.nodeType === 9 && !isXML(context) ) {\n\t\t\ttry {\n\t\t\t\treturn makeArray( context.querySelectorAll(query), extra );\n\t\t\t} catch(e){}\n\t\t}\n\t\t\n\t\treturn oldSizzle(query, context, extra, seed);\n\t};\n\n\tfor ( var prop in oldSizzle ) {\n\t\tSizzle[ prop ] = oldSizzle[ prop ];\n\t}\n\n\tdiv = null; // release memory in IE\n})();\n\nif ( document.getElementsByClassName && document.documentElement.getElementsByClassName ) (function(){\n\tvar div = document.createElement(\"div\");\n\tdiv.innerHTML = \"<div class='test e'></div><div class='test'></div>\";\n\n\t// Opera can't find a second classname (in 9.6)\n\tif ( div.getElementsByClassName(\"e\").length === 0 )\n\t\treturn;\n\n\t// Safari caches class attributes, doesn't catch changes (in 3.2)\n\tdiv.lastChild.className = \"e\";\n\n\tif ( div.getElementsByClassName(\"e\").length === 1 )\n\t\treturn;\n\n\tExpr.order.splice(1, 0, \"CLASS\");\n\tExpr.find.CLASS = function(match, context, isXML) {\n\t\tif ( typeof context.getElementsByClassName !== \"undefined\" && !isXML ) {\n\t\t\treturn context.getElementsByClassName(match[1]);\n\t\t}\n\t};\n\n\tdiv = null; // release memory in IE\n})();\n\nfunction dirNodeCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {\n\tvar sibDir = dir == \"previousSibling\" && !isXML;\n\tfor ( var i = 0, l = checkSet.length; i < l; i++ ) {\n\t\tvar elem = checkSet[i];\n\t\tif ( elem ) {\n\t\t\tif ( sibDir && elem.nodeType === 1 ){\n\t\t\t\telem.sizcache = doneName;\n\t\t\t\telem.sizset = i;\n\t\t\t}\n\t\t\telem = elem[dir];\n\t\t\tvar match = false;\n\n\t\t\twhile ( elem ) {\n\t\t\t\tif ( elem.sizcache === doneName ) {\n\t\t\t\t\tmatch = checkSet[elem.sizset];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif ( elem.nodeType === 1 && !isXML ){\n\t\t\t\t\telem.sizcache = doneName;\n\t\t\t\t\telem.sizset = i;\n\t\t\t\t}\n\n\t\t\t\tif ( elem.nodeName === cur ) {\n\t\t\t\t\tmatch = elem;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\telem = elem[dir];\n\t\t\t}\n\n\t\t\tcheckSet[i] = match;\n\t\t}\n\t}\n}\n\nfunction dirCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {\n\tvar sibDir = dir == \"previousSibling\" && !isXML;\n\tfor ( var i = 0, l = checkSet.length; i < l; i++ ) {\n\t\tvar elem = checkSet[i];\n\t\tif ( elem ) {\n\t\t\tif ( sibDir && elem.nodeType === 1 ) {\n\t\t\t\telem.sizcache = doneName;\n\t\t\t\telem.sizset = i;\n\t\t\t}\n\t\t\telem = elem[dir];\n\t\t\tvar match = false;\n\n\t\t\twhile ( elem ) {\n\t\t\t\tif ( elem.sizcache === doneName ) {\n\t\t\t\t\tmatch = checkSet[elem.sizset];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\tif ( !isXML ) {\n\t\t\t\t\t\telem.sizcache = doneName;\n\t\t\t\t\t\telem.sizset = i;\n\t\t\t\t\t}\n\t\t\t\t\tif ( typeof cur !== \"string\" ) {\n\t\t\t\t\t\tif ( elem === cur ) {\n\t\t\t\t\t\t\tmatch = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( Sizzle.filter( cur, [elem] ).length > 0 ) {\n\t\t\t\t\t\tmatch = elem;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\telem = elem[dir];\n\t\t\t}\n\n\t\t\tcheckSet[i] = match;\n\t\t}\n\t}\n}\n\nvar contains = document.compareDocumentPosition ?  function(a, b){\n\treturn a.compareDocumentPosition(b) & 16;\n} : function(a, b){\n\treturn a !== b && (a.contains ? a.contains(b) : true);\n};\n\nvar isXML = function(elem){\n\treturn elem.nodeType === 9 && elem.documentElement.nodeName !== \"HTML\" ||\n\t\t!!elem.ownerDocument && elem.ownerDocument.documentElement.nodeName !== \"HTML\";\n};\n\nvar posProcess = function(selector, context){\n\tvar tmpSet = [], later = \"\", match,\n\t\troot = context.nodeType ? [context] : context;\n\n\t// Position selectors must be done after the filter\n\t// And so must :not(positional) so we move all PSEUDOs to the end\n\twhile ( (match = Expr.match.PSEUDO.exec( selector )) ) {\n\t\tlater += match[0];\n\t\tselector = selector.replace( Expr.match.PSEUDO, \"\" );\n\t}\n\n\tselector = Expr.relative[selector] ? selector + \"*\" : selector;\n\n\tfor ( var i = 0, l = root.length; i < l; i++ ) {\n\t\tSizzle( selector, root[i], tmpSet );\n\t}\n\n\treturn Sizzle.filter( later, tmpSet );\n};\n\nreturn Sizzle;\n\n})();\n","pre":true},"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/math/geom/Rect.js":{"path":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/math/geom/Rect.js","friendlyPath":"math.geom.Rect","directory":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/math/geom/","filename":"Rect.js","baseMod":"math","basePath":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio","src":"jsio(\"import lib.Enum\");\njsio(\"import .Point\");\njsio(\"import .Line\");\njsio(\"import .intersect\");\n\n/**\n * Model a rectangle.\n */\n\nvar Users_arnovandervegt_gameclosure_basil_sdk_jsio_math_geom_Rect=__class__;var Rect = exports=Users_arnovandervegt_gameclosure_basil_sdk_jsio_math_geom_Rect(function Users_arnovandervegt_gameclosure_basil_sdk_jsio_math_geom_Rect(){return this.init&&this.init.apply(this,arguments)},function() {\n\tthis.init = function(a, b, c, d) {\n\t\tswitch(arguments.length) {\n\t\t\tcase 0: // init\n\t\t\t\tthis.width = this.height = this.x = this.y = 0;\n\t\t\t\tbreak;\n\t\t\tcase 1: // copy\n\t\t\t\tthis.width = a.width;\n\t\t\t\tthis.height = a.height;\n\t\t\t\tthis.x = a.x;\n\t\t\t\tthis.y = a.y;\n\t\t\t\tbreak;\n\t\t\tcase 2: // (x, y), (width, height)\n\t\t\t\tthis.x = a.x;\n\t\t\t\tthis.y = a.y;\n\t\t\t\tthis.width = b.x;\n\t\t\t\tthis.height = b.y;\n\t\t\t\tbreak;\n\t\t\tcase 3: // (x, y), width, height\n\t\t\t\tthis.x = a.x;\n\t\t\t\tthis.y = a.y;\n\t\t\t\tthis.width = b;\n\t\t\t\tthis.height = c;\n\t\t\t\tbreak;\n\t\t\tcase 4: // x, y, width, height\n\t\t\t\tthis.x = a;\n\t\t\t\tthis.y = b;\n\t\t\t\tthis.width = c;\n\t\t\t\tthis.height = d;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * Normalize negative height and width dimensions by adjusting the position\n\t * of the rect.\n\t */\n\t\n\tthis.normalize = function() {\n\t\tif (this.width < 0) {\n\t\t\tthis.x -= this.width;\n\t\t\tthis.width = -this.width;\n\t\t}\n\t\t\n\t\tif (this.height < 0) {\n\t\t\tthis.y -= this.height;\n\t\t\tthis.height = -this.height;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Generate the intersection of a rectange with another rectangle.\n\t */\n\n\tthis.intersectRect = function (rect) {\n\t\tif (intersect.isRectAndRect(this, rect)) {\n\t\t\tvar x1 = this.x;\n\t\t\tvar y1 = this.y;\n\t\t\tvar x2 = this.x + this.width;\n\t\t\tvar y2 = this.y + this.height;\n\n\t\t\tthis.x = Math.max(x1, rect.x),\n\t\t\tthis.y = Math.max(y1, rect.y),\n\t\t\tthis.width = Math.min(x2, rect.x + rect.width) - this.x;\n\t\t\tthis.height = Math.min(y2, rect.y + rect.height) - this.y;\n\t\t} else {\n\t\t\tthis.width = 0;\n\t\t\tthis.height = 0;\n\t\t}\n\t}\n\t\n\t/**\n\t * Generate the union of a rectange with another rectangle.\n\t */\n\t\n\tthis.unionRect = function(rect) {\n\t\tthis.normalize();\n\t\tif (rect.normalize) { rect.normalize(); }\n\t\t\n\t\tvar x2 = this.x + this.width,\n\t\t\ty2 = this.y + this.height;\n\t\t\n\t\tvar rx2 = rect.x + rect.width,\n\t\t\try2 = rect.y + rect.height;\n\t\t\n\t\tthis.x = this.x < rect.x ? this.x : rect.x;\n\t\tthis.y = this.y < rect.y ? this.y : rect.y;\n\t\t\n\t\tthis.width = (x2 > rx2 ? x2 : rx2) - this.x;\n\t\tthis.height = (y2 > ry2 ? y2 : ry2) - this.y;\n\t};\n\n\t/**\n\t * Get a point for the given corner.\n\t */\n\t\n\tthis.getCorner = function(i) {\n\t\tswitch(i) {\n\t\t\tcase CORNERS.TOP_LEFT:\n\t\t\t\treturn new Point(this.x, this.y);\n\t\t\tcase CORNERS.TOP_RIGHT:\n\t\t\t\treturn new Point(this.x + this.width, this.y);\n\t\t\tcase CORNERS.BOTTOM_LEFT:\n\t\t\t\treturn new Point(this.x, this.y + this.height);\n\t\t\tcase CORNERS.BOTTOM_RIGHT:\n\t\t\t\treturn new Point(this.x + this.width, this.y + this.height);\n\t\t}\n\t}\n\t\n\t/**\n\t * Return a line corresponding to the given side.\n\t */\n\t\n\tthis.getSide = function(i) {\n\t\tswitch(i) {\n\t\t\tcase SIDES.TOP:\n\t\t\t\treturn new Line(this.getCorner(CORNERS.TOP_LEFT), this.getCorner(CORNERS.TOP_RIGHT));\n\t\t\tcase SIDES.RIGHT:\n\t\t\t\treturn new Line(this.getCorner(CORNERS.TOP_RIGHT), this.getCorner(CORNERS.BOTTOM_RIGHT));\n\t\t\tcase SIDES.BOTTOM:\n\t\t\t\treturn new Line(this.getCorner(CORNERS.BOTTOM_RIGHT), this.getCorner(CORNERS.BOTTOM_LEFT));\n\t\t\tcase SIDES.LEFT:\n\t\t\t\treturn new Line(this.getCorner(CORNERS.BOTTOM_LEFT), this.getCorner(CORNERS.TOP_LEFT));\n\t\t}\n\t}\n\n\t/**\n\t * Return the center point of a rectangle.\n\t */\n\t\n\tthis.getCenter = function() {\n\t\treturn new Point(this.x + this.width / 2, this.y + this.height / 2);\n\t}\n});\n\nvar SIDES = Rect.SIDES = lib.Enum('TOP', 'BOTTOM', 'LEFT', 'RIGHT');\nvar CORNERS = Rect.CORNERS = lib.Enum('TOP_LEFT', 'TOP_RIGHT', 'BOTTOM_RIGHT', 'BOTTOM_LEFT');\n","pre":true},"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/math/geom/Point.js":{"path":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/math/geom/Point.js","friendlyPath":".Point","directory":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/math/geom/","filename":"Point.js","src":"/**\n * @package math.geom.Point;\n * Models a Point in 2D space.\n */\n\nvar Users_arnovandervegt_gameclosure_basil_sdk_jsio_math_geom_Point=__class__;var Point = exports=Users_arnovandervegt_gameclosure_basil_sdk_jsio_math_geom_Point(function Users_arnovandervegt_gameclosure_basil_sdk_jsio_math_geom_Point(){return this.init&&this.init.apply(this,arguments)},function() {\n\tthis.init = function(a, b) {\n\t\tswitch(arguments.length) {\n\t\t\tcase 0:\n\t\t\t\tthis.x = 0;\n\t\t\t\tthis.y = 0;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tthis.x = a.x || 0;\n\t\t\t\tthis.y = a.y || 0;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tthis.x = a || 0;\n\t\t\t\tthis.y = b || 0;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * Rotates this point around the origin by a value in radians.\n\t */\n\t\n\tthis.rotate = function(r) {\n\t\tvar x = this.x,\n\t\t\ty = this.y,\n\t\t\tcosr = Math.cos(r),\n\t\t\tsinr = Math.sin(r);\n\t\t\n\t\tthis.x = x * cosr - y * sinr;\n\t\tthis.y = x * sinr + y * cosr;\n\t\t\n\t\treturn this;\n\t}\n\n\t/**\n\t * Translate this point by two scalars or by another point.\n\t */\n\t\n\tthis.translate = this.add = function(x, y) {\n\t\tif (typeof x == 'number') {\n\t\t\tthis.x += x;\n\t\t\tthis.y += y;\n\t\t} else {\n\t\t\tthis.x += x.x;\n\t\t\tthis.y += x.y;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Subtract this point by two scalars or by another point.\n\t */\n\t\n\tthis.subtract = function(x, y) {\n\t\tif (typeof x == 'number') {\n\t\t\tthis.x -= x;\n\t\t\tthis.y -= y;\n\t\t} else {\n\t\t\tthis.x -= x.x;\n\t\t\tthis.y -= x.y;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Scale this number.\n\t */\n\n\tthis.scale = function(sx, sy) {\n\t\t//if no scaleY specified\n\t\tif(sy === undefined) sy = sx;\n\n\t\tthis.x *= sx;\n\t\tthis.y *= sy;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the magnitude of this point at a constant angle.\n\t */\n\t\n\tthis.setMagnitude = function(m) {\n\t\tvar theta = this.getAngle();\n\t\tthis.x = m * Math.cos(theta);\n\t\tthis.y = m * Math.sin(theta);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Normalize this point to the unit circle.\n\t */\n\t\n\tthis.normalize = function() {\n\t\tvar m = this.getMagnitude();\n\t\tthis.x /= m;\n\t\tthis.y /= m;\n\t\treturn this;\n\t};\n\n\t/**\n\t * Add magnitude to this point.\n\t */\n\t\n\tthis.addMagnitude = function(m) {\n\t\treturn this.setMagnitude(this.getMagnitude() + m);\n\t};\n\n\tthis.getMagnitude = function() {\n\t\treturn Math.sqrt(this.x * this.x + this.y * this.y);\n\t};\n\n\tthis.getSquaredMagnitude = function() {\n\t\treturn this.x * this.x + this.y * this.y;\n\t};\n\n\tthis.getDirection = this.getAngle = function() {\n\t\treturn Math.atan2(this.y, this.x);\n\t};\n\t\n});\n\nPoint.getPolarR = function(x, y) { \n\tthrow \"notImplemented\";\n}\n\nPoint.getPolarTheta = function(x, y) { \n\tvar val = Math.atan2(y,x) + (Math.PI * 2); \n\treturn val > Math.PI * 2 ? val % (Math.PI * 2) : val;\n}\n\nPoint.add = Point.translate = function(a, b, c, d) {\n\tswitch(arguments.length) {\n\t\tcase 2: return new Point(a).add(b);\n\t\tcase 3: return new Point(a).add(b, c);\n\t\tcase 4: return new Point(a, b).add(c, d);\n\t}\n}\n\nPoint.subtract = function(a, b, c, d) {\n\tswitch(arguments.length) {\n\t\tcase 2: return new Point(a).subtract(b);\n\t\tcase 3: return new Point(a).subtract(b, c);\n\t\tcase 4: return new Point(a, b).subtract(c, d);\n\t}\n}\n\nPoint.scale = function(a, b, c) {\n\tswitch(arguments.length) {\n\t\tcase 2: return new Point(a).scale(b);\n\t\tcase 3: return new Point(a, b).scale(c);\n\t}\n}\n\nPoint.setMagnitude = function(a, b, c) {\n\tswitch(arguments.length) {\n\t\tcase 2: return new Point(a).setMagnitude(c);\n\t\tcase 3: return new Point(a, b).setMagnitude(c);\n\t}\n}\n\nPoint.addMagnitude = function(a, b, c) {\n\tswitch(arguments.length) {\n\t\tcase 2: pt = new Point(a); break;\n\t\tcase 3: pt = new Point(a, b); b = c; break;\n\t}\n\t\n\treturn pt.addMagnitude(b);\n}\n\nPoint.getMagnitude = function(a, b) { return new Point(a, b).getMagnitude(); }\n\nPoint.rotate = function(a, b, c) {\n\tswitch(arguments.length) {\n\t\tcase 2: return new Point(a).rotate(b);\n\t\tcase 3: return new Point(a, b).rotate(c);\n\t}\n}\n","pre":true},"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/math/geom/Line.js":{"path":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/math/geom/Line.js","friendlyPath":".Line","directory":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/math/geom/","filename":"Line.js","src":"jsio(\"import .Point\");\n\nvar Users_arnovandervegt_gameclosure_basil_sdk_jsio_math_geom_Line=__class__;exports=Users_arnovandervegt_gameclosure_basil_sdk_jsio_math_geom_Line(function Users_arnovandervegt_gameclosure_basil_sdk_jsio_math_geom_Line(){return this.init&&this.init.apply(this,arguments)},function() {\n\tthis.init = function(a, b, c, d) {\n\t\tswitch(arguments.length) {\n\t\t\tcase 0:\n\t\t\t\tthis.start = new Point();\n\t\t\t\tthis.end = new Point();\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tthis.start = new Point(a.start);\n\t\t\t\tthis.end = new Point(a.end);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tthis.start = new Point(a);\n\t\t\t\tthis.end = new Point(b);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tthis.start = new Point(a);\n\t\t\t\tthis.end = new Point(b, c);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\tdefault:\n\t\t\t\tthis.start = new Point(a, b);\n\t\t\t\tthis.end = new Point(c, d);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tthis.getMagnitude = \n\tthis.getLength = function() {\n\t\tvar dx = this.end.x - this.start.x,\n\t\t\tdy = this.end.y - this.start.y;\n\t\t\n\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t}\n});\n","pre":true},"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/math/geom/intersect.js":{"path":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/math/geom/intersect.js","friendlyPath":".intersect","directory":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/math/geom/","filename":"intersect.js","src":"jsio(\"import .Point\");\njsio(\"import .Line\");\njsio(\"import .Rect\");\n\n/**\n * @package math.geom.intersect\n */\nvar intersect = exports;\n\nintersect.pointAndRect = intersect.ptAndRect = function (pt, rect) {\n\tvar x = pt.x,\n\t\t\ty = pt.y;\n\treturn (x >= rect.x &&\n\t\t\t\t\tx <= rect.x + rect.width &&\n\t\t\t\t\ty >= rect.y &&\n\t\t\t\t\ty <= rect.y + rect.height);\n};\n\nintersect.rectAndPoint = intersect.rectAndPt = function (rect, pt) {\n\treturn intersect.pointAndRect(pt, rect);\n};\n\nintersect.pointAndCircle = intersect.ptAndCirc = function(pt, circle) {\n\tvar dx = pt.x - circle.x,\n\t\t\tdy = pt.y - circle.y;\n\treturn dx * dx + dy * dy < circle.radius * circle.radius;\n};\n\nintersect.circleAndPoint = intersect.circAndPt = function (circle, pt) {\n\treturn intersect.pointAndCircle(pt, circle);\n};\n\nintersect.isRectAndRect = function (rect1, rect2) {\n\treturn !((rect1.y + rect1.height < rect2.y) ||\n\t\t\t\t\t (rect2.y + rect2.height < rect1.y) ||\n\t\t\t\t\t (rect1.x + rect1.width < rect2.x) ||\n\t\t\t\t\t (rect2.x + rect2.width < rect1.x));\n};\n\nintersect.circleAndRect = function(circle, rect) {\n\tif (intersect.pointAndRect(circle, rect)) {\n\t\treturn true;\n\t}\n\treturn (intersect.lineAndCircle(rect.getSide(1), circle) ||\n\t\t\t\t\tintersect.lineAndCircle(rect.getSide(2), circle) ||\n\t\t\t\t\tintersect.lineAndCircle(rect.getSide(3), circle) ||\n\t\t\t\t\tintersect.lineAndCircle(rect.getSide(4), circle));\n};\n\nintersect.rectAndCircle = function(rect, circle) {\n\treturn intersect.circleAndRect(circle, rect);\n};\n\nintersect.lineAndCircle = function (line, circle) {\n\tvar vec = intersect.pointToLine(circle, line);\n\treturn vec.getMagnitude() < circle.radius;\n};\n\nintersect.circleAndLine = function (circle, line) {\n\treturn intersect.lineAndCircle(line, circle);\n};\n\n// returns line from pt to nearest pt on line\nintersect.pointToLine = intersect.ptToLine = function (pt, line) {\n\tvar dx = (line.end.x - line.start.x),\n\t\t\tdy = (line.end.y - line.start.y),\n\t\t\tu = ((pt.x - line.start.x) * dx\t// TODO can we abstract this from 2D to 2D/3D?\n\t\t\t\t\t + (pt.y - line.start.y) * dy) / (dx * dx + dy * dy);\n\n\tvar i;\n\tif (u < 0) {\n\t\ti = new Point(line.start);\n\t} else if (u > 1) {\n\t\ti = new Point(line.end);\n\t} else {\n\t\ti = new Point(line.start.x + u * dx, line.start.y + u * dy);\n\t}\n\treturn new Line(i, pt);\n};\n\n// returns rectangle of intersection\nintersect.rectAndRect = function (rect1, rect2) {\n\tjsio(\"import .Rect\");\n\treturn (intersect.rectAndRect = function(rect1, rect2) {\n\t\tif (rect1 === true) { return new Rect(rect2); }\n\t\tif (rect2 === true) { return new Rect(rect2); }\n\n\t\tif (intersect.isRectAndRect(rect1, rect2)) {\n\t\t\tvar x1 = Math.max(rect1.x, rect2.x),\n\t\t\t\t\ty1 = Math.max(rect1.y, rect2.y),\n\t\t\t\t\tx2 = Math.min(rect1.x + rect1.width, rect2.x + rect2.width),\n\t\t\t\t\ty2 = Math.min(rect1.y + rect1.height, rect2.y + rect2.height);\n\t\t\treturn new Rect(x1, y1, x2 - x1, y2 - y1);\n\t\t}\n\t\treturn null;\n\t})(rect1, rect2);\n}\n","pre":true},"../../../browser/lib/runtimeBrowser/device/Audio.js":{"path":"../../../browser/lib/runtimeBrowser/device/Audio.js","friendlyPath":".Audio","directory":"../../../browser/lib/runtimeBrowser/device/","filename":"Audio.js","src":"/**\n * @package timestep.env.browser.Audio;\n *\n * Audio implementation using the <audio> element for browsers.\n */\n\nexports = function (opts) {\n\tvar defaults = {\n\t\tautoplay: false,\n\t\tpreload: 'auto',\n\t\tvolume: 1.0,\n\t\tloop: 0,\n\t\tsrc: ''\n\t};\n\t\n\topts = merge(opts, defaults);\n\tvar el = document.createElement('Audio');\n\t\n\tel.autoplay = opts.autoplay;\n\tel.preload = opts.preload;\n\tel.volume = opts.volume;\n\tel.loop = opts.loop;\n\tel.src = opts.src;\n\t\n\treturn el;\n};","pre":true},"../../../browser/lib/runtimeBrowser/device/Canvas.js":{"path":"../../../browser/lib/runtimeBrowser/device/Canvas.js","friendlyPath":".Canvas","directory":"../../../browser/lib/runtimeBrowser/device/","filename":"Canvas.js","src":"\"use import\";\n\n/**\n * @package timestep.env.browser.Canvas;\n *\n * Canvas implementation for browsers. Wraps a Context2D.\n */\n\njsio(\"import .Context2D\");\n\nvar browser_lib_runtimeBrowser_device_Canvas=__class__;exports=browser_lib_runtimeBrowser_device_Canvas(function browser_lib_runtimeBrowser_device_Canvas(){return this.init&&this.init.apply(this,arguments)},function() {\n\tthis.init = function(opts) {\n\t\topts = merge(opts, {width: 300, height: 200});\n\t\tvar ctx = new Context2D(opts);\n\t\tvar el = this._el = ctx.getElement();\n\t\tel.getContext = function() { return ctx; }\n\t\tel.complete = true;\n\t\treturn el;\n\t}\n});\n","pre":true},"../../../browser/lib/runtimeBrowser/device/Context2D.js":{"path":"../../../browser/lib/runtimeBrowser/device/Context2D.js","friendlyPath":".Context2D","directory":"../../../browser/lib/runtimeBrowser/device/","filename":"Context2D.js","src":"/**\n * @package timestep.env.browser.Context2D;\n *\n * Generates a rendering context by creating our own Canvas element.\n */\n\njsio(\"import device\");\njsio(\"import .FontRenderer\");\n\nfunction setter(name) {\n\treturn (function(val) {\n\t\treturn (this[name] = val);\n\t});\n}\n\nfunction getter(name) {\n\treturn (function(val) {\n\t\treturn this[name];\n\t});\n}\n\nexports = function (opts) {\n\tvar parentNode = opts && opts.parent,\n\t\tel = opts && opts.el || document.createElement('canvas');\n\t\n\t//if (!parentNode) {\n\t//\tel.style.cssText = 'position: absolute; top: 0px; left: 0px; z-index: 1';\n\t//}\n\t\n\tel.width = opts.width;\n\tel.height = opts.height;\n\t\n\tvar ctx = el.getContext('2d');\n\tctx.font = '11px ' + device.defaultFontFamily;\n\tctx.getElement = function() { return el; }\n\t\n\tctx.reset = function() {}\n\t\n\tctx.clear = function() {\n\t\t//el.width = el.width;\n\t\tthis.clearRect(0, 0, el.width, el.height);\n\t};\n\t\n\tctx.clipRect = function(x, y, w, h) {\n\t\tctx.beginPath();\n\t\tctx.rect(x, y, w, h);\n\t\tctx.clip();\n\t}\n\t\n\tctx.swap = function() {};\n\tctx.execSwap = function() {};\n\t\n\tctx.circle = function(x, y, radius) {\n\t\tthis.beginPath();\n\t\tthis.arc(x, y, radius, 0, 2 * Math.PI, true);\n\t}\n\n\tvar _lastPointSprite = {\n\t\timg: null,\n\t\tcolor: null,\n\t\tcanvas: null\n\t};\n\n\tctx.drawPointSprites = function(x1, y1, x2, y2) {\n\t\tvar sprite = this.pointSprite;\n\t\tif (!sprite || !sprite.complete) { return; }\n\n\t\tvar width = sprite.width;\n\t\tvar height = sprite.height;\n\t\tvar canvas = _lastPointSprite.canvas || (_lastPointSprite.canvas = document.createElement('canvas'));\n\n\t\tif (sprite != _lastPointSprite.img || this.strokeStyle != _lastPointSprite.color) {\n\t\t\t_lastPointSprite.img = sprite;\n\t\t\t_lastPointSprite.color = this.strokeStyle;\n\t\t\tcanvas.width = width;\n\t\t\tcanvas.height = height;\n\t\t\tvar ctx = canvas.getContext('2d');\n\t\t\tctx.fillStyle = this.strokeStyle;\n\t\t\tctx.fillRect(0, 0, width, height);\n\t\t\tctx.globalCompositeOperation = 'destination-in';\n\t\t\tctx.drawImage(sprite, 0, 0);\n\t\t}\n\n\t\t// Add points to the buffer so there are drawing points every X pixels\n\t\tvar dx = x2 - x1;\n\t\tvar dy = y2 - y1;\n\t\tvar count = Math.ceil(Math.sqrt(dx * dx + dy * dy) / this.pointSpriteStep);\n\t\tif (count < 1) { count = 1; }\n\n\t\tvar d = this.lineWidth;\n\t\tfor (var i = 0; i < count; ++i) {\n\t\t\tvar x = x1 + dx * i / count;\n\t\t\tvar y = y1 + dy * i / count;\n\t\t\tthis.drawImage(canvas, 0, 0, width, height, x - d / 2, y - d / 2, d, d);\n\t\t}\n\t}\n\t\n\tctx.roundRect = function(x, y, width, height, radius) {\n\t\tthis.beginPath();\n\t\tthis.moveTo(x,y+radius);\n\t\tthis.lineTo(x,y+height-radius);\n\t\tthis.quadraticCurveTo(x,y+height,x+radius,y+height);\n\t\tthis.lineTo(x+width-radius,y+height);\n\t\tthis.quadraticCurveTo(x+width,y+height,x+width,y+height-radius);\n\t\tthis.lineTo(x+width,y+radius);\n\t\tthis.quadraticCurveTo(x+width,y,x+width-radius,y);\n\t\tthis.lineTo(x+radius,y);\n\t\tthis.quadraticCurveTo(x,y,x,y+radius);\n\t}\n\n\tctx.loadIdentity = function() {\n\t\tthis.setTransform(1, 0, 0, 1, 0, 0);\n\t}\n\t\n\tctx.measureText = FontRenderer.wrapMeasureText(ctx.measureText);\n\tctx.fillText = FontRenderer.wrapFillText(ctx.fillText);\n\tctx.strokeText = FontRenderer.wrapStrokeText(ctx.strokeText);\n\n\tctx.filters = {}\n\tctx.setFilters = function(filters) {\n\t\tfor (var name in filters) {\n\t\t\tthis.filters[name]  = filters[name];\n\t\t}\n\t}\n\n\tctx.clearFilters = function() {\n\t\tfor (var name in this.filters) {\n\t\t\tdelete this.filters[name];\n\t\t}\n\t}\n\t\n\treturn ctx;\n};\n","pre":true},"../../../browser/lib/runtimeBrowser/device/FontRenderer.js":{"path":"../../../browser/lib/runtimeBrowser/device/FontRenderer.js","friendlyPath":".FontRenderer","directory":"../../../browser/lib/runtimeBrowser/device/","filename":"FontRenderer.js","src":"/**\n * @package env.browser.FontRenderer;\n *\n * Render fonts or custom fonts on a Canvas context.\n */\n\njsio(\"import ui.resource.Font as Font\");\njsio(\"import ui.Engine as Engine\");\njsio(\"import .FontBuffer as FontBuffer\");\n\n\nvar _customFonts = {},\n\t_customFontInfo = {},\n\t_fontMap = {},\n\t_buffers = [],\n\t_fontBuffer = false;\n\nfunction loadCustomFontImage(customFont, index) {\n\tvar image = new Image();\n\n\timage.onload = function() {\n\t\timage.onload = null;\n\t\tcustomFont.imagesLoaded++;\n\t\tcustomFont.loaded = (customFont.imagesLoaded === customFont.imagesTotal);\n\t}\n\timage.src = 'resources/fonts/' + customFont.filename + index + '.png';\n\n\treturn image;\n}\n\nfunction findVerticalInfo(dimensions) {\n\t// A..Z, a..z, all\n\tvar ranges = [{start: 0x41, end: 0x5A}, {start: 0x61, end: 0x7A}, {start: 0x20, end: 0xFF}];\n\tvar range;\n\tvar dimension;\n\tvar found = false;\n\tvar baseline = 0;\n\tvar bottom = 0;\n\tvar i;\n\n\tfor (i = 0; i < ranges.length; i++) {\n\t\trange = ranges[i];\n\t\tfor (j = range.start; j <= range.end; j++) {\n\t\t\tdimension = dimensions[j];\n\t\t\tif (dimension) {\n\t\t\t\tbaseline = Math.max(baseline, dimension.h);\n\t\t\t\tbottom = Math.max(bottom, dimension.h);\n\t\t\t\tfound = true;\n\t\t\t}\n\t\t}\n\t\tif (found) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn {\n\t\tbaseline: baseline,\n\t\tbottom: bottom\n\t};\n}\n\nfunction findHorizontalInfo(dimensions) {\n\t// a..z, A..Z\n\tvar ranges = [{start: 0x61, end: 0x7A}, {start: 0x41, end: 0x5A}, {start: 0x20, end: 0xFF}];\n\tvar range;\n\tvar dimension;\n\tvar width = 0;\n\tvar count = 0;\n\tvar i, j;\n\n\tfor (i = 0; i < ranges.length; i++) {\n\t\trange = ranges[i];\n\t\tfor (j = range.start; j <= range.end; j++) {\n\t\t\tdimension = dimensions[j];\n\t\t\tif (dimension) {\n\t\t\t\twidth += dimension.w;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tif (count !== 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn {\n\t\twidth: width / count\n\t};\n}\n\nfunction loadingCustomFont (customFont) {\n\tif (customFont.imagesLoaded !== -1) {\n\t \treturn !customFont.loaded;\n\t}\n\n\tvar settings = customFont.settings,\n\t\tfilename = settings.filename,\n\t\timages,\n\t\timage,\n\t\tinfo,\n\t\ti, j;\n\n\tif (_customFontInfo[filename]) {\n\t\tinfo = _customFontInfo[filename];\n\t\tcustomFont.dimensions = info.dimensions;\n\t\tcustomFont.horizontal = info.horizontal;\n\t\tcustomFont.vertical = info.vertical;\n\t} else {\n\t\t// Load from legacy .js extension or newer .json extension.\n\t\tvar basename = 'resources/fonts/' + filename;\n\t\tvar json = CACHE[basename + '.json'];\n\t\tif (json == null) {\n\t\t\tjson = CACHE[basename + '.js'];\n\t\t\tif (json) {\n\t\t\t\tjson = json.replace(/^\\s*exports\\s*=\\s*|;\\s*$/g, '');\n\t\t\t} else {\n\t\t\t\tlogger.warn('Could not load font', customFont.name, 'from cached path', basename);\n\t\t\t}\n\t\t}\n\t\tcustomFont.dimensions = JSON.parse(json);\n\t\tcustomFont.horizontal = findHorizontalInfo(customFont.dimensions);\n\t\tcustomFont.vertical = findVerticalInfo(customFont.dimensions);\n\n\t\t_customFontInfo[filename] = {\n\t\t\tdimensions: customFont.dimensions,\n\t\t\thorizontal: customFont.horizontal,\n\t\t\tvertical: customFont.vertical\n\t\t};\n\t}\n\n\tcustomFont.images = [];\n\tcustomFont.imagesLoaded = 0;\n\n\timages = customFont.images;\n\n\tswitch (customFont.type) {\n\t\tcase 'color':\n\t\t\tfor (i = 0; i < settings.count; i++) {\n\t\t\t\timages[i] = [];\n\t\t\t\timages[i].push(loadCustomFontImage(customFont, '_0_' + i));\n\t\t\t\tcustomFont.imagesTotal++;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'composite':\n\t\t\tfor (i = 1; i < 3; i++) {\n\t\t\t\timages[i - 1] = [];\n\t\t\t\tfor (j = 0; j < settings.count; j++) {\n\t\t\t\t\timages[i - 1].push(loadCustomFontImage(customFont, '_' + i + '_' + j));\n\t\t\t\t\tcustomFont.imagesTotal++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n\n\treturn true;\n}\n\n(function() {\n\tvar manifest = window.CONFIG;\n\tif (manifest && manifest.fonts) {\n\t\tvar fonts = manifest.fonts,\n\t\t\tfont,\n\t\t\tcustomFont,\n\t\t\ti = fonts.length;\n\n\t\twhile (i) {\n\t\t\tfont = fonts[--i];\n\t\t\tcustomFont = {\n\t\t\t\tfilename: font.filename,\n\t\t\t\tsettings: font,\n\t\t\t\timagesLoaded: -1,\n\t\t\t\timagesTotal: 0,\n\t\t\t\tloaded: false,\n\t\t\t\ttype: 'color'\n\t\t\t};\n\t\t\t_customFonts[font.contextName + ' color'] = customFont;\n\t\t\tloadingCustomFont(customFont);\n\n\t\t\tcustomFont = {\n\t\t\t\t// The difference between color- and composite-filename is in the suffix!!!\n\t\t\t\tfilename: font.filename,\n\t\t\t\tsettings: font,\n\t\t\t\timagesLoaded: -1,\n\t\t\t\timagesTotal: 0,\n\t\t\t\tloaded: false,\n\t\t\t\ttype: 'composite'\n\t\t\t}\n\t\t\t_customFonts[font.contextName + ' composite'] = customFont;\n\t\t\tloadingCustomFont(customFont);\n\t\t}\n\t}\n})();\n\nfunction getCanvas() {\n\treturn document.createElement('canvas');\n}\n\nfunction getBuffers(srcBuffers, customFont, color, type) {\n\tvar key = customFont.filename + '_' + color + '_' + type,\n\t\tdstBuffers = [],\n\t\ti;\n\n\tif (!_buffers[key]) {\n\t\t_buffers[key] = {\n\t\t\tbuffers: dstBuffers\n\t\t}\n\t\tfor (i = 0; i < srcBuffers.length; i++) {\n\t\t\tvar canvas = getCanvas(),\n\t\t\t\tctx = canvas.getContext('2d'),\n\t\t\t\twidth = srcBuffers[i].width,\n\t\t\t\theight = srcBuffers[i].height;\n\n\t\t\tdstBuffers[i] = canvas;\n\n\t\t\tcanvas.width = width;\n\t\t\tcanvas.height = height;\n\n\t\t\tctx.save();\n\t\t\tctx.fillStyle = color;\n\t\t\tctx.fillRect(0, 0, width, height);\n\t\t\tctx.globalCompositeOperation = 'destination-in';\n\t\t\tctx.drawImage(srcBuffers[i], 0, 0);\n\t\t\tctx.restore();\n\t\t}\n\t}\n\n\t_buffers[key].lastUsed = +new Date();\n\treturn _buffers[key].buffers;\n}\n\nfunction measure(fontInfo, text) {\n\tvar customFont = fontInfo.customFont;\n\tvar dimensions = customFont.dimensions;\n\tvar scale = fontInfo.scale;\n\tvar outline = (customFont.settings.outline || 0) * scale;\n\tvar tracking = (customFont.settings.tracking || 0) * scale;\n\tvar width = 0;\n\tvar i, j;\n\n\tif (dimensions) {\n\t\tfor (i = 0, j = text.length; i < j; i++) {\n\t\t\tcharacter = text.charCodeAt(i);\n\t\t\tswitch (character) {\n\t\t\t\tcase 9: // tab...\n\t\t\t\t\twidth += customFont.horizontal.width * 4 * scale;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 32: // space...\n\t\t\t\t\twidth += customFont.horizontal.width * scale;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tif (dimensions[character]) {\n\t\t\t\t\t\tcharacter = dimensions[character];\n\t\t\t\t\t\twidth += (character.ow - 2) * scale;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\twidth += tracking - outline;\n\t\t}\n\t}\n\n\treturn {\n\t\twidth: width + 2 * scale\n\t};\n}\n\nfunction renderCustomFont(ctx, x, y, text, color, fontInfo, index) {\n\tvar customFont = fontInfo.customFont,\n\t\tsrcBuffers = customFont.images[index],\n\t\tdimensions = customFont.dimensions,\n\t\tscale = fontInfo.scale,\n\t\twidth = measure(fontInfo, text).width,\n\t\toutline = (customFont.settings.outline || 0) * scale,\n\t\ttracking = (customFont.settings.tracking || 0) * scale;\n\n\tswitch (ctx.textBaseline) {\n\t\tcase 'alphabetic':\n\t\t\ty -= customFont.vertical.baseline * scale;\n\t\t\tbreak;\n\t\tcase 'middle':\n\t\t\ty -= (customFont.vertical.bottom / 2) * scale;\n\t\t\tbreak;\n\t\tcase 'bottom':\n\t\t\ty -= customFont.vertical.bottom * scale;\n\t\t\tbreak;\n\t}\n\n\tswitch (ctx.textAlign) {\n\t\tcase 'center':\n\t\t\tx -= width / 2;\n\t\t\tbreak;\n\t\tcase 'right':\n\t\t\tx -= width;\n\t\t\tbreak;\n\t}\n\n\tvar buffer = false,\n\t\tbufferX = x,\n\t\tbufferY = y,\n\t\tcharacter,\n\t\ti, j;\n\n\tif (buffer) {\n\t\tx = buffer.x;\n\t\ty = buffer.y;\n\t\tctx = buffer.ctx;\n\t}\n\n\tif (customFont.type === 'composite') {\n\t\tsrcBuffers = getBuffers(srcBuffers, customFont, color, index);\n\t}\n\n\tif (!buffer || buffer.refresh) {\n\t\tfor (i = 0, j = text.length; i < j; i++) {\n\t\t\tcharacter = text.charCodeAt(i);\n\t\t\tswitch (character) {\n\t\t\t\tcase 9: // tab...\n\t\t\t\t\tx += customFont.horizontal.width * 4 * scale + tracking - outline;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 32: // space...\n\t\t\t\t\tx += customFont.horizontal.width * scale + tracking - outline;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tif (dimensions[character]) {\n\t\t\t\t\t\tcharacter = dimensions[character];\n\t\t\t\t\t\tctx.drawImage(\n\t\t\t\t\t\t\tsrcBuffers[character.i],\n\t\t\t\t\t\t\tcharacter.x,\n\t\t\t\t\t\t\tcharacter.y,\n\t\t\t\t\t\t\tcharacter.w,\n\t\t\t\t\t\t\tcharacter.h,\n\t\t\t\t\t\t\tx,\n\t\t\t\t\t\t\ty + (character.oh - 1) * scale,\n\t\t\t\t\t\t\t(character.w - 2) * scale,\n\t\t\t\t\t\t\t(character.h - 2) * scale\n\t\t\t\t\t\t);\n\t\t\t\t\t\tx += (character.ow - 2) * scale + tracking - outline;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (buffer) {\n\t\tthis.drawImage(\n\t\t\tbuffer.ctx.canvas,\n\t\t\tbuffer.x,\n\t\t\tbuffer.y,\n\t\t\tbuffer.width,\n\t\t\tbuffer.height,\n\t\t\tbufferX,\n\t\t\tbufferY,\n\t\t\tbuffer.width,\n\t\t\tbuffer.height\n\t\t);\n\t}\n};\n\n\n\nexports.findFontInfo = function(ctx) {\n\tvar font = Font.parse(ctx.font);\n\tvar name = font.getName();\n\tif (name && _customFonts[name]) {\n\t\tcustomFont = _customFonts[name];\n\t\tfont.customFont = customFont;\n\t\tfont.scale = font.getSize() / customFont.settings.size;\n\t\treturn font;\n\t}\n\n\treturn false;\n}\n\nexports.wrapMeasureText = function(origMeasureText) {\n\treturn function(text) {\n\t\tvar fontInfo = exports.findFontInfo(this);\n\n\t\tif (!fontInfo) {\n\t\t\treturn origMeasureText.apply(this, arguments);\n\t\t}\n\n\t\treturn measure(fontInfo, text);\n\t}\n};\n\nexports.wrapFillText = function(origFillText) {\n\treturn function(text, x, y) {\n\t\tvar fontInfo = exports.findFontInfo(this);\n\n\t\tif (!fontInfo) {\n\t\t\treturn origFillText.apply(this, arguments);\n\t\t}\n\t\tif (loadingCustomFont(fontInfo.customFont)) {\n\t\t\treturn;\n\t\t}\n\n\t\trenderCustomFont(this, x, y, text + '', this.fillStyle, fontInfo, 0);\n\t}\n};\n\nexports.wrapStrokeText = function(origStrokeText) {\n\treturn function(text, x, y) {\n\t\tvar fontInfo = exports.findFontInfo(this);\n\n\t\tif (!fontInfo) {\n\t\t\treturn origStrokeText.apply(this, arguments);\n\t\t}\n\t\tif (loadingCustomFont(fontInfo.customFont)) {\n\t\t\treturn;\n\t\t}\n\n\t\trenderCustomFont(this, x, y, text + '', this.strokeStyle, fontInfo, 1);\n\t}\n};\n\nexports.getFontBuffer = function() {\n\treturn _fontBuffer;\n};\n\n","pre":true},"../../../../sdk/timestep/ui/resource/Font.js":{"path":"../../../../sdk/timestep/ui/resource/Font.js","friendlyPath":"ui.resource.Font","directory":"../../../../sdk/timestep/ui/resource/","filename":"Font.js","src":"/**\n * @class ui.resource.Font;\n * Font string parser, a la CSS Font strings. Exports a Font object class.\n * This class is purely informational.\n *\n * @doc http://doc.gameclosure.com/api/ui-text.html#class-ui.resource.font\n * @docsrc https://github.com/gameclosure/doc/blob/master/api/ui/text.md\n */\n\njsio(\"import device\");\n\nvar _cache = {},\n\tweights = 'normal|bold|bolder|lighter|[1-9]00',\n\tstyles = 'normal|italic|oblique',\n\tunits = 'px|pt|pc|in|cm|mm|%',\n\tname = '([\\\\w\\\"\\'\\\\- ]+(?:,|$))+',\n\tfontParser = new RegExp(\n\t\t'^ *'\n\t\t\t+ '(?:(' + weights + ') *)?'\n\t\t\t+ '(?:(' + styles + ') *)?'\n\t\t\t+ '([\\\\d\\\\.]+)(' + units + ')'\n\t\t\t+ '('+ name + ')',\n\t\t\t'i'\n\t),\n\tsizeParser = new RegExp('([\\\\d\\\\.]+)(' + units + ')', 'i'),\n\tTO_PT = {\n\t\t'pt': 1,\n\t\t'px': 3 / 4,\n\t\t'in': 3 / 4 * 96,\n\t\t'mm': 3 / 4 * 96 / 25.4,\n\t\t'cm': 3 / 4 * 96 / 2.54\n\t},\n\tTO_PX = {\n\t\t'pt': 4 / 3,\n\t\t'px': 1,\n\t\t'in': 96,\n\t\t'mm': 96 / 25.4,\n\t\t'cm': 96 / 2.54\n\t};\n\nfunction parseSize(sizeStr, unit) {\n\tvar match = sizeStr.match(sizeParser);\n\tif (!match) { throw 'invalid font size'; }\n\treturn {\n\t\tvalue: parseFloat(match[1]),\n\t\tunit: match[2]\n\t};\n}\n\nfunction toPx(size) {\n\treturn {\n\t\tvalue: size.value * TO_PX[size.unit],\n\t\tunit: 'px'\n\t};\n}\n\nfunction toPt(size) {\n\treturn {\n\t\tvalue: size.value * TO_PT[size.unit],\n\t\tunit: 'pt'\n\t};\n}\n\nfunction parseFont(fontStr) {\n\tvar match = fontStr.match(fontParser);\n\tif (!match) { throw 'invalid font string'; }\n\t\n\tvar res = {};\n\tres.weight = match[1] || 'normal';\n\tres.style = match[2] || 'normal';\n\tres.size = {\n\t\tvalue: parseFloat(match[3]),\n\t\tunit: match[4]\n\t};\n\tres.names = match[5]\n\t\t.split(',')\n\t\t.map(function (str) {\n\t\t\treturn str.replace(/[\\-_]/g, ' ')\n\t\t\t\t.replace(/\\s+/g, ' ')\n\t\t\t\t.replace(/['\"]/g, '')\n\t\t\t\t.replace(/^\\s+|\\s+$/g, '')\n\t\t});\n\n\tres.name = res.names[0];\n\treturn res;\n};\n\nvar sdk_timestep_ui_resource_Font=__class__;var Font = exports=sdk_timestep_ui_resource_Font(function sdk_timestep_ui_resource_Font(){return this.init&&this.init.apply(this,arguments)},function(){\n\t\n\tvar defaults = {\n\t\tname: device.defaultFontFamily,\n\t\tsize: 20,\n\t\tunit: 'px',\n\t\tstyle: '',\n\t\tweight: ''\n\t};\n\n\tthis.init = function(opts) {\n\t\tif (typeof opts === 'string') {\n\t\t\t_cache[opts] = this;\n\t\t\tthis._string = opts;\n\t\t\topts = parseFont(opts);\n\t\t} else {\n\t\t\topts = merge(opts, defaults);\n\t\t}\n\t\t\n\t\tif (typeof opts.size == 'string') {\n\t\t\topts.size = parseSize(opts.size);\n\t\t}\n\t\t\n\t\tthis._name = opts.name;\n\t\tthis._style = opts.style;\n\t\tthis.size = opts.size;\n\t\tthis.sizePx = toPx(this.size).value;\n\t\tthis.sizePt = toPt(this.size).value;\n\t\tthis._weight = opts.weight;\n\n\t\tthis._isBold = /bold/i.test(this._weight);\n\t};\n\t\n\tthis.getSize = function() { return this.sizePx; }\n\n\tthis.getName = function () { return this._name; }\n\tthis.getWeight = function () { return this._weight; }\n});\n\nexports.parse = function(str) {\n\tif (str in _cache) {\n\t\treturn _cache[str];\n\t} else {\n\t\treturn new Font(str);\n\t}\n}\n","pre":true},"../../../../sdk/timestep/ui/Engine.js":{"path":"../../../../sdk/timestep/ui/Engine.js","friendlyPath":"ui.Engine","directory":"../../../../sdk/timestep/ui/","filename":"Engine.js","src":"/**\n * @class ui.Engine\n *\n * This is the game engine for timestep. It is built on a scene graph composed\n * of \"views\", and has canvas and DOM rendering backends.\n *\n * Responsibilities for the application engine includes initializing the canvas,\n * input and key listeners, game loop, animation tick, the view hierarchy and\n * rendering the scene graph.\n *\n * Not to be confused with GC.Application, the superclass exposed to games which\n * controls the game loop. A single ui.Engine is instantiated for\n * games which resides at GC.app.engine.\n *\n * @doc http://doc.gameclosure.com/api/appengine.html\n * @docsrc https://github.com/gameclosure/doc/blob/master/api/appengine.md\n */\n\njsio(\"import event.Emitter as Emitter\");\n\njsio(\"import event.input.dispatch as dispatch\");\n\njsio(\"import timer\");\njsio(\"import ui.backend.ReflowManager as ReflowManager\");\n\njsio(\"import device\");\n\nvar _timers = [];\ntimer.onTick = function (dt) {\n\tvar i = _timers.length;\n\twhile (i--) {\n\t\t_timers[i](dt);\n\t}\n}\n\nvar __instance = null;\n\n/**\n * @extends event.Emitter\n */\nvar sdk_timestep_ui_Engine=__class__;var Application = exports=sdk_timestep_ui_Engine(function sdk_timestep_ui_Engine(){return this.init&&this.init.apply(this,arguments)},Emitter, function(supr) {\n\tthis.init = function(opts) {\n\t\tif (!__instance) {\n\t\t\tjsio(\"import .StackView\");\n\n\t\t\t__instance = this;\n\t\t}\n\n\t\tvar canvas = opts && opts.canvas;\n\t\tif (typeof canvas == 'string' && GLOBAL.document && document.getElementById) {\n\t\t\tcanvas = document.getElementById(canvas);\n\t\t}\n\n\t\tthis._opts = opts = merge(opts, {\n\t\t\tkeyListenerEnabled: true,\n\t\t\twidth: canvas && canvas.width || device.width,\n\t\t\theight: canvas && canvas.height || device.height,\n\t\t\tview: null,\n\t\t\tdtFixed: 0,\n\t\t\tdtMinimum: 0,\n\t\t\tclearEachFrame: true,\n\t\t\talwaysRepaint: true,\n\t\t\trepaintOnEvent: true,\n\t\t\tmergeMoveEvents: false,\n\t\t\tcontinuousInputCheck: !device.isMobileBrowser && !device.isMobile,\n\t\t\tshowFPS: false\n\t\t});\n\n\t\t_timers.push(bind(this, this._tick));\n\n\t\tthis._doubleBuffered = true;\n\t\tthis._countdown = null;\n\n\t\tif (!device.useDOM) {\n\t\t\tvar Canvas = device.get('Canvas');\n\t\t\tthis._rootElement = new Canvas({\n\t\t\t\tel: canvas, // use an existing canvas if one was provided, but wrap the 2D context\n\t\t\t\twidth: opts.width,\n\t\t\t\theight: opts.height,\n\t\t\t\toffscreen: false\n\t\t\t});\n\n\t\t\tthis._ctx = this._rootElement.getContext('2d');\n\t\t\tthis._ctx.font = '11px ' + device.defaultFontFamily;\n\t\t}\n\n\t\tthis._view = opts.view || new StackView();\n\t\tthis._view.style.update({\n\t\t\twidth: opts.width,\n\t\t\theight: opts.height\n\t\t});\n\n\t\tif (device.useDOM) {\n\t\t\tthis._rootElement = this._view.getBacking().getElement();\n\t\t}\n\n\t\t// __root is a pointer to the Engine instance that a view\n\t\t// is currently attached to.  If __root is null, the view\n\t\t// is not currently in a view hierarchy.\n\t\tthis._view.__root = this;\n\t\t\n\t\tthis._events = [];\n\n\t\tif (dispatch.KeyListener) {\n\t\t\tthis._keyListener = new dispatch.KeyListener();\n\t\t}\n\n\t\tthis._inputListener = new dispatch.InputListener({\n\t\t\tel: this._rootElement,\n\t\t\tkeyListener: this._keyListener\n\t\t});\n\n\t\tthis._reflowMgr = ReflowManager.get();\n\n\t\tthis._tickBuffer = 0;\n\t\tthis._onTick = [];\n\n\t\t// configure auto-layout in the browser (expand\n\t\t// to fill the viewport)\n\t\tif (!canvas && device.name == 'browser') {\n\t\t\tvar doc = device.get('doc');\n\t\t\tif (doc) { doc.setEngine(this); }\n\t\t}\n\n\t\tthis.updateOpts(this._opts);\n\t};\n\n\tthis.updateOpts = function(opts) {\n\t\tthis._opts = merge(opts, this._opts);\n\t\tif (this._keyListener) {\n\t\t\tthis._keyListener.setEnabled(this._opts.keyListenerEnabled);\n\t\t}\n\n\t\tif (this._opts.showFPS) {\n\t\t\tif (!this._applicationFPS) {\n\t\t\t\tjsio(\"import ui.backend.debug.FPSView as FPSView\");\n\t\t\t\tthis._applicationFPS = new FPSView({application: this});\n\t\t\t}\n\t\t\t\n\t\t\tthis._renderFPS = bind(this._applicationFPS, this._applicationFPS.render);\n\t\t\tthis._tickFPS = bind(this._applicationFPS, this._applicationFPS.tick);\n\t\t} else {\n\t\t\tthis._renderFPS = function() {};\n\t\t\tthis._tickFPS = function() {};\n\t\t}\n\t};\n\n\tthis.supports = function(key) { return this._opts[key]; }\n\n\tthis.getInput = function() { return this._inputListener; }\n\tthis.getEvents = function() { return this._events; }\n\tthis.getKeyListener = function() { return this._keyListener; }\n\n\t// deprecating getCanvas...\n\tthis.getElement = \n\tthis.getCanvas = function() { return this._rootElement; }\n\t\n\tthis.getViewCtor = function() { return View; }\n\tthis.getView = function() { return this._view; }\n\tthis.setView = function(view) { this._view = view; return this; }\n\n\tthis.show = function() {\n\t\tthis._rootElement.style.display = 'block';\n\t\treturn this;\n\t};\n\n\tthis.hide = function() {\n\t\tthis._rootElement.style.display = 'none';\n\t\treturn this;\n\t};\n\t\n\tthis.pause = function() {\n\t\tthis.stopLoop();\n\t\tif (this._keyListener) {\n\t\t\tthis._keyListener.setEnabled(false);\n\t\t}\n\t};\n\n\tthis.resume = function() {\n\t\tthis.startLoop();\n\t\tif (this._keyListener) {\n\t\t\tthis._keyListener.setEnabled(true);\n\t\t}\n\t};\n\n\tthis.stepFrame = function(n) {\n\t\tthis.pause();\n\t\tn = n || 1;\n\t\tthis._countdown = n;\n\t\tthis.resume();\n\t};\n\n\tthis.startLoop = function(dtMin) {\n\t\tif (this._running) { return; }\n\t\tthis._running = true;\n\t\t\n\t\tthis.now = 0;\n\t\ttimer.start(dtMin || this._opts.dtMinimum);\n\t\treturn this;\n\t};\n\n\tthis.stopLoop = function() {\n\t\tif (!this._running) { return; }\n\t\tthis._running = false;\n\t\t\n\t\ttimer.stop();\n\t\treturn this;\n\t};\n\n\tthis.doOnTick = function(cb) {\n\t\tif (arguments.length > 1) { cb = bind.apply(this, arguments); }\n\t\tthis._onTick.push(cb);\n\t};\n\n\tthis._tick = function(dt) {\n\t\t//if the countdown is defined\n\t\tif (this._countdown !== null) {\n\t\t\tthis._countdown--;\n\n\t\t\t//if below zero, stop timer\n\t\t\tif (this._countdown === -1) {\n\t\t\t\tthis.pause();\n\t\t\t\tthis._countdown = null;\n\t\t\t}\n\t\t}\n\n\t\tthis._needsRepaint = false;\n\t\tif (this._ctx) {\n\t\t\tvar el = this._ctx.getElement();\n\t\t\tvar s = this._view.style;\n\t\t\tif (el && (s.width != el.width / s.scale || s.height != el.height / s.scale)) {\n\t\t\t\ts.width = el.width / s.scale;\n\t\t\t\ts.height = el.height / s.scale;\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = 0, cb; cb = this._onTick[i]; ++i) { cb(dt); }\n\n\t\tvar events = this._inputListener.getEvents();\n\t\tvar n = events.length;\n\n\t\tthis._events = events;\n\t\tif (this._opts._mergeMoveEvents) {\n\t\t\tvar hasMove = false;\n\t\t\tfor (var i = n - 1; i >= 0; --i) {\n\t\t\t\tif (events[i].type == dispatch.eventTypes.MOVE) {\n\t\t\t\t\tif (!hasMove) { \n\t\t\t\t\t\thasMove = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tevents.splice(i, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = 0, evt; evt = events[i]; ++i) {\n\t\t\tevt.srcApp = this;\n\t\t\tdispatch.dispatchEvent(this._view, evt);\n\t\t}\n\n\t\tif (!device.useDOM) {\n\t\t\tif (i > 0) {\n\t\t\t\tif (this._opts.repaintOnEvent) { this.needsRepaint(); }\n\t\t\t} else if (this._opts.continuousInputCheck) {\n\t\t\t\tvar prevMove = dispatch._evtHistory['input:move'];\n\t\t\t\tif (prevMove) {\n\t\t\t\t\tdispatch.dispatchEvent(this._view, new dispatch.InputEvent(prevMove.id, prevMove.type, prevMove.srcPt));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (this._opts.dtFixed) {\n\t\t\tthis._tickBuffer += dt;\n\t\t\twhile (this._tickBuffer >= this._opts.dtFixed) {\n\t\t\t\tthis._tickBuffer -= this._opts.dtFixed;\n\t\t\t\tthis.now += this._opts.dtFixed;\n\t\t\t\tthis.__tick(this._opts.dtFixed);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.__tick(dt);\n\t\t}\n\n\t\tthis._reflowMgr.startReflow(this._ctx);\n\t\tthis._reflowMgr.setInRender(true);\n\n\t\tvar doRepaint = this._opts.alwaysRepaint || this._needsRepaint;\n\t\tif (!doRepaint && this._doubleBuffered && this._doubleBufferedState > 0) {\n\t\t\t// even if we don't repaint, we need to paint at least 1 more time\n\t\t\t// for devices that use multiple buffers (like the ios, I think...)\n\t\t\t--this._doubleBufferedState;\n\t\t\tthis.render(dt);\n\t\t} else if (doRepaint) {\n\t\t\tthis._doubleBufferedState = 3;\n\t\t\tthis.render(dt);\n\t\t}\n\n\t\tthis._reflowMgr.setInRender(false);\n\t};\n\n\tthis.render = function(dt) {\n\t\tif (this._opts.clearEachFrame) {\n\t\t\tthis._ctx && this._ctx.clear();\n\t\t}\n\n\t\tthis._view.__view.wrapRender(this._ctx, {});\n\t\tthis.publish('Render', this._ctx);\n\n\t\tif (this._ctx) {\n\t\t\tif (DEBUG) {\n\t\t\t\tthis._renderFPS(this._ctx, dt);\n\t\t\t}\n\n\t\t\tthis._ctx.swap();\n\t\t}\n\t};\n\n\tthis.needsRepaint = function() {\n\t\tthis._needsRepaint = true;\n\t\treturn this;\n\t};\n\n\tthis.__tick = function(dt) {\n\t\tthis._tickFPS(dt);\n\t\tthis.publish('Tick', dt);\n\t\tthis._view.__view.wrapTick(dt, this);\n\t};\n\n\tvar log_counter = 0;\n\n});\n\nexports.get = function() { return __instance; };\n","pre":true},"../../../../sdk/timestep/event/input/dispatch.js":{"path":"../../../../sdk/timestep/event/input/dispatch.js","friendlyPath":"event.input.dispatch","directory":"../../../../sdk/timestep/event/input/","filename":"dispatch.js","src":"/**\n * @module event.input.dispatch;\n * This namespace includes functions to dispatch touch events starting from the\n * root application view, which are traced through the hierarchy to each view's\n * individual InputHandler proxy. Additionally, this namespace includes those\n * functions actually in timestep.input, like InputListener and KeyListener classes.\n */\n\njsio(\"import math.geom.Point as Point\");\njsio(\"import device\");\njsio(\"import lib.Enum\");\n\nexports.eventTypes = new lib.Enum('START', 'MOVE', 'SELECT', 'SCROLL', 'CLEAR');\nexports.VERTICAL_AXIS = 2;\nexports.HORIZONTAL_AXIS = 1;\n\n/**\n * capture/bubble event, starting from root Application view\n *  - publish <inputTypeCapture> on the way down (e.g. onInputStartCapture)\n *  - call callbacks (e.g. onInputStart) and publish <inputType> (e.g. onInputstart)\n *    on the way up, checking evt.cancelled to see if someone has cancelled the event\n */\nexports.dispatchEvent = function(root, evt) {\n\t// if (evt.type == input.eventTypes.MOVE) { var now = +new Date(); }\n\t// store the root in case an event listener wants the top-most view?\n\tevt.root = root;\n\t\n\t// SHOULD_HANDLE = LOCALIZE = 0;\n\n\t// grab the bottom-most view whose bounding box contains the evt.srcPt\n\t// also updates the evt object with a trace of localized points and views\n\texports.traceEvt(root, evt, evt.srcPt);\n\n\t// if (now) { logger.log('TRACED A', LOCALIZE, SHOULD_HANDLE) }\n\t\n\t// once we've traced the event, we know how deep it goes\n\tvar depth = evt.depth;\n\t\n\texports._evtHistory[evt.type] = evt;\n\t\n\tvar signal = exports._evtCb[evt.type] || exports.getEvtCbName(evt.type);\n\t\n\tfor (var i = depth - 1; i >= 0; --i) {\n\t\tvar view = evt.trace[i],\n\t\t\tpt = evt.pt[view.uid];\n\t\tview.publish(signal + 'Capture', evt, pt, i == 0);\n\t\tif (evt.cancelled) { return; }\n\t}\n\t\n\tvar cbName = 'on' + signal;\n\tfor (var i = 0; i < depth; ++i) {\n\t\tvar view = evt.trace[i];\n\t\tif (view.__input.canHandleEvents) {\n\t\t\tvar pt = evt.pt[view.uid];\n\t\t\tif (view[cbName]) { view[cbName](evt, pt, i == 0); }\n\t\t\tview.publish(signal, evt, pt, i == 0);\n\t\t\tview._onEventPropagate(evt, pt, i == 0);\n\t\t\tif (evt.cancelled) { break; }\n\t\t}\n\t}\n}\n\n/**\n * Trace an event recursively down to the view on which the event is triggered.\n */\nexports.traceEvt = function(view, evt, pt) {\n\t// var now = +new Date();\n\tvar localPt = view.style.localizePoint(new Point(pt));\n\tvar inputHandler = view.getInput();\n\tif (!inputHandler.containsEvent(evt, localPt)) { return false; }\n\n\tvar canHandleEvents = view.getInput().canHandleEvents;\n\tif (canHandleEvents) {\n\t\tevt.depth++;\n\t\tevt.trace.unshift(view);\n\t\tevt.pt[view.uid] = localPt;\n\t}\n\t\n\tvar subviews = view.getSubviews();\n\tfor (var i = subviews.length - 1; i >= 0; --i) {\n\t\tif (subviews[i].style.visible && exports.traceEvt(subviews[i], evt, localPt)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tif (canHandleEvents) {\n\t\tevt.target = view;\n\t\treturn true;\n\t}\n}\n\nexports._evtHistory = {};\nexports._activeInputOver = {};\n\nexports.clearOverState = function (id) {\n\tif (id) {\n\t\tvar evt = exports._activeInputOver[id];\n\t\tif (evt) {\n\t\t\tdelete exports._activeInputOver[id];\n\t\t\tvar trace = evt.trace;\n\t\t\tfor (var i = 0, view; view = trace[i]; ++i) {\n\t\t\t\tview.__input.onLeave(id);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (var id in exports._activeInputOver) {\n\t\t\texports.clearOverState(id);\n\t\t}\n\t}\n}\n\nexports._isDragging = false;\nexports.isDragging = function() { return exports._isDragging; }\n\nexports._evtCb = {};\nexports.getEvtCbName = function(evtType) {\n\tvar name = exports.eventTypes[evtType];\n\treturn (exports._evtCb[evtType] = 'Input' + name.charAt(0) + name.substring(1).toLowerCase());\n}\n\n/**\n * Aliases for children of the timestep.input \"package\".\n */\n\nexports.InputListener = device.get('Input');\nexports.KeyListener = device.get('KeyListener');\n\njsio(\"import .InputEvent as exports.InputEvent\");\n","pre":true},"../../../../sdk/timestep/event/input/InputEvent.js":{"path":"../../../../sdk/timestep/event/input/InputEvent.js","friendlyPath":".InputEvent","directory":"../../../../sdk/timestep/event/input/","filename":"InputEvent.js","src":"/**\n * @class event.input.InputEvent;\n * This class represents an input event.\n * \n * It assumes a tree structure of View objects.  The top (root) of the\n * tree is typically the main Application view.  \n * \n * Events are assigned a root and a target.  View::dispatchEvent\n * computes the root and target from the event location (x, y).\n *\n * Propogation has two phases: capturing and bubbling.  Users \n * can mostly ignore capturing as the primary hooks are in the \n * bubbling.  Bubbling is defined as calling event handlers on\n * each view starting with 'target' and then continuing up \n * superview pointers until reaching 'root'.  Views can listen\n * to the event bubbling by adding methods such as:\n * \"input:start\" -> \"function onInputStart(evt)\"\n * \"input:drag\" -> \"function onDrag(dragEvt, moveEvt, delta)\"\n *\n * Other code can hook into a view's events by calling:\n *   myView.subscribe('input:start', function() { alert('Mouse Down'); });\n *   myView.subscribe('input:end', this, 'onChildViewClick');\n *\n * Propogation of events can be cancelled by calling evt.cancel().\n *\n * Note that onDrag is a special event that receives not only\n * a move event from an 'input:move' event, but also a custom\n * dragEvt object that contains extra data such as the start\n * position of the drag.\n *\n * @doc http://doc.gameclosure.com/api/event.html#class-event.input.inputevent\n * @docsrc https://github.com/gameclosure/doc/blob/master/api/event.md\n */\n\njsio(\"import math.geom.Point as Point\");\njsio(\"import timer\");\n\nvar sdk_timestep_event_input_InputEvent=__class__;var InputEvent = exports=sdk_timestep_event_input_InputEvent(function sdk_timestep_event_input_InputEvent(){return this.init&&this.init.apply(this,arguments)},function() {\n\tthis.cancelled = false; // If true, this event will not propogate\n\tthis.depth = 0; // Number of levels of the tree from root to target (inclusive)\n\t\n\t// Note that under normal usage:\n\t//   this.depth == this.trace.length\n\t//   this.root = this.trace[this.trace.length - 1]\n\t//   this.target = this.trace[0]\n\t\n\tthis.init = function(id, evtType, x, y, root, target) {\n\t\t// unique ID for a particular input - the ID should be constant for a given input\n\t\t// for example, the mouse should always have the same ID.  Each finger (touch)\n\t\t// should have the same ID throughout the touch start/move/end process\n\t\tthis.id = id; \n\t\t\n\t\t// string evtType, e.g. 'input:start'\n\t\tthis.type = evtType;\n\t\t\n\t\t// localized point coordinates, indexed by a view's uid (View::uid)\n\t\tthis.point = this.pt = {};\n\t\t\n\t\t// raw (x, y) coordinates\n\t\tthis.srcPoint = this.srcPt = new Point(x, y);\n\t\t\n\t\t// list of View nodes from target to root\n\t\tthis.trace = [];\n\t\t\n\t\t// Top-most view where event is dispatched (e.g. the tree root)\n\t\tthis.root = root || null;\n\t\t\n\t\t// time of dispatch\n\t\tthis.when = timer.now;\n\t\t\n\t\t// Bottom-most view where the event occurred\n\t\tthis.target = target || null;\n\t}\n\t\n\tthis.cancel = function() {\n\t\tthis.cancelled = true;\n\t}\n\n\tthis.clone = function() {\n\t\treturn new InputEvent(this.id, this.type, this.srcPt.x, this.srcPt.y, this.root, this.target);\n\t}\n});\n","pre":true},"../../../../sdk/timestep/timer.js":{"path":"../../../../sdk/timestep/timer.js","friendlyPath":"timer","directory":"../../../../sdk/timestep/","filename":"timer.js","baseMod":"timer","basePath":"../../../../sdk/timestep","src":"/**\n * @module timer\n *\n * Implements an independent, singleton timer for use by the environment.\n * The Application Engine binds to this to generate the rendering tick.\n */\n\njsio(\"import device\");\n\nvar Timer = device.get('Timer');\n\nvar MAX_TICK = 10000; // ticks over 10 seconds will be considered too large to process\nexports.now = 0;\nexports.frames = 0;\nexports.reset = function() { this._last = null; }\nexports.tick = function(dt) {\n\ttry {\n\t\tif (dt > MAX_TICK) {\n\t\t\texports.onLargeTick(dt, MAX_TICK);\n\t\t\tdt = 1;\n\t\t}\n\t\t\n\t\texports.now += dt;\n\t\texports.frames++;\n\t\texports.onTick(dt);\n\t\tok = true;\n\t} finally {\n\t\tif (exports.debug && !ok) {\n\t\t\tapp.stopLoop()\n\t\t}\n\t}\n}\n\n/**\n * If our computer falls asleep, dt might be an insanely large number. \n * If we're running a simulation of sorts, we don't want the computer\n * to freeze while computing 1000s of simulation steps, so just drop\n * this tick.  Anyone who is interested can listen for a call to 'onLargeTick'\n */\nexports.onLargeTick = function(largeDt, threshold) {\n\tlogger.warn('Dropping large tick: ' + largeDt + '; Threshold is set at: ' + threshold);\n}\n\nexports.onTick = function(dt) {}\n\nexports.debug = false;\n\n\n// TODO: <jsio>('from iOS import start as exports.start, stop as exports.stop');\n\nexports.start = function(minDt) {\n\tthis.reset();\n\tthis.isRunning = true;\n\tdevice.get('Timer').start(exports.tick, minDt);\n}\n\nexports.stop = function() {\n\tthis.reset();\n\tthis.isRunning = false;\n\tdevice.get('Timer').stop();\n}\n\nexports.getTickProgress = function() {\n\tvar now = +new Date;\n\treturn (-(Timer.last || now) + now);\n}\n","pre":true},"../../../../sdk/timestep/ui/backend/ReflowManager.js":{"path":"../../../../sdk/timestep/ui/backend/ReflowManager.js","friendlyPath":"ui.backend.ReflowManager","directory":"../../../../sdk/timestep/ui/backend/","filename":"ReflowManager.js","src":"var DEBUG = false;\n\nif (DEBUG) {\n\tvar _debug = {\n\t\tspace: '',\n\t\tstepIn: function () { this.space += ' '; return true; },\n\t\tstepOut: function () { this.space = this.space.slice(0, this.space.length - 1); return true; },\n\t\tlog: function () { logger.log.apply(logger, [this.space].concat(Array.prototype.slice.call(arguments, 0))); return true; }\n\t};\n\tlogger.log(\"===== CREATING REFLOW MANAGER\");\n}\n\n// max reflows for any view in a given tick\nvar MAX_REFLOW_THRESHOLD = 6;\n\nvar _pool = new (Class(function () {\n\tthis._pool = [];\n\n\tthis.recycle = function (item) {\n\t\titem.count = 0;\n\t\titem.view = null;\n\t\tthis._pool.push(item);\n\t}\n\n\tthis.get = function (view) {\n\t\tvar item = this._pool.pop() || {};\n\t\titem.view = view;\n\n\t\titem.iter = 0;\n\t\titem.count = 0;\n\t\treturn item;\n\t}\n}));\n\n/**\n * The ReflowManager is the controller for view layout.  It hooks into\n * the render cycle in two places:\n *  1. at the start of a render to reflow any views that we know\n *     need layout.  This is signalled by calling calls to needsReflow\n *     on a view between render cycles that result in a call to \n *     `ReflowMgr.add`.\n *  2. during render, if the view hasn't ever been rendered, the \n *     ReflowManager is notified to initiate the buildView call\n *     and handle any reflow logic before the view's first render.\n * The ReflowManager uses a queue-like structure to resolve the reflow \n * constraints. Views notify the ReflowManager through the add(view) \n * method, which then adds the view to the queue.  During a reflow cycle,\n * the ReflowManager tracks how many iterations through the queue each \n * view actually gets reflowed.  If the number of reflows exceeds the\n * MAX_REFLOW_THRESHOLD, reflow stops for that view, preventing infinite\n * loops when reflow cycles occur.\n */\n\nvar sdk_timestep_ui_backend_ReflowManager=__class__;var ReflowManager = exports=sdk_timestep_ui_backend_ReflowManager(function sdk_timestep_ui_backend_ReflowManager(){return this.init&&this.init.apply(this,arguments)},function () {\n\tthis.init = function () {\n\t\tthis._pending = {};\n\t\tthis._iter = 0;\n\t}\n\n\tthis.setInRender = function (isInRender) {\n\t\tthis._isInRender = isInRender;\n\t}\n\n\tthis.add = function (view) {\n\t\tvar uid = view.uid;\n\t\tvar item = this._pending[uid] || (this._pending[uid] = _pool.get(view));\n\n\t\titem.needsReflow = true;\n\n\t\t// increment count once per reflow iteration\n\t\tif (item.iter != this._iter) {\n\t\t\titem.count++;\n\t\t\titem.iter = this._iter;\n\t\t}\n\n\t\tDEBUG && _debug.log('adding view', uid, view.style.width + 'x' + view.style.height, view.getTag());\n\n\t\tif (this._isInRender && !this._isInReflow) {\n\t\t\tthis.startReflow(this._lastCtx);\n\t\t}\n\t}\n\n\tthis._reflow = function (ctx, item) {\n\t\titem.needsReflow = false;\n\n\t\tvar view = item.view;\n\t\tvar style = view.style;\n\t\tif (!style.__firstRender) {\n\t\t\tstyle.__firstRender = true;\n\n\t\t\tDEBUG && _debug.log('calling buildView for', view.uid, '(' + view.style.width + 'x' + view.style.height + ')') && _debug.stepIn();\n\t\t\tview.buildView(ctx);\n\t\t\tDEBUG && _debug.stepOut();\n\t\t}\n\n\t\tif (view.hasListeners('Resize')) {\n\t\t\tvar w = style.width;\n\t\t\tvar h = style.height;\n\t\t\tif (style.__cachedWidth != w || style.__cachedHeight != h) {\n\t\t\t\tstyle.__cachedWidth = w;\n\t\t\t\tstyle.__cachedHeight = h;\n\t\t\t\tview.publish('Resize');\n\t\t\t}\n\t\t}\n\n\t\tif (view.__layout) { view.__layout.reflow(); }\n\t\tview.reflow(false);\n\t}\n\n\tthis.startReflow = function (ctx) {\n\t\tthis._lastCtx = ctx;\n\t\tthis._isInReflow = true;\n\t\tthis._iter = 0;\n\t\tvar count;\n\n\t\tDEBUG && _debug.stepIn();\n\n\t\t// as long as we reflowed some views, keep looping\n\t\tdo {\n\t\t\t++this._iter; // what iteration are we on? only increment a view's count once per iteration\n\n\t\t\tcount = 0;\n\t\t\tfor (var uid in this._pending) {\n\t\t\t\tvar item = this._pending[uid];\n\t\t\t\tif (item.count > MAX_REFLOW_THRESHOLD) {\n\t\t\t\t\tlogger.warn('reflow loop detected for view', item.view.uid);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (item.needsReflow) {\n\t\t\t\t\tDEBUG && _debug.log('starting reflow for view', item.view.uid, '(' + item.count + ' times)') && _debug.stepIn();\n\t\t\t\t\tthis._reflow(ctx, item);\n\t\t\t\t\tDEBUG && _debug.stepOut();\n\t\t\t\t\t++count;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tDEBUG && count && _debug.log('iteration', this._iter, 'reflowed', count, 'views');\n\t\t} while (count);\n\n\t\t// recyle items\n\t\tfor (var uid in this._pending) {\n\t\t\t_pool.recycle(this._pending[uid]);\n\t\t}\n\n\t\tthis._pending = {};\n\t\tthis._isInReflow = false;\n\n\t\tDEBUG && _debug.stepOut();\n\t}\n\n});\n\nvar _instance = null;\nexports.get = function () {\n\treturn (_instance || (_instance = new ReflowManager()));\n}\n","pre":true},"../../../../sdk/timestep/ui/StackView.js":{"path":"../../../../sdk/timestep/ui/StackView.js","friendlyPath":".StackView","directory":"../../../../sdk/timestep/ui/","filename":"StackView.js","src":"/**\n * @class ui.StackView;\n * Implements a view which can switch out one of several child views to display at the front.\n *\n * @doc http://doc.gameclosure.com/api/ui-stackview.html\n * @docsrc https://github.com/gameclosure/doc/blob/master/api/ui/stackview.md\n */\n\njsio(\"import ui.layout.LinearView as LinearView\");\njsio(\"import animate\");\n\n/**\n * @extends ui.layout.LinearView\n */\nvar sdk_timestep_ui_StackView=__class__;exports=sdk_timestep_ui_StackView(function sdk_timestep_ui_StackView(){return this.init&&this.init.apply(this,arguments)},LinearView, function(supr) {\n\tthis.init = function(opts) {\n\t\tsupr(this, 'init', arguments);\n\t\tthis.stack = [];\n\t};\n\n\tthis.getStack = function() { return this.stack; };\n\n\tthis.getCurrentView = function() {\n\t\tif (!this.stack.length) { return null; }\n\t\treturn this.stack[this.stack.length - 1];\n\t};\n\n\tthis.push = function(view, dontAnimate, backwards) {\n\t\t// don't animate the first (base) view of a stackview unless explicitly asked to\n\t\tif (!this.stack[0] && dontAnimate !== false) {\n\t\t\tdontAnimate = true;\n\t\t}\n\n\t\tvar current = this.getCurrentView();\n\t\tif (current) { this._hide(current, dontAnimate); }\n\t\tview.style.width = this.style.width / view.style.scale;\n\t\tview.style.height = this.style.height / view.style.scale;\n\t\tthis.stack.push(view);\n\t\tthis._show(view, dontAnimate, backwards);\n\t\treturn view;\n\t};\n\n\tthis._hide = function(view, dontAnimate, backward) {\n\t\tview.publish('ViewWillDisappear');\n\t\tif (!dontAnimate) {\n\t\t\tthis.getInput().blockEvents = true;\n\t\t\tanimate(view)\n\t\t\t\t.then({x: (backward ? 1 : -1) * this.style.width})\n\t\t\t\t.then(bind(this, function () {\n\t\t\t\t\tthis.removeSubview(view);\n\t\t\t\t\tview.publish('ViewDidDisappear');\n\t\t\t\t\tthis.getInput().blockEvents = false;\n\t\t\t\t}));\n\t\t} else {\n\t\t\tthis.removeSubview(view);\n\t\t\tview.publish('ViewDidDisappear');\n\t\t}\n\t};\n\n\tthis._show = function(view, dontAnimate, backward) {\n\t\tview.publish('ViewWillAppear');\n\t\tview.style.visible = true;\n\t\tif (!dontAnimate) {\n\t\t\tview.style.x = (backward ? -1 : 1) * this.style.width;\n\t\t\tthis.addSubview(view);\n\t\t\tanimate(view)\n\t\t\t\t.then({x: 0})\n\t\t\t\t.then(bind(view, 'publish', 'ViewDidAppear'));\n\t\t} else {\n\t\t\tthis.addSubview(view);\n\t\t\tview.style.x = 0;\n\t\t\tview.publish('ViewDidAppear');\n\t\t}\n\t};\n\n\tthis.hasView = function(view) {\n\t\treturn this.stack.indexOf(view) >= 0;\n\t};\n\n\tthis.remove = function(view) {\n\t\tvar i = this.stack.indexOf(view);\n\t\tif (i >= 0) {\n\t\t\tthis.stack.splice(i, 1);\n\t\t}\n\t}\n\n\tthis.pop = function(dontAnimate, animateBackward) {\n\t\tif (!this.stack.length) { return false; }\n\t\tvar view = this.stack.pop();\n\t\t//animateBackwards by default\n\t\tvar animateBackward = (animateBackward === false) ? false : true;\n\t\tthis._hide(view, dontAnimate, animateBackward);\n\n\t\tif (this.stack.length) {\n\t\t\tthis._show(this.stack[this.stack.length - 1], dontAnimate, true);\n\t\t}\n\n\t\treturn view;\n\t};\n\n\tthis.popAll = function(dontAnimate) {\n\t\twhile (this.stack[1]) {\n\t\t\tthis.pop(dontAnimate);\n\t\t}\n\t};\n});\n","pre":true},"../../../../sdk/timestep/ui/layout/LinearView.js":{"path":"../../../../sdk/timestep/ui/layout/LinearView.js","friendlyPath":"ui.layout.LinearView","directory":"../../../../sdk/timestep/ui/layout/","filename":"LinearView.js","src":"/**\n * @package ui.layout.LinearView;\n *\n * Essentially a view proxy for a contained LinearLayout. Mainly contains logic\n * for reflowing in either significant direction.\n * Exposes LinearLayout in a .layout property.\n */\n\njsio(\"import ui.View as View\");\njsio(\"import ui.layout.Padding as Padding\");\njsio(\"import ui.layout.LinearLayout as LinearLayout\");\n\nvar DEBUG = false;\nvar _debug = {\n\t\tviews: {},\n\t\tmap: {}\n\t};\n\n/*\nStyle utilizes these properties:\n  left, right, top, bottom\n  centerX, centerY, widthPercent, heightPercent\n  inLayout\n\n\n*/\n\n/**\n * @extends ui.View\n */\nexports = View;\n\nif (DEBUG) {\n\tsetTimeout(function() {\n\n\t\tjsio(\"import ui.Engine\");\n\t\tui.Engine.get().subscribe('Render', _debug, function (ctx) {\n\t\t\tif (!ctx) { return; }\n\t\t\t\n\t\t\tvar now = +new Date();\n\n\t\t\tfor (var id in this.views) {\n\t\t\t\tvar data = this.map[id];\n\t\t\t\tvar view = data.view;\n\t\t\t\tif (now - this.views[id] < 500) {\n\n\t\t\t\t\tif (!data.alpha) { data.alpha = 0.4; }\n\t\t\t\t\tif (!data.state) {\n\t\t\t\t\t\tdata.alpha += 0.02;\n\t\t\t\t\t\tif (data.alpha > 0.6) { data.alpha = 0.6; data.state = true; }\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdata.alpha -= 0.02;\n\t\t\t\t\t\tif (data.alpha < 0.4) { data.alpha = 0.4; data.state = false; }\n\t\t\t\t\t}\n\n\t\t\t\t\tvar pos = view.getPosition();\n\t\t\t\t\tctx.save();\n\t\t\t\t\tctx.translate(pos.x, pos.y);\n\t\t\t\t\tctx.rotate(pos.r);\n\t\t\t\t\tctx.fillStyle = 'rgba(255, 255, 255, ' + data.alpha + ')';\n\t\t\t\t\tctx.fillRect(0, 0, pos.width, pos.height);\n\t\t\t\t\tctx.restore();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t});\n}\n","pre":true},"../../../../sdk/timestep/ui/View.js":{"path":"../../../../sdk/timestep/ui/View.js","friendlyPath":"ui.View","directory":"../../../../sdk/timestep/ui/","filename":"View.js","baseMod":"ui","basePath":"../../../../sdk/timestep","src":"/**\n * @class ui.View;\n * The View base class.\n *\n * @doc http://doc.gameclosure.com/api/ui-view.html\n * @docsrc https://github.com/gameclosure/doc/blob/master/api/ui/view.md\n */\n\njsio(\"import device\");\njsio(\"import event.Emitter as Emitter\");\n\njsio(\"import math.geom.Point as Point\");\njsio(\"import math.geom.Rect as Rect\");\njsio(\"import math.geom.Circle as Circle\");\n\njsio(\"import .backend.canvas.ViewBacking\");\n\njsio(\"import ui.backend.ReflowManager as ReflowManager\");\nvar _reflowMgr = ReflowManager.get();\n\njsio(\"import event.input.dispatch as dispatch\");\njsio(\"import event.input.InputHandler as InputHandler\");\n\njsio(\"import animate\");\n\njsio(\"import util.setProperty\");\n\n\nvar KeyListener = device.get('KeyListener');\n\nEventScheduler=__class__;var EventScheduler=EventScheduler(function EventScheduler(){return this.init&&this.init.apply(this,arguments)},function () {\n\tthis.init = function () {\n\t\tthis._queue = [];\n\t}\n\n\tthis.add = function (f) {\n\t\tthis._queue.push(f);\n\n\t\tif (!this._running) {\n\t\t\tthis._running = true;\n\t\t\twhile ((f = this._queue.shift())) {\n\t\t\t\tf();\n\t\t\t}\n\t\t\tthis._running = false;\n\t\t}\n\t}\n});\n\nvar scheduler = new EventScheduler();\n\n/**\n * This singleton class controls the focus of the current application. Only one\n * view can be focused at a given time.\n *\n * This doesn't correspond to native and isn't being used.\n */\nvar FocusMgr = new (Class(function() {\n\tthis.init = function(opts) {\n\t\tthis._keyListener = KeyListener && (new KeyListener());\n\t\tthis._target = null;\n\t\tthis._canChange = true;\n\t};\n\n\t/**\n\t * Focus the target, unfocusing the last target with focus.\n\t */\n\tthis.focus = function (target) {\n\t\tif (this._target != target && this._canChange) {\n\t\t\tif (this._target && this._target.onBlur) {\n\t\t\t\tthis._target.onBlur(this);\n\t\t\t}\n\n\t\t\tthis._target = target;\n\t\t\tif (target && target.onFocus) {\n\t\t\t\tthis._target.onFocus(this);\n\t\t\t}\n\t\t}\n\t};\n\n\tthis.blur = function(target) {\n\t\ttarget.onBlur && target.onBlur(this);\n\t\tthis._target = false;\n\t};\n\n\t/**\n\t * Return the keylistener used by the focus manager.\n\t */\n\tthis.getKeyListener = function() {\n\t\treturn this._keyListener;\n\t};\n\n\tthis.get = function() {\n\t\treturn this;\n\t};\n}));\n\n/**\n * Unique ID counter for all views.\n */\nvar UID = 0;\n\nvar _BackingCtor = null;\n\n/**\n * @extends event.Emitter\n */\nvar sdk_timestep_ui_View=__class__;var View = exports=sdk_timestep_ui_View(function sdk_timestep_ui_View(){return this.init&&this.init.apply(this,arguments)},Emitter, function() {\n\t/**\n\t * circle: boolean, default false - if true, use circular bounds for the view rather than rectangular and center the view at the origin\n\t * infinite: boolean, default false - if true, no bounding shape at all (e.g. infinite scroll plane)\n\t * clip: boolean, default false - if true, always clip to the region\n\t * canHandleEvents: boolean, default true - if false, this view is ignored for event handling\n\t * parent: object, if provided, sets the initial superview\n\t */\n\tthis.init = function (opts) {\n\t\tif (!opts) { opts = {}; }\n\n\t\tthis.uid = ++UID;\n\t\tthis.__input = new InputHandler(this, opts);\n\n\t\t// set with View.setDefaultViewBacking();\n\t\tthis.__view = this.style = new (opts.Backing || _BackingCtor)(this, opts);\n\n\t\tthis._filters = {};\n\n\t\tthis.__view._view = this;\n\n\t\tthis.updateOpts(opts);\n\t};\n\n\tthis.updateOpts = function(opts) {\n\t\topts = opts || {};\n\t\tif (this._opts) {\n\t\t\tfor (var key in opts) {\n\t\t\t\tthis._opts[key] = opts[key];\n\t\t\t}\n\t\t} else {\n\t\t\tthis._opts = opts;\n\t\t}\n\n\t\tif (opts.tag) { this.tag = opts.tag; }\n\t\tif (opts.filters) { this._filters = opts.filters; }\n\n\t\tif (opts.circle) {\n\t\t\tthis._circle = opts.circle;\n\t\t}\n\t\tif (opts.infinite) {\n\t\t\tthis._infinite = opts.infinite;\n\t\t}\n\n\t\tthis.style.update(opts);\n\n\t\tif (opts.superview) {\n\t\t\topts.superview.addSubview(this);\n\t\t}\n\t\t//opts.parent is deprecated, use opts.superview instead\n\t\tif (opts.parent) {\n\t\t\topts.parent.addSubview(this);\n\t\t}\n\n\t\treturn opts;\n\t};\n\n\t// --- filters ---\n\n\t/**\n\t * Returns an array of filters attached to this view.\n\t */\n\tthis.getFilters = function() { return this._filters; };\n\n\t/**\n\t * Adds a filter to this view. Only one filter of each type can exist on a view.\n\t */\n\tthis.addFilter = function(filter) { this._filters[filter.getType()] = filter; };\n\n\t/**\n\t * Remove a named filter from this view.\n\t */\n\tthis.removeFilter = function(type) { delete this._filters[type]; };\n\n\t// --- render/tick setters ---\n\n\t/**\n\t * Adds a hook to determine when the \"render\" property is set.\n\t */\n\tutil.setProperty(this, 'render', {\n\t\t\tvalue: undefined,\n\t\t\tcb: function() { this.__view && (this.__view.hasJSRender = true); }\n\t\t});\n\n\t/**\n\t * Adds a hook to determine when the \"tick\" property is set.\n\t */\n\tutil.setProperty(this, 'tick', {\n\t\t\tvalue: undefined,\n\t\t\tcb: function() { this.__view && (this.__view.hasJSTick = true); }\n\t\t});\n\n\t// --- animation component ---\n\n\t/**\n\t * Get an animation group from this view.\n\t */\n\tthis.getAnimation = function(groupID) {\n\t\treturn animate(this, groupID);\n\t};\n\n\t/**\n\t * @deprecated\n\t * Return an animation object for this view.\n\t */\n\tthis.animate = function(style, duration, easing) { return this.getAnimation().then(style, duration, easing); };\n\n\t// --- ui focus/blur component ---\n\n\t/**\n\t * Indicate to the focus manager singleton this element is focused.\n\t */\n\tthis.focus = function() { FocusMgr.get().focus(this); return this; };\n\n\t/**\n\t * Indicate to the focus manager singleton this element is blurred.\n\t */\n\tthis.blur = function() { FocusMgr.get().blur(this); return this; };\n\n\t/**\n\t * Triggered when focus is given to this view.\n\t */\n\tthis.onFocus = function() { this._isFocused = true; };\n\n\t/**\n\t * Indicate to the focus manager singleton this element is blurred.\n\t */\n\tthis.onBlur = function() { this._isFocused = false; };\n\n\t// --- input component ---\n\n\t/**\n\t * Returns a boolean indicating we are currently dragging this view.\n\t */\n\tthis.isDragging = function() { return this.__input.isDragging(); };\n\n\t/**\n\t * Start responding to touch input by dragging this view.\n\t */\n\tthis.startDrag = function(opts) { this.__input.startDrag(opts); };\n\n\t/**\n\t * Return the InputHandler for this view.\n\t */\n\tthis.getInput = function() { return this.__input; };\n\n\t/**\n\t * Returns a boolean indicating if a touch is on this view.\n\t */\n\tthis.isInputOver = function() { return !!this.__input.overCount; };\n\n\t/**\n\t * Returns a number indicating how many touches are on this view.\n\t */\n\tthis.getInputOverCount = function() { return this._inputOverCount; };\n\n\t/**\n\t * @deprecated\n\t */\n\tvar _warnedOnce = false;\n\tthis.canHandleEvents = function(canHandleEvents) {\n\t\tif (!_warnedOnce) {\n\t\t\tlogger.warn('canHandleEvents is deprecated');\n\t\t\t_warnedOnce = true;\n\t\t}\n\n\t\tthis.__input.canHandleEvents = canHandleEvents;\n\t};\n\n\t// TODO: think about refactoring internal components and exposing them differently...\n\tthis.setIsHandlingEvents = function (canHandleEvents) { this.__input.canHandleEvents = canHandleEvents; };\n\tthis.isHandlingEvents = function () { return this.__input.canHandleEvents; };\n\n\tthis.needsRepaint = function() { this._needsRepaint = true; }\n\tthis.needsReflow = function(force) {\n\t\tif (this.style.__firstRender || force) {\n\t\t\t_reflowMgr.add(this);\n\t\t\tthis._needsRepaint = true;\n\t\t}\n\t};\n\n\t/**\n\t * Consumes an event targeting this view.\n\t * NOTE: Does no actual propagation.\n\t */\n\tthis._onEventPropagate = function(evt, pt, atTarget) {\n\t\tif (atTarget) {\n\t\t\tvar id = evt.id;\n\t\t\tvar lastEvt;\n\t\t\tvar i;\n\n\t\t\tswitch(evt.type) {\n\t\t\t\tcase dispatch.eventTypes.SELECT:\n\t\t\t\tcase dispatch.eventTypes.CLEAR:\n\t\t\t\t\tdispatch._evtHistory[dispatch.eventTypes.MOVE] = null;\n\t\t\t\t\tlastEvt = dispatch._activeInputOver[id];\n\t\t\t\t\tif (lastEvt) {\n\t\t\t\t\t\tdispatch.clearOverState(id);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase dispatch.eventTypes.START:\n\t\t\t\tcase dispatch.eventTypes.MOVE:\n\t\t\t\t\t// translate input:move events into two higher-level events:\n\t\t\t\t\t//   input:over and input:out\n\n\t\t\t\t\tvar target = evt.trace[0];\n\t\t\t\t\tvar view = null;\n\n\t\t\t\t\t// fire input:out events first, start with deepest node and work out\n\t\t\t\t\tlastEvt = dispatch._activeInputOver[id];\n\t\t\t\t\tif (lastEvt && target != lastEvt.trace[0]) {\n\t\t\t\t\t\tvar trace = lastEvt.trace;\n\t\t\t\t\t\tfor (i = 0, view; view = trace[i]; ++i) {\n\t\t\t\t\t\t\tif (!(view.uid in evt.pt)) {\n\t\t\t\t\t\t\t\tview.__input.onLeave(id, target == view);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!lastEvt || target != lastEvt.trace[0]) {\n\t\t\t\t\t\t// fire input:over events second, start with outermost node and go to target\n\t\t\t\t\t\tvar trace = evt.trace;\n\t\t\t\t\t\tfor (i = evt.depth - 1; i >= 0; --i) {\n\t\t\t\t\t\t\ttrace[i].__input.onEnter(id, target == view);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// update current mouse trace\n\t\t\t\t\t\tdispatch._activeInputOver[id] = evt;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t};\n\n\tthis.localizePoint = function (pt) {\n\t\tvar list = this.getParents();\n\t\tvar i = 0;\n\t\tlist.push(this);\n\t\twhile (list[++i]) { pt = list[i].__view.localizePoint(pt); }\n\t\treturn pt;\n\t};\n\n\t// --- view hierarchy component ---\n\n\t/**\n\t * Return the subview at the given index.\n\t */\n\tthis.getSubview = function (i) {\n\t\treturn this.__view.getSubviews()[i];\n\t};\n\n\t/**\n\t * Returns an array of all subviews.\n\t */\n\tthis.getSubviews = function () {\n\t\treturn this.__view.getSubviews();\n\t};\n\n\t/**\n\t * Returns the superview of this view.\n\t */\n\tthis.getSuperview = function () {\n\t\treturn this.__view.getSuperview();\n\t};\n\n\tthis.connectEvent = function (src, name /*, args */) {\n\t\tif (!this.__subs) {\n\t\t\tthis.__subs = [];\n\n\t\t\tthis.on('ViewAdded', bind(this, '_connectEvents'));\n\t\t\tthis.on('ViewRemoved', bind(this, '_disconnectEvents'));\n\n\t\t\tif (this.__root) {\n\t\t\t\tthis._connectEvents();\n\t\t\t}\n\t\t}\n\n\t\tvar args = Array.prototype.slice.call(arguments, 1);\n\t\tthis.__subs.push([src, args]);\n\t\tif (this.__root) {\n\t\t\tsrc.on.apply(src, args);\n\t\t}\n\t}\n\n\tfunction compareSubscription (args, sub) {\n\t\t// note that args and sub may not be the same length\n\t\t// return true if all items in args match items in sub\n\t\t// (we don't care if sub has extra arguments)\n\t\tfor (var i = 0, n = args.length; i < n; ++i) {\n\t\t\tif (args[i] != sub[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tthis.disconnectEvent = function (src, name /*, args */) {\n\t\tif (this.__subs) {\n\t\t\tvar args = Array.prototype.slice.call(arguments, 1);\n\t\t\tfor (var i = 0, sub; sub = this.__subs[i]; ++i) {\n\t\t\t\tif (sub[0] == src && compareSubscription(args, sub[1])) {\n\t\t\t\t\tsub[0].removeListener.apply(sub[0], sub[1]);\n\t\t\t\t\tthis.__subs.splice(i--, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tthis._connectEvents = function () {\n\t\tfor (var i = 0, args; args = this.__subs[i]; ++i) {\n\t\t\targs[0].on.apply(args[0], args[1]);\n\t\t}\n\t}\n\n\tthis._disconnectEvents = function () {\n\t\tfor (var i = 0, args; args = this.__subs[i]; ++i) {\n\t\t\targs[0].removeListener.apply(args[0], args[1]);\n\t\t}\n\t}\n\n\t/**\n\t * Add a subview.\n\t */\n\tthis.addSubview = function (view) {\n\t\tif (this.__view.addSubview(view)) {\n\t\t\tview.needsRepaint();\n\t\t\tview.needsReflow();\n\n\t\t\t// if successful, clear any residual input over count\n\t\t\tview.__input.resetOver();\n\n\t\t\tthis.publish('SubviewAdded', view);\n\t\t\tif (this.__root) {\n\t\t\t\tvar root = this.__root;\n\t\t\t\tvar viewCreated = view;\n\t\t\t\tscheduler.add(bind(this, function recurse(view) {\n\t\t\t\t\tview.__root = root;\n\t\t\t\t\tview.emit('ViewAdded', viewCreated);\n\t\t\t\t\tvar subviews = view.getSubviews();\n\t\t\t\t\tfor (var i = 0, subview; subview = subviews[i]; ++i) {\n\t\t\t\t\t\trecurse(subview);\n\t\t\t\t\t}\n\t\t\t\t}, view));\n\t\t\t}\n\t\t}\n\n\t\treturn view;\n\t};\n\n\t/**\n\t * Removes a subview.\n\t */\n\tthis.removeSubview = function(view) {\n\t\tif (this.__view.removeSubview(view)) {\n\t\t\tthis.publish('SubviewRemoved', view);\n\t\t\tif (view.__root) {\n\t\t\t\tscheduler.add(bind(this, function recurse(view) {\n\t\t\t\t\tview.__root = null;\n\t\t\t\t\tview.emit('ViewRemoved', this);\n\t\t\t\t\tvar subviews = view.getSubviews();\n\t\t\t\t\tfor (var i = 0, subview; subview = subviews[i]; ++i) {\n\t\t\t\t\t\trecurse(subview);\n\t\t\t\t\t}\n\t\t\t\t}, view));\n\t\t\t}\n\t\t}\n\n\t\treturn view;\n\t}\n\n\t/**\n\t * Removes this view from its parent.\n\t */\n\tthis.removeFromSuperview = function() {\n\t\tvar superview = this.__view.getSuperview();\n\t\tif (superview) {\n\t\t\tsuperview.removeSubview(this);\n\t\t}\n\t};\n\n\t/**\n\t * Removes all subviews from this view.\n\t */\n\tthis.removeAllSubviews = function() {\n\t\tvar subviews = this.getSubviews();\n\t\tvar i = subviews.length;\n\t\twhile (i--) {\n\t\t\tthis.removeSubview(subviews[i]);\n\t\t}\n\t};\n\n\t// legacy implementation shim\n\tthis.__defineGetter__('_superview', this.getSuperview);\n\tthis.__defineSetter__('_superview', function () {});\n\tthis.__defineGetter__('_subviews', this.getSubviews);\n\tthis.__defineSetter__('_superview', function () {});\n\n\t// --- onResize callbacks ---\n\n\tthis.reflow = function () {\n\t};\n\n\t// ---\n\n\t/**\n\t * Get the root application for this view.\n\t */\n\tthis.getApp = function() {\n\t\tvar top = this;\n\t\tvar next;\n\t\tdo {\n\t\t\tnext = top.__view.getSuperview();\n\t\t} while (next && (top = next));\n\t\treturn top.__root;\n\t};\n\n\t/**\n\t * Returns an array of all ancestors of the current view.\n\t */\n\tthis.getParents = function() {\n\t\tvar list = [this];\n\t\tvar next;\n\t\tdo {\n\t\t\tnext = list[0].__view.getSuperview();\n\t\t} while (next && list.unshift(next));\n\n\t\tlist.pop();\n\t\treturn list;\n\t};\n\n\t/**\n\t * @interface\n\t */\n\tthis.buildView = function() {};\n\n\t/**\n\t * Determine if this view contains a point.\n\t */\n\tthis.containsLocalPoint = function(pt) {\n\t\tif (this._infinite) { return true; }  // infinite plane\n\n\t\tif (this._circle) { // bounding circle\n\t\t\tvar radius = this.style.radius;\n\t\t\treturn pt.x * pt.x + pt.y * pt.y < radius * radius;\n\t\t} else { // bounding box\n\t\t\tvar s = this.style,\n\t\t\t\tw = s.width,\n\t\t\t\th = s.height;\n\n\t\t\tif (w > 0 && h > 0) {\n\t\t\t\treturn pt.x <= w && pt.y <= h && pt.x >= 0 && pt.y >= 0;\n\t\t\t} else if (w > 0) {\n\t\t\t\treturn pt.x <= w && pt.y >= h && pt.x >= 0 && pt.y <= 0;\n\t\t\t} else if (h > 0) {\n\t\t\t\treturn pt.x >= w && pt.y <= h && pt.x <= 0 && pt.y >= 0;\n\t\t\t} else {\n\t\t\t\treturn pt.x >= w && pt.y >= h && pt.x <= 0 && pt.y <= 0;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Return the bounding shape for this view. The shape is defined in the\n\t * options object when this view was constructed.\n\t */\n\tthis.getBoundingShape = function() {\n\t\tvar s = this.style;\n\t\tif (this._infinite) {\n\t\t\treturn true;\n\t\t} else if (this._circle) {\n\t\t\treturn new Circle(s.x, s.y, s.radius * s.scale);\n\t\t} else {\n\t\t\treturn new Rect(s.x, s.y, s.width * s.scale, s.height * s.scale);\n\t\t}\n\t};\n\n\t/**\n\t * Given a rectangle and a parent view, compute the location of\n\t * the rectangle in this view's coordinate space.\n\t * WARNING: only works with non-rotated rectangles.\n\t * TODO Make it work with rotated rectangles!\n\t */\n\tthis.getRelativeRegion = function(region, parent) {\n\t\tvar offset = this.getPosition(parent || region.src);\n\t\treturn new Rect((region.x - offset.x) / offset.scale,\n\t\t\t\t\t\t(region.y - offset.y)  / offset.scale,\n\t\t\t\t\t\tregion.width / offset.scale,\n\t\t\t\t\t\tregion.height / offset.scale);\n\t};\n\n\t/**\n\t * Return a fully defined position, rotation, size, and scale for this view.\n\t */\n\tthis.getPosition = function(/* optional */ relativeTo) {\n\t\tvar abs = new Point(),\n\t\t\tview = this,\n\t\t\tr = 0,\n\t\t\ts = this.style,\n\t\t\tw = s.width,\n\t\t\th = s.height,\n\t\t\tc = 1;\n\n\t\twhile (view && view != relativeTo) {\n\t\t\tvar scale = view.style.scale;\n\n\t\t\t//translate to anchor point\n\t\t\tabs.add(\n\t\t\t\t-(view.style.anchorX),\n\t\t\t\t-(view.style.anchorY)\n\t\t\t);\n\n\t\t\t//scale and rotate\n\t\t\tabs.rotate(view.style.r);\n\t\t\tabs.scale(scale);\n\n\t\t\t//translate back\n\t\t\tabs.add(\n\t\t\t\tview.style.anchorX + view.style.x + view.style.offsetX,\n\t\t\t\tview.style.anchorY + view.style.y + view.style.offsetY\n\t\t\t);\n\n\t\t\tr += view.style.r;\n\t\t\tw *= scale;\n\t\t\th *= scale;\n\t\t\tc *= scale;\n\t\t\tview = view.__view.getSuperview();\n\t\t}\n\n\t\treturn {\n\t\t\tx: abs.x,\n\t\t\ty: abs.y,\n\t\t\tr: r % (2 * Math.PI),\n\t\t\twidth: w,\n\t\t\theight: h,\n\t\t\tscale: c,\n\t\t\tanchorX: this.style.anchorX,\n\t\t\tanchorY: this.style.anchorY\n\t\t};\n\t};\n\n\t/**\n\t * Exposes the internal implementation of the view hierarchy\n\t */\n\tthis.getBacking = function () {\n\t\treturn this.__view;\n\t};\n\n\t/**\n\t * Sets the visibility to true. Triggers repaint.\n\t */\n\tthis.show = function () {\n\t\tthis.style.visible = true;\n\t\tthis.needsRepaint();\n\t};\n\n\t/**\n\t * Sets the visibility to false. Triggers repaint.\n\t */\n\tthis.hide = function () {\n\t\tthis.style.visible = false;\n\t\tthis.needsRepaint();\n\t};\n\n\t/**\n\t * Return a human-readable tag for this view.\n\t */\n\tthis.getTag = function () {\n\t\tvar cls = \"View\";\n\n\t\tif (DEBUG) {\n\t\t\t//check the cached name\n\t\t\tif (this._className) {\n\t\t\t\tcls = this._className;\n\t\t\t} else {\n\t\t\t\t//generate the classname\n\t\t\t\tcls = this.constructor.name;\n\n\t\t\t\tcls = cls.substr(\n\t\t\t\t\tcls.lastIndexOf(\"_\") + 1\n\t\t\t\t);\n\n\t\t\t\tthis._className = cls;\n\t\t\t}\n\t\t}\n\n\t\treturn cls + this.uid + (this.tag ? ':' + this.tag : '');\n\t};\n\n\tthis.toString = function () {\n\t\treturn this.__view.__sortKey;\n\t};\n});\n\nvar _extensions = [];\nView.addExtension = function (ext) {\n\text.extend(View.BackingCtor);\n\t_extensions.push(ext);\n}\n\nView.setDefaultViewBacking = function (ViewBackingCtor) {\n\t_BackingCtor = View.BackingCtor = ViewBackingCtor;\n\t_extensions.forEach(function (ext) { ext.extend(_BackingCtor); });\n}\n\n// default view backing is canvas\nView.setDefaultViewBacking(backend.canvas.ViewBacking);\n","pre":true},"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/math/geom/Circle.js":{"path":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/math/geom/Circle.js","friendlyPath":"math.geom.Circle","directory":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/math/geom/","filename":"Circle.js","src":"jsio(\"import .Point\");\n\n/**\n * @extends math.geom.Point\n * Models a circle given a radius.\n *   Circle(x, y, radius)\n *   Circle({x: default 0, y: default 0, radius: default 0})\n */\nvar Users_arnovandervegt_gameclosure_basil_sdk_jsio_math_geom_Circle=__class__;exports=Users_arnovandervegt_gameclosure_basil_sdk_jsio_math_geom_Circle(function Users_arnovandervegt_gameclosure_basil_sdk_jsio_math_geom_Circle(){return this.init&&this.init.apply(this,arguments)},Point, function(supr) {\n\tthis.init = function(a, b, c) {\n\t\tswitch(arguments.length) {\n\t\t\tcase 0:\n\t\t\t\tthis.x = 0;\n\t\t\t\tthis.y = 0;\n\t\t\t\tthis.radius = 0;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\tcase 2:\n\t\t\t\tthis.x = a.x || 0;\n\t\t\t\tthis.y = a.y || 0;\n\t\t\t\tthis.radius = a.radius || 0;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tthis.x = a;\n\t\t\t\tthis.y = b;\n\t\t\t\tthis.radius = c;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * Scale the position and radius of this circle by a percentage.\n\t */\n\t\n\tthis.scale = function(s) {\n\t\tsupr(this, 'scale', arguments);\n\t\tthis.radius *= s;\n\t\treturn this;\n\t}\n});","pre":true},"../../../../sdk/timestep/ui/backend/canvas/ViewBacking.js":{"path":"../../../../sdk/timestep/ui/backend/canvas/ViewBacking.js","friendlyPath":".backend.canvas.ViewBacking","directory":"../../../../sdk/timestep/ui/backend/canvas/","filename":"ViewBacking.js","src":"/**\n * @package ui.backend.canvas.ViewStyle;\n *\n * Models the style object of the canvas View.\n */\n\njsio(\"import ..strPad\");\njsio(\"import ..BaseBacking\");\njsio(\"import util.setProperty as setProperty\");\n\nvar _styleKeys = {};\n\nvar sdk_timestep_ui_backend_canvas_ViewBacking=__class__;var ViewBacking = exports=sdk_timestep_ui_backend_canvas_ViewBacking(function sdk_timestep_ui_backend_canvas_ViewBacking(){return this.init&&this.init.apply(this,arguments)},BaseBacking, function () {\n\t\n\tthis.init = function (view) {\n\t\tthis._view = view;\n\t\tthis._subviews = [];\n\t}\n\n\tthis.getSuperview = function () { return this._superview; }\n\tthis.getSubviews = function () {\n\t\tif (this._needsSort) { this._needsSort = false; this._subviews.sort(); }\n\t\treturn this._subviews;\n\t}\n\n\tvar ADD_COUNTER = 900000;\n\tthis.addSubview = function (view) {\n\t\tvar backing = view.__view;\n\t\tvar superview = backing._superview;\n\t\tif (superview == this._view) { return false; }\n\t\tif (superview) { superview.__view.removeSubview(view); }\n\n\t\tvar n = this._subviews.length;\n\t\tthis._subviews[n] = view;\n\n\t\tbacking._superview = this._view;\n\t\tbacking._setAddedAt(++ADD_COUNTER);\n\n\t\tif (n && backing.__sortKey < this._subviews[n - 1].__view.__sortKey) {\n\t\t\tthis._needsSort = true;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tthis.removeSubview = function (targetView) {\n\t\tvar index = this._subviews.indexOf(targetView);\n\t\tif (index != -1) {\n\t\t\tthis._subviews.splice(index, 1);\n\t\t\t// this._view.needsRepaint();\n\n\t\t\ttargetView.__view._superview = null;\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tthis.wrapTick = function(dt, app) {\n\t\tthis._view.tick && this._view.tick(dt, app);\n\n\t\tfor (var i = 0, view; view = this._subviews[i]; ++i) {\n\t\t\tview.__view.wrapTick(dt, app);\n\t\t}\n\n\t\t// TODO: support partial repaints?\n\t\t// if (this._view._needsRepaint) {\n\t\t// \tthis._view._needsRepaint = false;\n\t\t// \tapp.needsRepaint();\n\t\t// }\n\t}\n\n\tthis.wrapRender = function(ctx, opts) {\n\t\tif (!this.visible) { return; }\n\t\t\n\t\tif (!this.__firstRender) { this._view.needsReflow(true); }\n\t\tif (this._needsSort) { this._needsSort = false; this._subviews.sort(); }\n\t\t\n\t\tvar width = this._width;\n\t\tvar height = this._height;\n\t\tif (!width || !height || width < 0 || height < 0) { return; }\n\n\t\tctx.save();\n\t\t\n\t\tctx.translate(this.x + this.anchorX + this.offsetX, this.y + this.anchorY + this.offsetY);\n\t\t\n\t\tif (this.r) { ctx.rotate(this.r); }\n\t\t\n\t\t// clip this render to be within its view;\n\t\tif (this.scale != 1) { ctx.scale(this.scale, this.scale); }\n\t\t\n\t\tif (this.opacity != 1) { ctx.globalAlpha *= this.opacity; }\n\n\t\tctx.translate(-this.anchorX, -this.anchorY);\n\n\t\tif (this.circle) { ctx.translate(-width / 2, -height / 2); }\n\n\t\tif (this.clip) { ctx.clipRect(0, 0, width, height); }\n\t\t\n\t\tvar filters = this._view.getFilters();\n\t\tctx.setFilters(filters);\n\n\t\tif (this.flipX || this.flipY) {\n\t\t\tctx.translate(\n\t\t\t\tthis.flipX ? width / 2 : 0,\n\t\t\t\tthis.flipY ? height / 2 : 0\n\t\t\t);\n\n\t\t\tctx.scale(\n\t\t\t\tthis.flipX ? -1 : 1,\n\t\t\t\tthis.flipY ? -1 : 1\n\t\t\t);\n\n\t\t\tctx.translate(\n\t\t\t\tthis.flipX ? -width / 2 : 0,\n\t\t\t\tthis.flipY ? -height / 2 : 0\n\t\t\t);\n\t\t}\n\n\t\ttry {\n\t\t\tif (this.backgroundColor) {\n\t\t\t\tctx.fillStyle = this.backgroundColor;\n\t\t\t\tctx.fillRect(0, 0, width, height);\n\t\t\t}\n\n\t\t\tvar viewport = opts.viewport;\n\t\t\tthis._view.render && this._view.render(ctx, opts);\n\t\t\tthis._renderSubviews(ctx, opts);\n\t\t\topts.viewport = viewport;\n\n\t\t} finally {\n\t\t\tctx.clearFilters();\n\t\t\tctx.restore();\n\t\t}\n\t}\n\n\tthis._renderSubviews = function(ctx, opts) {\n\t\tvar i = 0;\n\t\tvar view;\n\t\tvar subviews = this._subviews;\n\t\twhile (view = subviews[i++]) {\n\t\t\tview.__view.wrapRender(ctx, opts);\n\t\t}\n\t}\n\n\t// this._clearCache = function() { this._cache = null; }\n\t\n\t// this.updateRadius = function() {\n\t// \tvar w = this.width * 0.5,\n\t// \t\th = this.height * 0.5;\n\t\t\n\t// \tif (!this._cache) { this._cache = {}; }\n\t// \treturn (this._cache.radius = Math.sqrt(w * w + h * h));\n\t// }\n\t\n\tthis._onResize = function(prop, value, prevValue) {\n\t\t// local properties are invalidated\n\t\t// this._cache = null;\n\t\t\n\t\t// child view properties might be invalidated\n\t\tthis._view.needsReflow();\n\t}\n\t\n\tthis._sortIndex = strPad.initialValue;\n\tthis._onZIndex = function(_, zIndex) {\n\t\tthis._sortIndex = strPad.pad(zIndex);\n\n\t\tthis._setSortKey();\n\t\tthis._view.needsRepaint();\n\n\t\tvar superview = this._view.getSuperview();\n\t\tif (superview) { superview.__view._needsSort = true; }\n\t}\n\n\tthis._setAddedAt = function(addedAt) {\n\t\tthis._addedAt = addedAt;\n\t\tthis._setSortKey();\n\t}\n\n\tthis._setSortKey = function() {\n\t\tthis.__sortKey = this._sortIndex + this._addedAt;\n\t}\n\n\t//not implemented\n\tthis._onOffsetX = function (n) {\n\t\tthis.offsetX = n * this.width / 100;\n\t};\n\n\t//not implemented\n\tthis._onOffsetY = function (n) {\n\t\tthis.offsetY = n * this.height / 100;\n\t};\n\t\n\tthis.toString = function() { return this.__sortKey; }\n});\n","pre":true},"../../../../sdk/timestep/ui/backend/strPad.js":{"path":"../../../../sdk/timestep/ui/backend/strPad.js","friendlyPath":"..strPad","directory":"../../../../sdk/timestep/ui/backend/","filename":"strPad.js","src":"var LEN = 8;\nvar MAX = 99999999;\nvar MIN = -99999999;\nvar PAD = \"00000000\";\n\nexports.initialValue = PAD;\n\nexports.pad = function (val) {\n\tval = ~~val;\n\n\tif (val < MIN) { val = MIN; }\n\tif (val > MAX) { val = MAX; }\n\tif (val < 0) {\n\t\tval *= -1;\n\t\treturn '-' + PAD.substring(0, LEN - ('' + val).length) + val;\n\t} else {\n\t\treturn PAD.substring(0, LEN - ('' + val).length) + val;\n\t}\n};\n","pre":true},"../../../../sdk/timestep/ui/backend/BaseBacking.js":{"path":"../../../../sdk/timestep/ui/backend/BaseBacking.js","friendlyPath":"..BaseBacking","directory":"../../../../sdk/timestep/ui/backend/","filename":"BaseBacking.js","src":"\njsio(\"import util.setProperty as setProperty\");\n\nvar sdk_timestep_ui_backend_BaseBacking=__class__;var BaseBacking = exports=sdk_timestep_ui_backend_BaseBacking(function sdk_timestep_ui_backend_BaseBacking(){return this.init&&this.init.apply(this,arguments)},function () {\n\t\n\t// required methods:\n\t//\n\t// this._onResize = function () {};\n\t// this._onZIndex = function () {};\n\n\tvar styleKeys = this.constructor.styleKeys = {};\n\n\t// keys map to properties\n\tvar BASE_STYLE_PROPS = {\n\t\t'x': {value: 0},\n\t\t'y': {value: 0},\n\t\t'offsetX': {value: 0}, //translate\n\t\t'offsetY': {value: 0},\n\t\t'offsetXPercent': {value: undefined, cb: '_onOffsetX'}, //not implemented\n\t\t'offsetYPercent': {value: undefined, cb: '_onOffsetY'},\n\t\t'anchorX': {value: 0}, //rotation and scale\n\t\t'anchorY': {value: 0},\n\t\t'width': {cb: '_onResize'},\n\t\t'height': {cb: '_onResize'},\n\t\t'r': {value: 0},\n\t\t'opacity': {value: 1},\n\t\t'zIndex': {value: 0, cb: '_onZIndex'},\n\t\t// 'radius': {\n\t\t// \tget: function() {\n\t\t// \t\treturn this._cache && 'radius' in this._cache ? this._cache.radius : this.updateRadius();\n\t\t// \t}\n\t\t// },\n\t\t'scale': {value: 1},\n\t\t'flipX': {value: false},\n\t\t'flipY': {value: false},\n\t\t'visible': {value: true},\n\t\t'shadowColor': {value: 'black'},\n\t\t'clip': {value: false},\n\t\t'backgroundColor': {value: undefined}\n\t};\n\t\n\tthis.constructor.addProperty = function (key, def) {\n\t\tstyleKeys[key] = true;\n\t\tsetProperty(this.prototype, key, def);\n\t}\n\n\tfor (var key in BASE_STYLE_PROPS) {\n\t\tthis.constructor.addProperty(key, BASE_STYLE_PROPS[key]);\n\t}\n\n\tthis.localizePoint = function (pt) {\n\t\tpt.x -= this.x + this.anchorX + this.offsetX;\n\t\tpt.y -= this.y + this.anchorY + this.offsetY;\n\t\tif (this.r) { pt.rotate(-this.r); }\n\t\tpt.scale(1 / this.scale);\n\t\tpt.x += this.anchorX;\n\t\tpt.y += this.anchorY;\n\t\treturn pt;\n\t}\n\n\tthis.copy = function () {\n\t\tvar copy = {};\n\t\tfor (var key in styleKeys) {\n\t\t\tcopy[key] = this[key];\n\t\t}\n\n\t\treturn copy;\n\t}\n\t\n\tthis.update = function (style) {\n\t\tfor (var i in style) {\n\t\t\tif (style.hasOwnProperty(i) && styleKeys.hasOwnProperty(i)) {\n\t\t\t\tthis[i] = style[i];\n\t\t\t}\n\t\t}\n\t}\n});\n","pre":true},"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/util/setProperty.js":{"path":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/util/setProperty.js","friendlyPath":"util.setProperty","directory":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/util/","filename":"setProperty.js","src":"function createGetter(ctx, name) {\n\treturn function() {\n\t\treturn this[name];\n\t}\n}\n\nfunction createSetter(ctx, name, callback, initialValue) {\n\tif (initialValue !== undefined) {\n\t\tctx[name] = initialValue;\n\t}\n\t\n\tif (typeof callback == 'function') {\n\t\treturn function(value) {\n\t\t\tif (this[name] !== value) {\n\t\t\t\tvar old = this[name];\n\t\t\t\tthis[name] = value;\n\t\t\t\tcallback.call(this, name, value, old);\n\t\t\t}\n\t\t}\n\t} else if (typeof callback == 'string') {\n\t\treturn function(value) {\n\t\t\tif (this[name] !== value) {\n\t\t\t\tvar old = this[name];\n\t\t\t\tthis[name] = value;\n\t\t\t\tthis[callback](name, value, old);\n\t\t\t}\n\t\t}\n\t} else {\n\t\treturn function(value) {\n\t\t\tthis[name] = value;\n\t\t}\n\t}\n}\n\nexports = function(ctx, name, def) {\n\tif (!def.get && !def.set && !def.cb && ('value' in def)) {\n\t\tctx[name] = def.value;\n\t} else {\n\t\tif (!def.get) { def.get = createGetter(ctx, '_' + name); }\n\t\tif (!def.set) { def.set = createSetter(ctx, '_' + name, def.cb, def.value); }\n\t\tif ('value' in def) { ctx['_' + name] = def.value; }\n\n\t\tdelete def.value;\n\t\tif (Object.defineProperty) {\n\t\t\tObject.defineProperty(ctx, name, def);\n\t\t\t// merge(def, {\n\t\t\t// \t\t\t\tconfigurable: false,\n\t\t\t// \t\t\t\tenumerable: true\n\t\t\t// \t\t\t});\n\t\t} else if (ctx.__defineSetter__) {\n\t\t\tctx.__defineSetter__(name, def.set);\n\t\t\tctx.__defineGetter__(name, def.get);\n\t\t} else {\n\t\t\tctx[name] = def.value;\n\t\t}\n\t}\n}\n","pre":true},"../../../../sdk/timestep/event/input/InputHandler.js":{"path":"../../../../sdk/timestep/event/input/InputHandler.js","friendlyPath":"event.input.InputHandler","directory":"../../../../sdk/timestep/event/input/","filename":"InputHandler.js","src":"/**\n * @class event.input.InputHandler;\n * An event handler proxy for an individual view. This handles dispatching\n * of events onto the actual view itself, as well as determining if the view\n * is the actual target of a propagated event. \n */\n\njsio(\"import math.geom.Point as Point\");\njsio(\"import event.input.dispatch as dispatch\");\n\nvar sdk_timestep_event_input_InputHandler=__class__;var InputHandler = exports=sdk_timestep_event_input_InputHandler(function sdk_timestep_event_input_InputHandler(){return this.init&&this.init.apply(this,arguments)},function() {\n\t\n\t// ---- start mouseover\n\t\n\tthis.dragCount = 0;\n\tthis.overCount = 0;\n\tthis.canHandleEvents = true;\n\tthis.blockEvents = false;\n\n\tthis.init = function(view, opts) {\n\t\tthis.view = view;\n\n\t\tif ('canHandleEvents' in opts) {\n\t\t\tthis.canHandleEvents = opts.canHandleEvents;\n\t\t}\n\n\t\tif ('blockEvents' in opts) {\n\t\t\tthis.blockEvents = opts.blockEvents;\n\t\t}\n\t}\n\t\n\tthis.containsEvent = function(evt, localPt) {\n\t\t// block events must be false\n\t\treturn !this.blockEvents && (!this.view._superview   // top-view captures all events\n\t\t\t\t|| this.view.containsLocalPoint(localPt));\n\t}\n\n\tthis.onEnter = function(id, atTarget) {\n\t\tvar view = this.view;\n\t\tvar over = this._over || (this._over = {});\n\t\tif (id in over) { return; }\n\t\t\n\t\tover[id] = true;\n\t\tthis.overCount++;\n\t\t\n\t\tif (view.onInputOver) { view.onInputOver(over, this.overCount, atTarget); }\n\t\tview.publish('InputOver', over, this.overCount, atTarget);\n\t}\n\t\n\tthis.onLeave = function(id, atTarget) {\n\t\tvar view = this.view;\n\t\tvar over = this._over || (this._over = {});\n\t\tif (!(id in over)) { return; }\n\t\t\n\t\tdelete over[id];\n\t\t--this.overCount;\n\t\t\n\t\tif (view.onInputOut) { view.onInputOut(over, this.overCount, atTarget); }\n\t\tview.publish('InputOut', over, this.overCount, atTarget);\n\t}\n\t\n\tthis.resetOver = function() {\n\t\tdelete this._over;\n\t\tthis.overCount = 0;\n\t}\n\t\n\t// ---- end mouseover\n\t\n\t\n\t// ---- start drag\n\t\n\tthis.startDrag = function(opts) {\n\t\topts = opts || {};\n\t\tvar view = this.view;\n\t\tvar inputStartEvt = opts.inputStartEvt || dispatch._evtHistory[dispatch.eventTypes.START];\n\t\tvar id = inputStartEvt.id;\n\t\t\n\t\t// dedup drags from same input ID\n\t\tvar dragging = this._isDragging || (this._isDragging = {});\n\t\tif (dragging[id]) { return; }\n\t\tdragging[id] = true;\n\t\t\n\t\t++this.dragCount;\n\n\t\tvar root = inputStartEvt.root;\n\t\tvar dragEvt = new dispatch.InputEvent(inputStartEvt.id, 'input:drag', inputStartEvt.srcPt.x, inputStartEvt.srcPt.y, root, view);\n\t\t\n\t\tdragEvt.didDrag = false;\n\t\tdragEvt.radius = opts.radius * opts.radius || 0;\n\t\t\n\t\troot.subscribe('InputMoveCapture', this, 'onDragStart', dragEvt);\n\t\troot.subscribe('InputSelectCapture', this, 'onDragStop', dragEvt);\n\t}\n\t\n\tthis.isDragging = function() { return this.dragCount && dispatch._isDragging; }\n\t\n\tthis.onDragStart = function(dragEvt, moveEvt) {\n\t\t// have we exceeded the move radius?\n\t\tvar dx = moveEvt.srcPt.x - dragEvt.srcPt.x;\n\t\tvar dy = moveEvt.srcPt.y - dragEvt.srcPt.y;\n\t\tif (dx * dx + dy * dy <= dragEvt.radius) { return; }\n\n\t\tvar view = this.view;\n\t\t\n\t\t// no longer need to listen for move events for onDragStart\n\t\tdragEvt.root.unsubscribe('InputMoveCapture', this, 'onDragStart');\n\t\t\n\t\t// want to fire onDragStart with the current point equal to the initial point \n\t\t// even though the user has moved away by now\n\t\tdragEvt.currPt = dragEvt.srcPt;\n\t\tdragEvt.localPt = view.localizePoint(new Point(dragEvt.currPt));\n\n\t\tif (view.onDragStart) { view.onDragStart(dragEvt); }\n\t\tview.publish('DragStart', dragEvt);\n\t\t\n\t\t// future move events should be captured by _onDrag\n\t\t// we should also call _onDrag now to handle the current move event delta\n\t\tdragEvt.root.subscribe('InputMoveCapture', this, 'onDrag', dragEvt);\n\t\tthis.onDrag(dragEvt, moveEvt);\n\t}\n\t\n\tthis.onDrag = function(dragEvt, moveEvt) {\n\t\tif (dragEvt.id != moveEvt.id\n\t\t\t\t|| moveEvt.srcPt.x == dragEvt.currPt.x && moveEvt.srcPt.y == dragEvt.currPt.y) { return; }\n\n\t\tvar view = this.view;\n\t\t\n\t\tdragEvt.prevPt = dragEvt.currPt;\n\t\tdragEvt.currPt = moveEvt.srcPt;\n\n\t\tdragEvt.prevLocalPt = dragEvt.localPt;\n\t\tdragEvt.localPt = view.localizePoint(new Point(dragEvt.currPt));\n\n\t\tdragEvt.didDrag = true;\n\t\t\n\t\tvar delta = Point.subtract(dragEvt.localPt, dragEvt.prevLocalPt);\n\n\t\tdispatch._isDragging = true;\n\n\t\tif (view.onDrag) { view.onDrag(dragEvt, moveEvt, delta); }\n\t\tview.publish('Drag', dragEvt, moveEvt, delta);\n\t\t\n\t\t//moveEvt.cancel();\n\t}\n\t\n\tthis.onDragStop = function(dragEvt, selectEvt) {\n\t\tvar id = dragEvt.id;\n\t\tvar dragging = this._isDragging || (this._isDragging = {});\n\t\tif (!dragging[id] || dragEvt.id != selectEvt.id) { return; }\n\t\t\n\t\tdelete dragging[id];\n\t\t--this.dragCount;\n\n\t\tif (!this.dragCount) {\n\t\t\tdragEvt.root.unsubscribe('InputMoveCapture', this, 'onDragStart');\n\t\t\tdragEvt.root.unsubscribe('InputMoveCapture', this, 'onDrag');\n\t\t\tdragEvt.root.unsubscribe('InputSelectCapture', this, 'onDragStop');\n\t\t\tdispatch._isDragging = false;\n\t\t}\n\t\t\n\t\tif (dragEvt.didDrag) {\n\t\t\tvar view = this.view;\n\t\t\t\n\t\t\t// a subscription can later 'uncancel' the selectEvt by setting 'selectEvt.cancelled = false;'\n\t\t\tselectEvt.cancel();\n\t\t\t\n\t\t\tif (view.onDragStop) { view.onDragStop(dragEvt, selectEvt); }\n\t\t\tview.publish('DragStop', dragEvt, selectEvt);\n\t\t}\n\t}\n\t\n\t// ---- end drag\n});\n","pre":true},"../../../../sdk/timestep/animate.js":{"path":"../../../../sdk/timestep/animate.js","friendlyPath":"animate","directory":"../../../../sdk/timestep/","filename":"animate.js","baseMod":"animate","basePath":"../../../../sdk/timestep","src":"/**\n * @module animate\n * Import the DOM/Canvas implementation of animate. Also define the transition function aliases.\n *\n * @doc http://doc.gameclosure.com/api/animate.html\n * @docsrc https://github.com/gameclosure/doc/blob/master/api/animate.md\n */\n\njsio(\"import ui.backend.canvas.animate as exports\");\n","pre":true},"../../../../sdk/timestep/ui/backend/canvas/animate.js":{"path":"../../../../sdk/timestep/ui/backend/canvas/animate.js","friendlyPath":"ui.backend.canvas.animate","directory":"../../../../sdk/timestep/ui/backend/canvas/","filename":"animate.js","src":"/**\n * package ui.backend.canvas.animate;\n *\n * Canvas animate namespace and functions.\n */\n\njsio(\"import event.Emitter as Emitter\");\njsio(\"import animate.transitions as transitions\");\njsio(\"import timer\");\n\nvar anim_uid = 0;\n\nexports = function(subject, groupId) {\n\n\t// TODO: we have a circular import, so do the Engine import on first use\n\tif (typeof Engine == 'undefined') {\n\t\tjsio(\"import ui.Engine as Engine\");\n\t\tjsio(\"import ui.View as View\");\n\t}\n\n\tvar groupId = groupId || 0,\n\t\tgroup = groups[groupId] || (groups[groupId] = new Group()),\n\t\tanimID = subject.__anim_id || (subject.__anim_id = '__anim_' + (++anim_uid)),\n\t\tanim = group.get(animID);\n\n\tif (!anim) {\n\t\tanim = subject instanceof View\n\t\t\t\t? new ViewAnimator(subject, group)\n\t\t\t\t: new Animator(subject, group);\n\n\t\tgroup.add(animID, anim);\n\t}\n\n\treturn anim;\n}\n\nexports.getViewAnimator = function() {\n\treturn ViewAnimator;\n};\n\nexports.setViewAnimator = function(ctor) {\n\tViewAnimator = ctor;\n};\n\nGroup=__class__;var Group=Group(function Group(){return this.init&&this.init.apply(this,arguments)},Emitter, function(supr) {\n\tthis.init = function() {\n\t\tthis._anims = {};\n\t\tthis._pending = [];\n\t};\n\n\tthis.get = function(id) { return this._anims[id]; };\n\n\tthis.add = function(id, q) {\n\t\tthis._anims[id] = q;\n\t\tq.id = id;\n\t\treturn q;\n\t};\n\n\tthis.isActive = function() {\n\t\tfor (var id in this._anims) {\n\t\t\tif (this._anims[id].hasFrames()) { return true; }\n\t\t}\n\n\t\treturn false;\n\t};\n\n\tthis.onAnimationFinish = function(anim) {\n\t\tdelete this._anims[anim.id];\n\n\t\tif (!this.isActive()) {\n\t\t\t// if called from a Finish event, republish it\n\t\t\tthis.publish('Finish');\n\t\t}\n\t};\n});\n\nvar groups = {\n\t0: new Group()\n};\n\nexports.getGroup = function(i) {\n\treturn groups[i || 0];\n};\n\nvar TRANSITIONS = [\n\ttransitions.easeInOut, // 0: default\n\ttransitions.linear,    // 1\n\ttransitions.easeIn,    // 2\n\ttransitions.easeOut,   // 3\n\ttransitions.easeInOut, // 4\n\ttransitions.bounce     // 5\n];\n\nexports.linear = 1;\nexports.easeIn = 2;\nexports.easeOut = 3;\nexports.easeInOut = 4;\nexports.bounce = 5;\n\nfunction getTransition(n) {\n\treturn (typeof n == 'function' ? n : TRANSITIONS[n | 0]);\n}\n\nFrame=__class__;var Frame=Frame(function Frame(){return this.init&&this.init.apply(this,arguments)},function() {\n\tthis.init = function(opts) {\n\t\tthis.subject = opts.subject;\n\t\tthis.target = opts.target;\n\t\tthis.duration = opts.duration || 0;\n\t\tthis.transition = getTransition(opts.transition);\n\t\tthis.onTick = opts.onTick;\n\t};\n\n\tthis.exec = function() {};\n\tthis.onInterrupt = function() {};\n});\n\nCallbackFrame=__class__;var CallbackFrame=CallbackFrame(function CallbackFrame(){return this.init&&this.init.apply(this,arguments)},Frame, function() {\n\tthis.exec = function(tt, t) {\n\t\tthis.target.apply(this.subject, arguments);\n\t};\n});\n\n// a wait frame is just a frame that does nothing... so we\n// don't need to do anything!\nvar WaitFrame = Frame;\n\nObjectFrame=__class__;var ObjectFrame=ObjectFrame(function ObjectFrame(){return this.init&&this.init.apply(this,arguments)},Frame, function() {\n\tthis.exec = function(tt, t, debug) {\n\t\tif (!this.base) {\n\t\t\tthis.base = {};\n\t\t\tfor (var key in this.target) {\n\t\t\t\tthis.base[key] = this.subject[key];\n\t\t\t}\n\t\t}\n\n\t\tfor (var key in this.target) {\n\t\t\tthis.subject[key] = (this.target[key] - this.base[key]) * tt + this.base[key];\n\t\t}\n\n\t\tif (debug) {\n\t\t\tvar changed = {};\n\t\t\tfor (var key in this.target) {\n\t\t\t\tchanged[key] = this.subject[key] + ' -> ' + this.target[key];\n\t\t\t}\n\t\t\tlogger.log(this.duration, tt, JSON.stringify(changed));\n\t\t}\n\t};\n});\n\n// a ViewStyleFrame updates a view's style in exec\nViewStyleFrame=__class__;var ViewStyleFrame=ViewStyleFrame(function ViewStyleFrame(){return this.init&&this.init.apply(this,arguments)},Frame, function() {\n\n\tthis._resolvedDeltas = false;\n\n\tthis.init = function(opts) {\n\t\tthis.subject = opts.subject;\n\t\tthis.target = merge({}, opts.target);\n\t\tthis.duration = opts.duration === 0 ? 0 : (opts.duration || 500);\n\t\tthis.transition = getTransition(opts && opts.transition);\n\t\tthis.onTick = opts.onTick;\n\t};\n\n\tthis.resolveDeltas = function(againstStyle) {\n\t\tvar style = this.target;\n\t\tthis._resolvedDeltas = true;\n\t\tfor (var key in style) {\n\t\t\tvar baseKey = key.substring(1);\n\t\t\tif (key.charAt(0) == 'd' && !(key in againstStyle) && (baseKey in againstStyle)) {\n\t\t\t\tstyle[baseKey] = style[key] + againstStyle[baseKey];\n\t\t\t\tdelete style[key];\n\t\t\t}\n\t\t}\n\t};\n\n\tthis.exec = function(tt, t, debug) {\n\t\tvar oldStyle = this._baseStyle || (this._baseStyle = this.subject.style.copy()),\n\t\t\tnewStyle = this.target;\n\n\t\tif (!this._resolvedDeltas) { this.resolveDeltas(this._baseStyle); }\n\n\t\tvar oldStyle = this._baseStyle;\n\t\tfor (var key in newStyle) {\n\t\t\tif (key in oldStyle) {\n\t\t\t\tthis.subject.style[key] = (newStyle[key] - oldStyle[key]) * tt + oldStyle[key];\n\t\t\t}\n\t\t}\n\n\t\tthis.subject.needsRepaint();\n\n\t\tif (debug) {\n\t\t\tvar changed = {};\n\t\t\tfor (var key in newStyle) {\n\t\t\t\tchanged[key] = this.subject.style[key] + ' -> ' + newStyle[key];\n\t\t\t}\n\t\t\tlogger.log(timer.now, this.duration, tt, JSON.stringify(changed));\n\t\t}\n\t};\n\n\tthis.onInterrupt = function(newFrame) {\n\t\t// var preStyle = this.subject.style.copy();\n\n\t\t// You might want to resolve any deltas against the post-committed style.\n\t\t// But I think this should be off by default.  You can commit the style,\n\t\t// resolve your deltas, then restore the old style yourself if you want.\n\t\t// I don't think you _always_ want this to be the behavior?\n\t\t//\n\t\t// this.commit(true);\n\t\t// newFrame.resolveDeltas(this.subject.style);\n\n\t\t// If you're animating multiple properties, and you've only\n\t\t// interrupted some of them, you may want the rest to continue.\n\t\t// This only looks good if the timing is the same too -- to do\n\t\t// this properly, you'd have to branch animations based on the\n\t\t// style property being animated...\n\t\t//\n\t\t// for (var i in ViewStyle.keys) {\n\t\t// \tif (postCommitStyle[i] != preStyle[i] && !(i in newStyle)) {\n\t\t// \t\tnewStyle[i] = postCommitStyle[i];\n\t\t// \t}\n\t\t// }\n\n\t\t// this.subject.style.update(preStyle);\n\t};\n});\n\nexports.Animator=__class__;var Animator = exports.Animator=exports.Animator(function exports_Animator(){return this.init&&this.init.apply(this,arguments)},Emitter, function() {\n\tthis.init = function(subject, group) {\n\t\tthis.subject = subject;\n\t\tthis._group = group;\n\t\tthis.clear();\n\t\tthis._isPaused = false;\n\t};\n\n\tthis.clear = function() {\n\t\tthis._elapsed = 0;\n\t\tthis._queue = [];\n\t\tthis._unschedule();\n\t\treturn this;\n\t};\n\n\t// this.getQueue = function() { return this._queue; }\n\n\t// Careful: pause will *not* fire the finish event, so anything pending the end of the\n\t// animation will have to wait until the animation is resumed.\n\tthis.pause = function() {\n\t\tif (!this._isPaused) {\n\t\t\tthis._isPaused = true;\n\t\t\tthis._unschedule();\n\t\t}\n\t};\n\n\tthis.resume = function() {\n\t\tif (this._isPaused) {\n\t\t\tthis._isPaused = false;\n\t\t\tthis._schedule();\n\t\t}\n\t};\n\n\tthis._schedule = function() {\n\t\tif (!this._isScheduled) {\n\t\t\tthis._isScheduled = true;\n\t\t\tEngine.get().subscribe('Tick', this, 'onTick');\n\t\t}\n\t};\n\n\tthis._unschedule = function() {\n\t\tif (this._isScheduled) {\n\t\t\tthis._isScheduled = false;\n\t\t\tEngine.get().unsubscribe('Tick', this, 'onTick');\n\t\t}\n\t};\n\n\tthis.isPaused = function() { return this._isPaused; };\n\tthis.hasFrames = function() { return !!this._queue[0]; };\n\n\tthis.wait = function(duration) {\n\t\treturn this.then(new WaitFrame({duration: duration}));\n\t};\n\n\tthis.buildFrame = function(opts) {\n\t\tif (typeof opts.target == 'function') {\n\t\t\treturn new CallbackFrame(opts);\n\t\t}\n\n\t\tif (typeof opts.target == 'object') {\n\t\t\treturn new ObjectFrame(opts);\n\t\t}\n\n\t\treturn new WaitFrame(opts);\n\t};\n\n\tthis.now = function(target, duration, transition, onTick) {\n\t\ttransition = transition || (this._queue[0] ? exports.easeOut : exports.easeInOut);\n\n\t\tvar nextFrame = target instanceof Frame\n\t\t\t\t? target\n\t\t\t\t: this.buildFrame({\n\t\t\t\t\t\tsubject: this.subject,\n\t\t\t\t\t\ttarget: target,\n\t\t\t\t\t\tduration: duration,\n\t\t\t\t\t\ttransition: transition,\n\t\t\t\t\t\tonTick: onTick\n\t\t\t\t\t});\n\n\t\tvar frame = this._queue[0];\n\t\tframe && frame.onInterrupt(nextFrame);\n\n\t\tthis.clear();\n\t\treturn this.then(nextFrame);\n\t};\n\n\tthis.then = function(target, duration, transition, onTick) {\n\t\tvar nextFrame = target instanceof Frame\n\t\t\t\t? target\n\t\t\t\t: this.buildFrame({\n\t\t\t\t\t\tsubject: this.subject,\n\t\t\t\t\t\ttarget: target,\n\t\t\t\t\t\tduration: duration,\n\t\t\t\t\t\ttransition: transition,\n\t\t\t\t\t\tonTick: onTick\n\t\t\t\t\t});\n\n\t\tthis._queue.push(nextFrame);\n\t\tthis._schedule();\n\t\treturn this;\n\t};\n\n\tthis.debug = function() { this._debug = true; return this; };\n\n\tthis.commit = function() {\n\t\tthis._elapsed = 0;\n\t\tfor (var i = 0, p; p = this._queue[i]; ++i) {\n\t\t\tthis._elapsed += p.duration;\n\t\t}\n\n\t\tthis.next();\n\t\treturn this;\n\t};\n\n\tthis.onTick = function(dt) {\n\t\tthis._elapsed += dt;\n\t\tthis.next();\n\n\t\tif (!this._isScheduled) {\n\t\t\tthis._group.onAnimationFinish(this);\n\t\t}\n\t};\n\n\tthis.next = function() {\n\t\tvar p,\n\t\t\ttarget;\n\n\t\tif (!this._queue[0]) { return; }\n\n\t\twhile ((p = this._queue[0])) {\n\t\t\tvar frameFinished = this._elapsed >= p.duration,\n\t\t\t\tt = frameFinished ? 1 : this._elapsed / p.duration,\n\t\t\t\ttt = p.transition(t);\n\n\t\t\tif (frameFinished) {\n\t\t\t\tthis._elapsed -= p.duration;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tp.exec(tt, t, this._debug);\n\t\t\t\tif (p.onTick) { p.onTick.call(p.subject, tt, t); }\n\t\t\t} finally {\n\t\t\t\t// if we haven't modified the queue in a callback, remove the frame if it is finished\n\t\t\t\tif (frameFinished && p == this._queue[0]) {\n\t\t\t\t\tthis._queue.shift();\n\t\t\t\t}\n\n\t\t\t\t// if we got paused during a callback or the\n\t\t\t\t// frame is not finished yet, don't continue\n\t\t\t\tif (!frameFinished || this._isPaused) { return; }\n\t\t\t}\n\t\t}\n\n\t\t// nothing left in the queue!\n\t\tthis._unschedule();\n\t};\n});\n\nViewAnimator=__class__;var ViewAnimator=ViewAnimator(function ViewAnimator(){return this.init&&this.init.apply(this,arguments)},Animator, function(supr) {\n\tthis.buildFrame = function(opts) {\n\t\tif (typeof opts.target == 'object') {\n\t\t\treturn new ViewStyleFrame(opts);\n\t\t}\n\n\t\treturn supr(this, 'buildFrame', arguments);\n\t};\n});\n","pre":true},"../../../../sdk/timestep/animate/transitions.js":{"path":"../../../../sdk/timestep/animate/transitions.js","friendlyPath":"animate.transitions","directory":"../../../../sdk/timestep/animate/","filename":"transitions.js","src":"/**\n * @module animate.transitions\n *\n * Transition functions for use by the animate features. These aren't referenced\n * directly by the animate namespace, but by numerical reference.\n *\n * @doc http://doc.gameclosure.com/api/animate.html\n * @docsrc https://github.com/gameclosure/doc/blob/master/api/animate.md\n */\n\nexports.linear = function (n) { return n; }\nexports.easeIn = function (n) { return n * n; }\nexports.easeInOut = function (n) { return (n *= 2) < 1 ? 0.5 * n * n * n : 0.5 * ((n -= 2) * n * n + 2); }\nexports.easeOut = function(n) { return n * (2 - n); }\n","pre":true},"../../../../sdk/timestep/ui/layout/Padding.js":{"path":"../../../../sdk/timestep/ui/layout/Padding.js","friendlyPath":"ui.layout.Padding","directory":"../../../../sdk/timestep/ui/layout/","filename":"Padding.js","src":"/**\n * package ui.layout.Padding;\n *\n * A simple class to express padding views. Used by LinearLayout, LinearView.\n */\n\nvar sdk_timestep_ui_layout_Padding=__class__;exports=sdk_timestep_ui_layout_Padding(function sdk_timestep_ui_layout_Padding(){return this.init&&this.init.apply(this,arguments)},function () {\n\tthis.init =\n\tthis.update = function (args) {\n\t\tif (typeof args == 'string') {\n\t\t\targs = args.split(/\\s+/).map(function (piece) { return parseFloat(piece); });\n\t\t}\n\n\t\tif (!args || !args.length) { args = [args || 0]; }\n\n\t\tswitch (args.length) {\n\t\t\tcase 1:\n\t\t\t\tthis.left = this.right = this.top = this.bottom = args[0];\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tthis.top = this.bottom = args[0];\n\t\t\t\tthis.left = this.right = args[1];\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tthis.top = args[0];\n\t\t\t\tthis.left = this.right = args[1];\n\t\t\t\tthis.bottom = args[2];\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tthis.top = args[0];\n\t\t\t\tthis.right = args[1];\n\t\t\t\tthis.bottom = args[2];\n\t\t\t\tthis.left = args[3];\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tthis.getVertical = function () { return this.top + this.bottom; }\n\tthis.getHorizontal = function () { return this.left + this.right; }\n\n\tthis.toString = function () { return [this.top, this.right, this.bottom, this.left].join(' '); }\n});","pre":true},"../../../../sdk/timestep/ui/layout/LinearLayout.js":{"path":"../../../../sdk/timestep/ui/layout/LinearLayout.js","friendlyPath":"ui.layout.LinearLayout","directory":"../../../../sdk/timestep/ui/layout/","filename":"LinearLayout.js","src":"/**\n * package ui.layout.LinearLayout;\n *\n * A class to direct the layout of its parent view, set through opts.parent.\n */\n\njsio(\"import ui.layout.Padding as Padding\");\n\njsio(\"import .BoxLayout\");\n\nvar DEBUG = false;\n\n// TODO: native\n// TODO: Resize event on width/height change\n// TODO: reflow on subview visibility change\n\nvar sdk_timestep_ui_layout_LinearLayout=__class__;exports=sdk_timestep_ui_layout_LinearLayout(function sdk_timestep_ui_layout_LinearLayout(){return this.init&&this.init.apply(this,arguments)},BoxLayout, function (supr) {\n\n\t// set to true to tell other layouts not to try to control the child layout\n\tthis.reflowsChildren = true;\n\n\tthis.init = function(opts) {\n\t\tthis._view = opts.view;\n\t\tthis._view.subscribe('SubviewAdded', this, '_onSubviewAdded');\n\t\tthis._view.subscribe('SubviewRemoved', this, '_onSubviewRemoved');\n\n\t\tthis.setDirection(opts.isVertical ? 'vertical' : 'horizontal');\n\n\t\tthis._views = [];\n\t\tvar subviews = this._view.getSubviews();\n\t\tfor (var i = 0, view; view = subviews[i]; ++i) {\n\t\t\tif (view.style.inLayout) {\n\t\t\t\tthis._views.push(this._initLayoutView(view));\n\t\t\t}\n\t\t}\n\n\t\tthis._forwardEvents();\n\n\t\tthis._debug = DEBUG;\n\t}\n\n\tthis._onSubviewRemoved = function (view) {\n\t\tif (view.style.inLayout) {\n\t\t\tthis.remove(view);\n\t\t}\n\t}\n\n\tthis._onSubviewAdded = function (view) {\n\t\tif (view.style.inLayout) {\n\t\t\tthis.add(view);\n\t\t}\n\t}\n\n\tthis.debug = function () { this._debug = true; return this; }\n\n\t/**\n\t * Set which language to use, for horizontal or vertical layout.\n\t * @param String direction One of \"horizontal\" or \"vertical\".\n\t */\n\n\tthis.setDirection = function (direction) {\n\t\tthis._direction = direction;\n\n\t\tvar isVertical = direction == 'vertical';\n\t\tthis._propPos = isVertical ? 'y' : 'x';\n\t\tthis._propPosOpp = isVertical ? 'x' : 'y';\n\t\tthis._propDim = isVertical ? 'height' : 'width';\n\t\tthis._minPropDim = isVertical ? 'minHeight' : 'minWidth';\n\t\tthis._maxPropDim = isVertical ? 'maxHeight' : 'maxWidth';\n\t\tthis._propDimOpp = isVertical ? 'width' : 'height';\n\t\tthis._propSideA = isVertical ? 'top' : 'left';\n\t\tthis._propSideB = isVertical ? 'bottom' : 'right';\n\n\t\tthis._flexProp = isVertical ? 'vflex' : 'hflex';\n\n\t\tthis._view.needsReflow();\n\t\treturn this;\n\t}\n\n\tthis.getDirection = function () { return this._direction; }\n\n\t/**\n\t * Events to proxy to the parent view from this layout.\n\t */\n\tthis._events = ['ViewWillAppear', 'ViewDidAppear', 'ViewWillDisappear', 'ViewDidDisappear'];\n\n\tthis._forwardEvents = function() {\n\t\tfor (var i = 0, a; a = this._events[i]; ++i) {\n\t\t\tthis._view.subscribe(a, this, '_forwardSignal', a);\n\t\t}\n\t};\n\n\tthis._events = ['ViewWillAppear', 'ViewDidAppear', 'ViewWillDisappear', 'ViewDidDisappear'];\n\n\t/**\n\t * Emit events on the children. Variable arguments.\n\t */\n\n\tthis._forwardSignal = function () {\n\t\tfor (var i = 0, v; v = this._views[i]; ++i) {\n\t\t\tv.view.publish.apply(v.view, arguments);\n\t\t}\n\t};\n\n\t/**\n\t * Initialize a subview controlled by this layout.\n\t */\n\n\tthis._initLayoutView = function(view) {\n\t\tview.style.inLayout = true;\n\n\t\tthis._debug && logger.log(this._view.uid, 'adding view', view.uid, this._propDim, view.style[this._propDim]);\n\n\t\tthis._view.connectEvent(view, 'Resize', bind(this, 'reflow'));\n\n\t\treturn {\n\t\t\tview: view,\n\t\t\tindex: 0,\n\t\t\ttoString: toStringSort\n\t\t};\n\t};\n\n\tfunction toStringSort () {\n\t\treturn this.view.style._sortOrder + this.index;\n\t}\n\n\t/**\n\t * Return the size of this element (in its cardinal direction).\n\t */\n\n\tthis.getSize = function () {\n\t\treturn this._size;\n\t};\n\n\t/**\n\t * Return the index of a subview.\n\t */\n\n\tthis.getViewIndex = function (view) {\n\t\tfor (var i = 0, d; d = this._views[i]; ++i) {\n\t\t\tif (d.view == view) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t};\n\n\t/**\n\t * Add an array of subviews to this element in batch (prevent reflow each\n\t * time).\n\t */\n\n\tthis.addSubviews = function (views) {\n\t\tthis._debug && logger.log(this._view.uid, \"adding\", views.length, \"views\");\n\t\tif (isArray(views)) {\n\t\t\tfor (var i = 0, n = views.length; i < n; ++i) {\n\t\t\t\tvar view = views[i];\n\t\t\t\tif (view) {\n\t\t\t\t\tthis._views.push(this._initLayoutView(view));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._view.needsReflow();\n\t\t} else {\n\t\t\tthis.insertBefore(views);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Return the list of subviews controlled by this layout.\n\t */\n\n\tthis.getSubviews = function () {\n\t\treturn this._views.map(function (v) { return v.view; });\n\t};\n\n\t/**\n\t * Remove a subview controlled by this layout.\n\t */\n\n\tthis.remove = function (view) {\n\t\tvar i = this.getViewIndex(view);\n\t\tif (i != -1) {\n\t\t\tthis._views.splice(i, 1);\n\t\t\tthis._view.disconnectEvent(view, 'Resize');\n\t\t\tthis._view.needsReflow();\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/**\n\t * Insert a subview before another subview in this hierarchy.\n\t */\n\n\tthis.add =\n\tthis.insertBefore = function (view, before) {\n\n\t\tif (this.getViewIndex(view) != -1) { return; }\n\n\t\tvar item = this._initLayoutView(view);\n\t\tvar added = false;\n\t\tif (before) {\n\t\t\tvar i = this.getViewIndex(before);\n\t\t\tif (i != -1) {\n\t\t\t\tthis._views.splice(i, 0, item);\n\t\t\t\tadded = true;\n\t\t\t}\n\t\t}\n\n\t\tif (!added) {\n\t\t\tthis._views.push(item);\n\t\t}\n\n\t\tthis._view.needsReflow();\n\t}\n\n\t/**\n\t * Insert a subview after another subview in this hierarchy.\n\t */\n\n\tthis.insertAfter = function (view, after) {\n\n\t\tif (this.getViewIndex(view) != -1) { return; }\n\n\t\tvar item = this._initLayoutView(view);\n\t\tvar added = false;\n\t\tif (after) {\n\t\t\tvar i = this.getViewIndex(after);\n\t\t\tif (i != -1) {\n\t\t\t\tthis._views.splice(i + 1, 0, item);\n\t\t\t\tadded = true;\n\t\t\t}\n\t\t}\n\n\t\tif (!added) {\n\t\t\tthis._views.unshift(item);\n\t\t}\n\n\t\tthis._view.needsReflow();\n\t}\n\n\t/**\n\t * Reflow logic.\n\t */\n\n\tthis.reflow = function () {\n\t\tsupr(this, 'reflow', arguments);\n\n\t\t// style.order is first, then default to standard view sort order\n\t\tvar n = 0;\n\t\tfor (var i = 0, v; v = this._views[i]; ++i) {\n\t\t\tif (v.view.style.visible) {\n\t\t\t\t// TODO: this won't work on native\n\t\t\t\tv.index = v.view.style.__sortKey;\n\n\t\t\t\t++n;\n\t\t\t}\n\t\t}\n\n\t\tif (!n) { return; }\n\n\t\tthis._views.sort();\n\n\t\tif (DEBUG) {\n\t\t\tvar uid = this._view.uid;\n\t\t\t// _debug.views[uid] = +new Date();\n\t\t}\n\n\t\tvar layoutStyle = this._view.style;\n\t\tif (layoutStyle.direction != this._direction) {\n\t\t\tthis.setDirection(layoutStyle.direction);\n\t\t}\n\n\t\tvar scale = this._view.getPosition().scale;\n\n\t\tvar isVertical = this._direction == 'vertical';\n\t\tvar propDim = this._propDim;\n\t\tvar propDimOpp = this._propDimOpp;\n\t\tvar minPropDim = this._minPropDim;\n\t\tvar propA = this._propSideA;\n\t\tvar propB = this._propSideB;\n\t\tvar padding = layoutStyle.padding;\n\t\tvar paddingSum = padding && (isVertical ? padding.getVertical() : padding.getHorizontal()) || 0;\n\t\tvar parentDim = layoutStyle[propDim];\n\t\tvar views = this._views;\n\n\t\tthis._debug && logger.log('reflow() view', uid + ':', views.length, 'subview(s)');\n\n\t\t// compute the total size of the fixed views and count\n\t\t// how many dynamically sized views we have\n\t\tvar sum = 0;\n\t\tvar flexSum = 0;\n\t\tvar paddingOpp = padding && (isVertical ? padding.getHorizontal() : padding.getVertical()) || 0;\n\t\tfor (var i = 0, v; v = views[i]; ++i) {\n\t\t\tvar s = v.view.style;\n\t\t\tif (!s.visible) { continue; }\n\n\t\t\tv.margins = (s[propA] || 0) + (s[propB] || 0);\n\n\t\t\tif (s.flex) {\n\t\t\t\tflexSum += s.flex;\n\t\t\t\tv.baseSize = s[minPropDim] || 0;\n\t\t\t\tsum += v.baseSize;\n\t\t\t} else {\n\t\t\t\tsum += (s[propDim] || 0) * s.scale + v.margins;\n\t\t\t}\n\n\t\t\t// LinearViews should reflow the opposite direction\n\t\t\tif (padding) {\n\t\t\t\ts.x = padding.left;\n\t\t\t\ts.y = padding.top;\n\t\t\t}\n\n//\t\t\tif (v.view.style.layout == 'box') {\n\t\t\t\tBoxLayout.reflowX(v.view, layoutStyle.width, padding);\n\t\t\t\tBoxLayout.reflowY(v.view, layoutStyle.height, padding);\n//\t\t\t}\n\t\t}\n\n\t\tif (flexSum && parentDim == undefined) { return; }\n\n\t\t// compute available space\n\t\tvar availableSpace = parentDim - paddingSum;\n\t\tif (availableSpace < 0) { return; }\n\n\t\t// if there's a flex subview or (?), the total size is the availableSpace\n\t\t// otherwise the totalSize is the sum of the subview sizes\n\t\tvar justifyContent = layoutStyle.justifyContent;\n\t\tvar totalSize = (flexSum || justifyContent != 'start' ? availableSpace : sum) + paddingSum;\n\t\tvar flexSize = availableSpace - sum;\n\n\t\t//\n\t\tvar layoutDim = isVertical ? 'layoutHeight' : 'layoutWidth';\n\t\tif (!flexSum && layoutStyle[layoutDim] == 'wrapContent') {\n\t\t\tthis._debug && logger.log('  view', uid, '(sizing to fit)', propDim, '=', totalSize + 'px', '(' + paddingSum + 'px padding)');\n\t\t\tlayoutStyle[propDim] = totalSize;\n\t\t}\n\n\t\t// compute the space for each flexible view\n\t\tvar flexUsed = 0;\n\t\tvar balance = 0;\n\t\tfor (var i = 0, v; v = views[i]; ++i) {\n\t\t\tvar s = v.view.style;\n\t\t\tif (!s.visible) { continue; }\n\n\t\t\tif (s.flex) {\n\t\t\t\t// compute the ideal space for the flex view\n\t\t\t\tvar idealSpace = v.baseSize + flexSize * (s.flex / flexSum) / s.scale + balance;\n\n\t\t\t\t// round to the nearest screen pixel (take into account the global scale of the layout view)\n\t\t\t\tvar roundedSpace = Math.round(idealSpace / scale) * scale;\n\n\t\t\t\t// propogate the balance into the next view space computation\n\t\t\t\tbalance = idealSpace - roundedSpace;\n\n\t\t\t\t// store the actual space for the view, which is the computed space minus the margins\n\t\t\t\tv.dim = roundedSpace - v.margins;\n\n\t\t\t\t// account for maximal bound\n\t\t\t\tif (v.dim > s[this._maxPropDim]) {\n\t\t\t\t\tv.dim = s[this._maxPropDim];\n\t\t\t\t}\n\n\t\t\t\t// keep track of used flex space\n\t\t\t\tflexUsed += roundedSpace;\n\t\t\t}\n\t\t}\n\n\t\tvar flexRemaining = flexSize - flexUsed;\n\n\t\t// set the position of the views\n\t\tvar pos = padding && padding[propA] || 0;\n\t\tvar gap = 0;\n\t\tif (flexRemaining > 0) {\n\t\t\t// there's unused space, so justify our views\n\t\t\tswitch (justifyContent) {\n\t\t\t\tcase 'end':\n\t\t\t\t\tpos += flexRemaining;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'center':\n\t\t\t\t\tpos += flexRemaining / 2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'space':\n\t\t\t\t\tgap = flexRemaining / (n - 1) || 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'space-outside':\n\t\t\t\t\tgap = flexRemaining / (n + 1) || 0;\n\t\t\t\t\tpos += gap;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'start':\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// position and size views!\n\t\tvar propPos = this._propPos;\n\t\tfor (var i = 0, v; v = views[i]; ++i) {\n\t\t\tvar s = v.view.style;\n\t\t\tif (!s.visible) { continue; }\n\n\t\t\t// set position\n\t\t\ts[propPos] = pos + (s[propA] || 0);\n\n\t\t\tthis._debug && logger.log('  view', uid, 'layout subview', v.view.uid, propPos, '=', s[propPos]);\n\n\t\t\tif (s.flex) {\n\t\t\t\t// set width\n\t\t\t\ts[propDim] = v.dim;\n\n\t\t\t\tthis._debug && logger.log('  view', uid, 'layout subview', v.view.uid, propDim, '=', s[propDim]);\n\t\t\t}\n\n\t\t\t// advance position\n\t\t\tpos += gap + (s[propDim] || 0) * s.scale + v.margins;\n\t\t}\n\n\t\tif (this._size != totalSize) {\n\t\t\tthis._size = totalSize;\n\t\t\tthis._view.publish('LayoutResize', totalSize);\n\t\t}\n\t};\n});\n\n","pre":true},"../../../../sdk/timestep/ui/layout/BoxLayout.js":{"path":"../../../../sdk/timestep/ui/layout/BoxLayout.js","friendlyPath":".BoxLayout","directory":"../../../../sdk/timestep/ui/layout/","filename":"BoxLayout.js","src":"var sdk_timestep_ui_layout_BoxLayout=__class__;var BoxLayout = exports=sdk_timestep_ui_layout_BoxLayout(function sdk_timestep_ui_layout_BoxLayout(){return this.init&&this.init.apply(this,arguments)},function () {\n\n\tvar cls = this.constructor;\n\n\tthis.reflowsChildren = false;\n\n\tthis.init = function (opts) {\n\t\tthis._view = opts.view;\n\n\t\tcls.initParentListener(opts.view);\n\t}\n\n\tthis.reflow = function (force) {\n\t\tvar view = this._view;\n\t\tvar sv = view.getSuperview();\n\t\tvar style = view.style;\n\n\t\tif (sv && (force || !style.inLayout || !sv.style.layout || !sv.__layout.reflowsChildren)) {\n\t\t\tcls.reflowX(view, sv.style.width);\n\t\t\tcls.reflowY(view, sv.style.height);\n\t\t}\n\n\n\t}\n\n\tcls.addParentListener = function (view) {\n\t\tif (view.style.__removeSuperviewResize) {\n\t\t\tview.style.__removeSuperviewResize();\n\t\t}\n\n\t\t// reflow on parent view resize\n\t\tvar onResize = bind(view, 'needsReflow');\n\t\tvar superview = view.getSuperview();\n\t\tsuperview.on('Resize', onResize);\n\n\t\t// store a closure to unsubscribe this event\n\t\tview.style.__removeSuperviewResize = bind(view.style, function () {\n\t\t\tthis.__removeSuperviewResize = null;\n\t\t\tsuperview.removeListener('Resize', onResize);\n\t\t});\n\t}\n\n\tcls.initParentListener = function (view) {\n\t\tif (view.__root) { this.addParentListener(view); }\n\n\t\tview.on('ViewAdded', bind(this, 'addParentListener', view));\n\t\tview.on('ViewRemoved', bind(view.style, function () {\n\t\t\tthis.__removeSuperviewResize && this.__removeSuperviewResize();\n\t\t}));\n\t}\n\n\tvar isPercent = /%$/;\n\tcls.reflowX = function (view, svWidth, padding) {\n\t\tif (!svWidth) { return; }\n\n\t\tvar s = view.style;\n\t\tvar availWidth = (svWidth - (padding && padding.getHorizontal() || 0));\n\n\t\t// compute the width\n\t\tvar w = 0;\n\t\tif (s.layoutWidth == 'wrapContent') {\n\t\t\t// find the maximal right edge\n\t\t\tvar views = view.getSubviews();\n\t\t\tfor (var i = 0, v; v = views[i]; ++i) {\n\t\t\t\tvar right = v.style.x + v.style.width * v.style.scale;\n\t\t\t\tif (right > w) {\n\t\t\t\t\tw = right;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tw = s.right != undefined && s.left != undefined ? availWidth / s.scale - (s.left || 0) - (s.right || 0)\n\t\t\t\t: isPercent.test(s.layoutWidth) ? availWidth / s.scale * parseFloat(s.layoutWidth) / 100\n\t\t\t\t: s.aspectRatio ? s.height * s.aspectRatio\n\t\t\t\t: s.width || availWidth / s.scale;\n\t\t}\n\n\t\tif (s.centerX) { s.x = (availWidth - s.scale * w) / 2 + (padding && padding.left || 0); }\n\t\tif (s.left == undefined && s.right != undefined) { s.x = availWidth - s.scale * w - s.right - (padding && padding.right || 0); }\n\t\tif (s.left != undefined) { s.x = s.left + (padding && padding.left || 0); }\n\n\t\ts.width = w;\n\t}\n\n\tcls.reflowY = function (view, svHeight, padding) {\n\t\tif (!svHeight) { return; }\n\n\t\tvar s = view.style;\n\t\tvar availHeight = (svHeight - (padding && padding.getVertical() || 0));\n\n\t\t// compute the height\n\t\tvar h = 0;\n\t\tif (s.layoutHeight == 'wrapContent') {\n\t\t\t// find the maximal right edge\n\t\t\tvar views = view.getSubviews();\n\t\t\tfor (var i = 0, v; v = views[i]; ++i) {\n\t\t\t\tvar bottom = v.style.y + v.style.height * v.style.scale;\n\t\t\t\tif (bottom > h) {\n\t\t\t\t\th = bottom;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\th = s.top != undefined && s.bottom != undefined ? availHeight / s.scale - (s.top || 0) - (s.bottom || 0)\n\t\t\t\t: isPercent.test(s.layoutHeight) ? availHeight / s.scale * parseFloat(s.layoutHeight) / 100\n\t\t\t\t: s.aspectRatio ? s.width / s.aspectRatio\n\t\t\t\t: s.height || availHeight / s.scale;\n\t\t}\n\n\t\tif (s.centerY) { s.y = (availHeight - s.scale * h) / 2 + (padding && padding.top || 0); }\n\t\tif (s.top == undefined && s.bottom != undefined) { s.y = availHeight - s.scale * h - s.bottom - (padding && padding.bottom || 0); }\n\t\tif (s.top != undefined) { s.y = s.top + (padding && padding.top || 0); }\n\n\t\ts.height = h;\n\t}\n});\n\n\n","pre":true},"../../../../sdk/timestep/ui/backend/debug/FPSView.js":{"path":"../../../../sdk/timestep/ui/backend/debug/FPSView.js","friendlyPath":"ui.backend.debug.FPSView","directory":"../../../../sdk/timestep/ui/backend/debug/","filename":"FPSView.js","src":"/**\n * @package ui.backend.debug.FPSView;\n *\n * The view which renders the FPS when showFPS is set to true on the\n * Application options.\n *\n * TODO Move to debug package.\n */\n\njsio(\"import device\");\njsio(\"import lib.Enum as Enum\");\n\njsio(\"import math.geom.Rect as Rect\");\njsio(\"import math.geom.intersect as intersect\");\n\njsio(\"import event.input.dispatch as dispatch\");\n\nvar viewModes = new Enum('FPS', 'DT');\n\nfunction strokeRect(ctx, rect, color) {\n\tctx.fillStyle = color;\n\tctx.fillRect(rect.x, rect.y, 1, rect.height);\n\tctx.fillRect(rect.x, rect.y, rect.width, 1);\n\tctx.fillRect(rect.x + rect.width - 1, rect.y, 1, rect.height);\n\tctx.fillRect(rect.x, rect.y + rect.height - 1, rect.width, 1);\n};\n\nfunction fillRect(ctx, rect, color) {\n\tctx.fillStyle = color;\n\tctx.fillRect(rect.x, rect.y, rect.width, rect.height);\n};\n\nGraph=__class__;var Graph=Graph(function Graph(){return this.init&&this.init.apply(this,arguments)},function() {\n\tthis.init = function(opts) {\n\t\tvar Canvas = device.get('Canvas');\n\n\t\tthis._width = opts.width;\n\t\tthis._height = opts.height;\n\n\t\tthis._maxValue = opts.maxValue;\n\t\tthis._backgroundColor = opts.backgroundColor;\n\t\tthis._colors = opts.colors;\n\t\tthis._axisColor = opts.axisColor;\n\n\t\tthis._canvas = new Canvas({width: opts.width, height: opts.height});\n\t\tthis._ctx = this._canvas.getContext('2d');\n\t\tthis._ctx.fillStyle = opts.backgroundColor;\n\t\tthis._ctx.fillRect(0, 0, opts.width, opts.height);\n\n\t\tthis._offset = 0;\n\t\tthis._index = 0;\n\t};\n\n\tthis.addValues = function(values, timeAxis) {\n\t\tvar ctx = this._ctx,\n\t\t\twidth = this._width,\n\t\t\theight = this._height,\n\t\t\tvalue,\n\t\t\tmaxValue = this._maxValue,\n\t\t\tx = (this._offset + this._index) % width,\n\t\t\ty = this._height,\n\t\t\tn,\n\t\t\ti, j;\n\n\t\tctx.fillStyle = this._backgroundColor;\n\t\tctx.fillRect(x, 0, 2, height);\n\n\t\ti = values.length;\n\t\twhile (i) {\n\t\t\tvalue = values[--i];\n\t\t\tif (value > maxValue) {\n\t\t\t\tvalue = maxValue;\n\t\t\t}\n\t\t\tn = ~~(value / maxValue *  height);\n\t\t\tctx.fillStyle = this._colors[i];\n\t\t\tctx.fillRect(x, height - n, 2, n);\n\t\t}\n\n\t\tctx.fillStyle = this._axisColor;\n\t\tif (timeAxis) {\n\t\t\tctx.fillRect(x, 0, 1, height);\n\t\t}\n\t\tctx.fillRect(x, 25, 2, 1);\n\t\tctx.fillRect(x, 50, 2, 1);\n\t\tctx.fillRect(x, 75, 2, 1);\n\n\t\tif (this._index < width) {\n\t\t\tthis._index += 2;\n\t\t} else {\n\t\t\tthis._offset += 2;\n\t\t\tif (this._offset >= width) {\n\t\t\t\tthis._offset = 0;\n\t\t\t}\n\t\t}\n\t};\n\n\tthis.render = function(ctx, x, y) {\n\t\tvar offset = this._offset,\n\t\t\twidth = this._width,\n\t\t\theight = this._height;\n\n\t\tif (offset === 0) {\n\t\t\tctx.drawImage(this._canvas, 0, 0, width, height, x, y, width, height);\n\t\t} else {\n\t\t\tctx.drawImage(this._canvas, offset, 0, width - offset, height, x, y, width - offset, height);\n\t\t\tctx.drawImage(this._canvas, 0, 0, offset, height, width - offset + x, y, offset, height);\n\t\t}\n\t};\n});\n\nvar sdk_timestep_ui_backend_debug_FPSView=__class__;exports=sdk_timestep_ui_backend_debug_FPSView(function sdk_timestep_ui_backend_debug_FPSView(){return this.init&&this.init.apply(this,arguments)},function() {\n\tthis.init = function(opts) {\n\t\tthis._application = opts.application;\n\n\t\tthis._time = +(new Date()) + 1000;\n\t\tthis._frames = 0;\n\t\tthis._fps = 20;\n\t\tthis._dt = 10;\n\n\t\tthis._minimized = true;\n\n\t\tvar width = 200,\n\t\t\theight = 100;\n\n\t\tthis._rectTop = new Rect(1, 1, width, 16);\n\t\tthis._rectMin = new Rect(0, 0, 24, 15);\n\t\tthis._rectMax = new Rect(0, 0, width + 2, height + 17);\n\t\tthis._rect = this._rectMin;\n\n\t\tthis._rectFPS = new Rect(141, 1, 30, 15);\n\t\tthis._rectDT = new Rect(171, 1, 30, 15);\n\n\t\tthis._borderColor = 'rgb(100,100,150)';\n\t\tthis._backgroundColor = '#17182E';\n\t\tthis._textColor = '#FFFFFF';\n\n\t\tthis._viewMode = viewModes.DT;\n\n\t\tthis._graphs = {}\n\t\tthis._graphs[viewModes.FPS] = new Graph({\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\tmaxValue: 60,\n\t\t\tbackgroundColor: this._backgroundColor,\n\t\t\tcolors: ['rgba(170,170,252,0.3)', 'rgb(170,170,252)'],\n\t\t\taxisColor: '#FFFFFF'\n\t\t});\n\t\tthis._graphs[viewModes.DT] = new Graph({\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\tmaxValue: 66,\n\t\t\tbackgroundColor: this._backgroundColor,\n\t\t\tcolors: ['rgba(255,0,0,0.5)', 'rgb(254,255,170)'],\n\t\t\taxisColor: '#FFFFFF'\n\t\t});\n\t};\n\n\tthis.tick = function(dt) {\n\t\tvar time = +(new Date());\n\t\tif (time > this._time) {\n\t\t\tthis._time = time + 1000;\n\t\t\tthis._fps = this._frames;\n\t\t\tthis._frames = 1;\n\t\t} else {\n\t\t\tthis._frames++;\n\t\t}\n\n\t\tvar events = this._application.getEvents();\n\t\tif (events.length) {\n\t\t\tthis._handleEvents(events);\n\t\t}\n\n\t\tthis._dt = this._dt * 0.8 + dt * 0.2;\n\n\t\tif (!this._minimized) {\n\t\t\tswitch (this._viewMode) {\n\t\t\t\tcase viewModes.DT:\n\t\t\t\t\tthis._graphs[viewModes.DT].addValues([this._dt, dt], (this._frames === 1));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase viewModes.FPS:\n\t\t\t\t\tthis._graphs[viewModes.FPS].addValues([this._fps, 1000 / dt], (this._frames === 1));\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t};\n\n\tthis._handleEvents = function(events) {\n\t\tvar types = dispatch.eventTypes;\n\t\tvar i = events.length;\n\n\t\twhile (i) {\n\t\t\tvar event = events[--i];\n\t\t\tswitch (event.type) {\n\t\t\t\tcase types.START:\n\t\t\t\t\tif (intersect.ptAndRect(event.srcPt, this._rect)) {\n\t\t\t\t\t\tif (this._minimized) {\n\t\t\t\t\t\t\tthis._minimized = false;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (intersect.ptAndRect(event.srcPt, this._rectFPS)) {\n\t\t\t\t\t\t\t\tthis._viewMode = viewModes.FPS;\n\t\t\t\t\t\t\t} else if (intersect.ptAndRect(event.srcPt, this._rectDT)) {\n\t\t\t\t\t\t\t\tthis._viewMode = viewModes.DT;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis._minimized = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis._rect = this._minimized ? this._rectMin : this._rectMax;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t};\n\n\tthis.render = function(ctx) {\n\t\tctx.save();\n\n\t\tctx.textBaseline = 'top';\n\t\tctx.textAlign = 'center';\n\t\tctx.font = '12px Verdana';\n\n\t\tif (this._minimized) {\n\t\t\tfillRect(ctx, this._rect, this._backgroundColor);\n\t\t} else {\n\t\t\tfillRect(ctx, this._rectTop, this._backgroundColor);\n\t\t\tthis._graphs[this._viewMode].render(ctx, 1, 17);\n\t\t\tctx.fillStyle = this._borderColor;\n\t\t\tctx.fillRect(0, 16, this._rect.width, 1);\n\n\t\t\tvar fpsMode = (this._viewMode === viewModes.FPS),\n\t\t\t\tdtMode = (this._viewMode === viewModes.DT);\n\n\t\t\tfillRect(ctx, this._rectFPS, fpsMode ? this._borderColor : this._backgroundColor);\n\t\t\tctx.fillStyle = fpsMode ? this._textColor : this._borderColor;\n\t\t\tctx.fillText('FPS', this._rectFPS.x + this._rectFPS.width / 2, 0);\n\n\t\t\tfillRect(ctx, this._rectDT, dtMode ? this._borderColor : this._backgroundColor);\n\t\t\tctx.fillStyle = dtMode ? this._textColor : this._borderColor;\n\t\t\tctx.fillText('DT', this._rectDT.x + this._rectDT.width / 2, 0);\n\t\t}\n\n\t\tstrokeRect(ctx, this._rect, this._borderColor);\n\n\t\tctx.fillStyle = this._textColor;\n\t\tctx.fillText(this._fps, 12, 0);\n\n\t\tctx.restore();\n\t};\n\n\tthis.getFPS = function() {\n\t\treturn this._fps;\n\t};\n});\n","pre":true},"../../../browser/lib/runtimeBrowser/device/FontBuffer.js":{"path":"../../../browser/lib/runtimeBrowser/device/FontBuffer.js","friendlyPath":".FontBuffer","directory":"../../../browser/lib/runtimeBrowser/device/","filename":"FontBuffer.js","src":"/**\n * @package env.browser.FontBuffer;\n *\n * ??? What the hell is this\n */\n\njsio(\"import device\");\n\nvar randomColorElement = function() {\n\tvar e = Math.floor(Math.random() * 255).toString(16);\n\treturn ((e.length === 1) ? '0' : '') + e;\n};\n\nvar randomColor = function() {\n\treturn '#' + randomColorElement() + randomColorElement() + randomColorElement();\n};\n\nvar browser_lib_runtimeBrowser_device_FontBuffer=__class__;var FontBuffer = exports=browser_lib_runtimeBrowser_device_FontBuffer(function browser_lib_runtimeBrowser_device_FontBuffer(){return this.init&&this.init.apply(this,arguments)},function() {\n\tthis.init = function(opts) {\n\t\t// 8 * 24\n\t\t// 10 * 32\n\t\t// 8 * 64\n\t\tvar lineSizes = [{size: 24, count: 8}, {size: 32, count: 10}, {size: 64, count: 8}],\n\t\t\tlineSize,\n\t\t\tlines,\n\t\t\titem,\n\t\t\ty = 0,\n\t\t\ti, j;\n\n\t\tthis._canvas = document.createElement('canvas');\n\t\tthis._canvas.width = 1024;\n\t\tthis._canvas.height = 1024;\n\t\tthis._ctx = this._canvas.getContext('2d');\n\n\t\tthis._list = [];\n\t\tfor (i = 0; i < lineSizes.length; i++) {\n\t\t\tlines = [];\n\t\t\tlineSize = lineSizes[i];\n\n\t\t\tfor (j = 0; j < lineSize.count; j++) {\n\t\t\t\titem = {\n\t\t\t\t\tprevious: null,\n\t\t\t\t\tnext: null,\n\t\t\t\t\tx: 0,\n\t\t\t\t\ty: y,\n\t\t\t\t\twidth: 1024,\n\t\t\t\t\theight: 0,\n\t\t\t\t\thash: null,\n\t\t\t\t\tframe: 0,\n\t\t\t\t\trefresh: true,\n\t\t\t\t\tctx: this._ctx\n\t\t\t\t};\n\t\t\t\tlines.push(item);\n\t\t\t\ty += lineSize.size;\n\t\t\t}\n\n\t\t\tthis._list.push({\n\t\t\t\tsize: lineSize.size,\n\t\t\t\tlines: lines\n\t\t\t});\n\t\t}\n\n\t\tthis._hashMap = {};\n\n\t\tthis._currentFrame = 0;\n\t\tthis._frameTimeout = 3;\n\n\t\tjsio('import ui.Engine').get().subscribe('Tick', this, this._onTick);\n\t};\n\n\tthis._onTick = function(dt) {\n\t\tthis._currentFrame++;\n\n\t\tvar remove,\n\t\t\tcurrentFrame = this._currentFrame,\n\t\t\tframeTimeout = this._frameTimeout,\n\t\t\tlist = this._list,\n\t\t\tlines,\n\t\t\titem,\n\t\t\ti, j, k, l;\n\n\t\tfor (i = 0, j = list.length; i < j; i++) {\n\t\t\tlines = list[i].lines;\n\t\t\tfor (k = 0, l = lines.length; k < l; k++) {\n\t\t\t\titem = lines[k];\n\t\t\t\twhile (item) {\n\t\t\t\t\tif (item.hash === null) {\n\t\t\t\t\t\tif (item.next && (item.next.hash === null)) {\n\t\t\t\t\t\t\titem.width += item.next.width;\n\t\t\t\t\t\t\titem.next = item.next.next;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (currentFrame > item.frame + frameTimeout) {\n\t\t\t\t\t\tthis._ctx.fillStyle = randomColor();\n\t\t\t\t\t\tthis._ctx.fillRect(item.x, item.y, item.width, item.height);\n\t\t\t\t\t\t// Remove old item...\n\t\t\t\t\t\tdelete(this._hashMap[item.hash]);\n\t\t\t\t\t\titem.hash = null;\n\t\t\t\t\t}\n\t\t\t\t\titem = item.next;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tthis.alloc = function(opts) {\n\t\tvar requestHeight = opts.height,\n\t\t\trequestWidth = opts.width + 3, // Add some extra pixels to allow color bleeding...\n\n\t\t\tstrokeStyle = opts.strokeStyle || '',\n\t\t\tfillStyle = opts.fillStyle || '',\n\t\t\tfont = opts.font || '',\n\t\t\thash = strokeStyle + '_' + fillStyle + '_' + font + '_' + opts.text,\n\n\t\t\tlist = this._list,\n\t\t\tlines,\n\t\t\titem = this._hashMap[hash],\n\t\t\ti, j, k, l;\n\n\t\tif (item) {\n\t\t\titem.frame = this._currentFrame;\n\t\t\titem.refresh = false;\n\t\t\treturn item;\n\t\t}\n\n\t\tfor (i = 0, j = list.length; i < j; i++) {\n\t\t\tif (requestHeight <= list[i].size) {\n\t\t\t\tlines = list[i].lines;\n\t\t\t\tfor (k = 0, l = lines.length; k < l; k++) {\n\t\t\t\t\titem = lines[k];\n\t\t\t\t\twhile (item) {\n\t\t\t\t\t\tif ((requestWidth <= item.width) && (item.hash === null)) {\n\t\t\t\t\t\t\tif (requestWidth !== item.width) {\n\t\t\t\t\t\t\t\t//console.log('request:', requestWidth, 'width:', item.width, 'rest:', item.width - requestWidth);\n\t\t\t\t\t\t\t\titem.next = {\n\t\t\t\t\t\t\t\t\tprevious: item,\n\t\t\t\t\t\t\t\t\tnext: item.next,\n\t\t\t\t\t\t\t\t\tx: item.x + requestWidth,\n\t\t\t\t\t\t\t\t\ty: item.y,\n\t\t\t\t\t\t\t\t\twidth: item.width - requestWidth,\n\t\t\t\t\t\t\t\t\thash: null,\n\t\t\t\t\t\t\t\t\tframe: 0,\n\t\t\t\t\t\t\t\t\tctx: this._ctx\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\titem.frame = this._currentFrame;\n\t\t\t\t\t\t\titem.hash = hash;\n\t\t\t\t\t\t\titem.width = requestWidth;\n\t\t\t\t\t\t\titem.height = requestHeight;\n\t\t\t\t\t\t\titem.refresh = true;\n\n\t\t\t\t\t\t\tthis._ctx.clearRect(item.x, item.y, requestWidth, requestHeight);\n\n\t\t\t\t\t\t\tthis._hashMap[hash] = item;\n\t\t\t\t\t\t\treturn item;\n\t\t\t\t\t\t}\n\t\t\t\t\t\titem = item.next;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t};\n\n\tthis.getCanvas = function() {\n\t\treturn this._canvas;\n\t};\n});\n","pre":true},"../../../browser/lib/runtimeBrowser/device/dev_error.js":{"path":"../../../browser/lib/runtimeBrowser/device/dev_error.js","friendlyPath":".dev_error","directory":"../../../browser/lib/runtimeBrowser/device/","filename":"dev_error.js","src":"/**\n * @package timestep.env.browser.dev_error;\n *\n * Displays a developer error.\n *\n * ??? TODO move to a debug package.\n */\n\nexports.render = function(e) {\n\tlogger.error(\"unhandled tick exception\");\n\tlogger.error(e.stack);\n\t\n\tvar c = document.getElementsByTagName('canvas');\n\tfor (var i = 0, el; el = c[i]; ++i) {\n\t\trender(el.getContext('2d'), e);\n\t}\n}\n\nfunction render(ctx, e) {\n\tctx.fillStyle = \"rgb(0, 0, 255)\";\n\tctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n\t\n\tvar x = 30, y = 40;\n\n\tctx.fillStyle = \"#FFF\";\n\tctx.font = \"bold 12px Monaco,\\\"Bitstream Vera Sans Mono\\\",\\\"Lucida Console\\\",Terminal,monospace\";\n\tfunction drawLine(msg) {\n\t\tctx.fillText(msg, x, y);\n\t\ty += 20;\n\t}\n\t\n\tdrawLine(e.message);\n\ty += 40;\n\te.stack.split('\\n').map(drawLine);\n}\n","pre":true},"../../../browser/lib/runtimeBrowser/device/FlashAPI.js":{"path":"../../../browser/lib/runtimeBrowser/device/FlashAPI.js","friendlyPath":".FlashAPI","directory":"../../../browser/lib/runtimeBrowser/device/","filename":"FlashAPI.js","src":"\"use import\";\n\njsio(\"import lib.PubSub\");\njsio(\"import .SoundManager\");\njsio(\"from util.underscore import _\");\n\nvar soundManager = new SoundManager();\nsoundManager.url = 'media/swf';\nsoundManager.flashVersion = 9;\nsoundManager.useMovieStar = true;\nsoundManager.debugMode = false;\nsoundManager.consoleOnly = true;\nsoundManager.useHighPerformance = true;\nsoundManager.useFastPolling = true;\n\n/**\n * @extends lib.PubSub\n */\nvar browser_lib_runtimeBrowser_device_FlashAPI=__class__;var AudioAPI = exports=browser_lib_runtimeBrowser_device_FlashAPI(function browser_lib_runtimeBrowser_device_FlashAPI(){return this.init&&this.init.apply(this,arguments)},lib.PubSub, function(supr) {\n\tthis.init = function(opts) {\n\n\t\topts = merge(opts, {\n\t\t\tmap: {},\n\t\t\tbackground: []\n\t\t});\n\n\t\tsupr(this, 'init', [opts]);\n\t\tvar path = opts.path;\n\t\tthis._map = {};\n\n\t\t_.each(opts.background, function(name) {\n\t\t\topts.map[name] = {'name': name}\n\t\t}, this);\n\t\t\n\t\tsoundManager.onready(bind(this, function() {\n\t\t\tlogger.log('SoundManager onReady');\n\t\t\tfor (key in opts.map) {\n\t\t\t\tlogger.log('SoundManager key: ', key);\n\t\t\t\tvar url = 'media/audio/'  + key + '.mp3';\n\t\t\t\tvar k = this._map[key] = soundManager.createSound({\n\t\t\t\t\tid: key,\n\t\t\t\t\tbufferTime: 3,\n\t\t\t\t\turl: url\n\t\t\t\t});\n\t\t\t\tk.load();\n\t\t\t}\n\n\t\t\tthis.publish('Ready');\n\t\t}));\n\t}\n\t\n\tthis.canPlay = function(name) {\n\t\treturn (name in this._map);\n\t}\n\t\n\tthis.setVolume = function(volume) {\n\t\tthis._soundPlaying && soundManager.setVolume(this._soundPlaying, volume);\n\t\tthis._backgroundSoundPlaying && soundManager.setVolume(this._backgroundSoundPlaying, volume);\n\t}\n\n\tthis.setMuted = function(muted) {\n\t\tthis.muted = muted;\n\t\tif (muted) {\n\t\t\tthis.setVolume(0);\n\t\t}\n\t}\n\n\tthis.play = function(name, volume, channel) {\n\t\tif (!this.canPlay(name)) { return; }\n\t\tif (this.muted) { return; }\n\t\tif (volume === undefined) {\n\t\t\tvolume = 1.0;\n\t\t}\n\t\tthis._soundPlaying = name;\n\t\tthis._map[name].setVolume(volume * 100 | 0);\n\t\tthis._map[name].play();\n\t}\n\n\tthis.pause = function() {\n\t\tthis._map[this._soundPlaying].pause();\n\t\tthis._soundPlaying = null;\n\t}\n\n\tthis.playBackgroundMusic = function(name, volume) {\n\t\tif (!this.canPlay(name)) { return; }\n\t\tif (this.muted) { return; }\n\t\tif (volume === undefined) {\n\t\t\tvolume = 1.0;\n\t\t}\n\t\tthis._backgroundSoundPlaying = name;\n\t\tthis._map[name].setVolume(volume * 100 | 0);\n\t\tthis._map[name].play();\n\t}\n\n\tthis.pauseBackgroundMusic = function() {\n\t\tif (!this._backgroundSoundPlaying) { return; }\n\t\tthis._map[this._backgroundSoundPlaying].pause();\n\t\tthis._backgroundSoundPlaying = null;\n\t}\n});\n","pre":true},"../../../browser/lib/runtimeBrowser/device/SoundManager.js":{"path":"../../../browser/lib/runtimeBrowser/device/SoundManager.js","friendlyPath":".SoundManager","directory":"../../../browser/lib/runtimeBrowser/device/","filename":"SoundManager.js","src":"/** @license\r\n * SoundManager 2: JavaScript Sound for the Web\r\n * ----------------------------------------------\r\n * http://schillmania.com/projects/soundmanager2/\r\n *\r\n * Copyright (c) 2007, Scott Schiller. All rights reserved.\r\n * Code provided under the BSD License:\r\n * http://schillmania.com/projects/soundmanager2/license.txt\r\n *\r\n * V2.97a.20110801\r\n*/\r\n\r\n/*global window, SM2_DEFER, sm2Debugger, console, document, navigator, setTimeout, setInterval, clearInterval, Audio */\r\n/*jslint regexp: true, sloppy: true, white: true, nomen: true, plusplus: true */\r\n\r\nvar SoundManager = exports = function SoundManager(smURL, smID) {\r\n\r\n  this.flashVersion = 8;             // version of flash to require, either 8 or 9. Some API features require Flash 9.\r\n  this.debugMode = true;             // enable debugging output (div#soundmanager-debug, OR console if available+configured)\r\n  this.debugFlash = false;           // enable debugging output inside SWF, troubleshoot Flash/browser issues\r\n  this.useConsole = true;            // use firebug/safari console.log()-type debug console if available\r\n  this.consoleOnly = false;          // if console is being used, do not create/write to #soundmanager-debug\r\n  this.waitForWindowLoad = false;    // force SM2 to wait for window.onload() before trying to call soundManager.onload()\r\n  this.nullURL = 'about:blank';      // path to \"null\" (empty) MP3 file, used to unload sounds (Flash 8 only)\r\n  this.allowPolling = true;          // allow flash to poll for status update (required for whileplaying() events, peak, sound spectrum functions to work.)\r\n  this.useFastPolling = false;       // uses lower flash timer interval for higher callback frequency, best combined with useHighPerformance\r\n  this.useMovieStar = true;          // enable support for Flash 9.0r115+ (codename \"MovieStar\") MPEG4 audio formats (AAC, M4V, FLV, MOV etc.)\r\n  this.bgColor = '#ffffff';          // movie (.swf) background color, eg. '#000000'\r\n  this.useHighPerformance = false;   // position:fixed flash movie can help increase js/flash speed, minimize lag\r\n  this.flashPollingInterval = null;  // msec for polling interval. Defaults to 50 unless useFastPolling = true.\r\n  this.flashLoadTimeout = 1000;      // msec to wait for flash movie to load before failing (0 = infinity)\r\n  this.wmode = null;                 // string: flash rendering mode - null, transparent, opaque (last two allow layering of HTML on top)\r\n  this.allowScriptAccess = 'always'; // for scripting the SWF (object/embed property), either 'always' or 'sameDomain'\r\n  this.useFlashBlock = false;        // *requires flashblock.css, see demos* - allow recovery from flash blockers. Wait indefinitely and apply timeout CSS to SWF, if applicable.\r\n  this.useHTML5Audio = true;         // Beta feature: Use HTML5 Audio() where API is supported (most Safari, Chrome versions), Firefox (no MP3/MP4.) Ideally, transparent vs. Flash API where possible.\r\n  this.html5Test = /^(probably|maybe)$/i; // HTML5 Audio() format support test. Use /^probably$/i; if you want to be more conservative.\r\n  this.preferFlash = true;           // (experimental) if true and flash support present, will try to use flash for MP3/MP4 as needed since HTML5 audio support is still quirky in browsers.\r\n\r\n  this.audioFormats = {\r\n    /*\r\n     * determines HTML5 support + flash requirements.\r\n     * if no support for a \"required\" format, SM2 will fail to start.\r\n     * flash fallback is used for MP3 or MP4 if HTML5 can't play it (or if preferFlash = true)\r\n     * multiple MIME types may be tested while trying to get a positive canPlayType() response.\r\n    */\r\n    'mp3': {\r\n      'type': ['audio/mpeg; codecs=\"mp3\"', 'audio/mpeg', 'audio/mp3', 'audio/MPA', 'audio/mpa-robust'],\r\n      'required': true\r\n    },\r\n    'mp4': {\r\n      'related': ['aac','m4a'], // additional formats under the MP4 container\r\n      'type': ['audio/mp4; codecs=\"mp4a.40.2\"', 'audio/aac', 'audio/x-m4a', 'audio/MP4A-LATM', 'audio/mpeg4-generic'],\r\n      'required': false\r\n    },\r\n    'ogg': {\r\n      'type': ['audio/ogg; codecs=vorbis'],\r\n      'required': false\r\n    },\r\n    'wav': {\r\n      'type': ['audio/wav; codecs=\"1\"', 'audio/wav', 'audio/wave', 'audio/x-wav'],\r\n      'required': false\r\n    }\r\n  };\r\n\r\n  this.defaultOptions = {\r\n    'autoLoad': false,             // enable automatic loading (otherwise .load() will be called on demand with .play(), the latter being nicer on bandwidth - if you want to .load yourself, you also can)\r\n    'stream': true,                // allows playing before entire file has loaded (recommended)\r\n    'autoPlay': false,             // enable playing of file as soon as possible (much faster if \"stream\" is true)\r\n    'loops': 1,                    // how many times to repeat the sound (position will wrap around to 0, setPosition() will break out of loop when >0)\r\n    'onid3': null,                 // callback function for \"ID3 data is added/available\"\r\n    'onload': null,                // callback function for \"load finished\"\r\n    'whileloading': null,          // callback function for \"download progress update\" (X of Y bytes received)\r\n    'onplay': null,                // callback for \"play\" start\r\n    'onpause': null,               // callback for \"pause\"\r\n    'onresume': null,              // callback for \"resume\" (pause toggle)\r\n    'whileplaying': null,          // callback during play (position update)\r\n    'onstop': null,                // callback for \"user stop\"\r\n    'onfailure': null,             // callback function for when playing fails\r\n    'onfinish': null,              // callback function for \"sound finished playing\"\r\n    'onbeforefinish': null,        // callback for \"before sound finished playing (at [time])\"\r\n    'onbeforefinishtime': 5000,    // offset (milliseconds) before end of sound to trigger beforefinish (eg. 1000 msec = 1 second)\r\n    'onbeforefinishcomplete': null,// function to call when said sound finishes playing\r\n    'onjustbeforefinish': null,    // callback for [n] msec before end of current sound\r\n    'onjustbeforefinishtime': 200, // [n] - if not using, set to 0 (or null handler) and event will not fire.\r\n    'multiShot': true,             // let sounds \"restart\" or layer on top of each other when played multiple times, rather than one-shot/one at a time\r\n    'multiShotEvents': false,      // fire multiple sound events (currently onfinish() only) when multiShot is enabled\r\n    'position': null,              // offset (milliseconds) to seek to within loaded sound data.\r\n    'pan': 0,                      // \"pan\" settings, left-to-right, -100 to 100\r\n    'type': null,                  // MIME-like hint for file pattern / canPlay() tests, eg. audio/mp3\r\n    'usePolicyFile': false,        // enable crossdomain.xml request for audio on remote domains (for ID3/waveform access)\r\n    'volume': 100                  // self-explanatory. 0-100, the latter being the max.\r\n  };\r\n\r\n  this.flash9Options = {      // flash 9-only options, merged into defaultOptions if flash 9 is being used\r\n    'isMovieStar': null,      // \"MovieStar\" MPEG4 audio mode. Null (default) = auto detect MP4, AAC etc. based on URL. true = force on, ignore URL\r\n    'usePeakData': false,     // enable left/right channel peak (level) data\r\n    'useWaveformData': false, // enable sound spectrum (raw waveform data) - WARNING: CPU-INTENSIVE: may set CPUs on fire.\r\n    'useEQData': false,       // enable sound EQ (frequency spectrum data) - WARNING: Also CPU-intensive.\r\n    'onbufferchange': null,   // callback for \"isBuffering\" property change\r\n    'ondataerror': null       // callback for waveform/eq data access error (flash playing audio in other tabs/domains)\r\n  };\r\n\r\n  this.movieStarOptions = { // flash 9.0r115+ MPEG4 audio options, merged into defaultOptions if flash 9+movieStar mode is enabled\r\n    'bufferTime': 3,        // seconds of data to buffer before playback begins (null = flash default of 0.1 seconds - if AAC playback is gappy, try increasing.)\r\n    'serverURL': null,      // rtmp: FMS or FMIS server to connect to, required when requesting media via RTMP or one of its variants\r\n    'onconnect': null,      // rtmp: callback for connection to flash media server\r\n    'duration': null        // rtmp: song duration (msec)\r\n  };\r\n\r\n  this.version = null;\r\n  this.versionNumber = 'V2.97a.20110801';\r\n  this.movieURL = null;\r\n  this.url = (smURL || null);\r\n  this.altURL = null;\r\n  this.swfLoaded = false;\r\n  this.enabled = false;\r\n  this.o = null;\r\n  this.movieID = 'sm2-container';\r\n  this.id = (smID || 'sm2movie');\r\n  this.swfCSS = {\r\n    'swfBox': 'sm2-object-box',\r\n    'swfDefault': 'movieContainer',\r\n    'swfError': 'swf_error', // SWF loaded, but SM2 couldn't start (other error)\r\n    'swfTimedout': 'swf_timedout',\r\n    'swfLoaded': 'swf_loaded',\r\n    'swfUnblocked': 'swf_unblocked', // or loaded OK\r\n    'sm2Debug': 'sm2_debug',\r\n    'highPerf': 'high_performance',\r\n    'flashDebug': 'flash_debug'\r\n  };\r\n  this.oMC = null;\r\n  this.sounds = {};\r\n  this.soundIDs = [];\r\n  this.muted = false;\r\n  this.debugID = 'soundmanager-debug';\r\n  this.debugURLParam = /([#?&])debug=1/i;\r\n  this.specialWmodeCase = false;\r\n  this.didFlashBlock = false;\r\n\r\n  this.filePattern = null;\r\n  this.filePatterns = {\r\n    'flash8': /\\.mp3(\\?.*)?$/i,\r\n    'flash9': /\\.mp3(\\?.*)?$/i\r\n  };\r\n\r\n  this.baseMimeTypes = /^\\s*audio\\/(?:x-)?(?:mp(?:eg|3))\\s*(?:$|;)/i; // mp3\r\n  this.netStreamMimeTypes = /^\\s*audio\\/(?:x-)?(?:mp(?:eg|3))\\s*(?:$|;)/i; // mp3, mp4, aac etc.\r\n  this.netStreamTypes = ['aac', 'flv', 'mov', 'mp4', 'm4v', 'f4v', 'm4a', 'mp4v', '3gp', '3g2']; // Flash v9.0r115+ \"moviestar\" formats\r\n  this.netStreamPattern = new RegExp('\\\\.(' + this.netStreamTypes.join('|') + ')(\\\\?.*)?$', 'i');\r\n  this.mimePattern = this.baseMimeTypes;\r\n\r\n  this.features = {\r\n    'buffering': false,\r\n    'peakData': false,\r\n    'waveformData': false,\r\n    'eqData': false,\r\n    'movieStar': false\r\n  };\r\n\r\n  this.sandbox = {\r\n    // <d>\r\n    'type': null,\r\n    'types': {\r\n      'remote': 'remote (domain-based) rules',\r\n      'localWithFile': 'local with file access (no internet access)',\r\n      'localWithNetwork': 'local with network (internet access only, no local access)',\r\n      'localTrusted': 'local, trusted (local+internet access)'\r\n    },\r\n    'description': null,\r\n    'noRemote': null,\r\n    'noLocal': null\r\n    // </d>\r\n  };\r\n\r\n  this.hasHTML5 = (typeof Audio !== 'undefined' && typeof new Audio().canPlayType !== 'undefined'); // switch for handling logic\r\n\r\n  // stores canPlayType() results, etc. treat as read-only.\r\n  this.html5 = {\r\n    // mp3: boolean\r\n    // mp4: boolean\r\n    'usingFlash': null // set if/when flash fallback is needed\r\n  };\r\n\r\n  // format support\r\n  this.flash = {\r\n    // mp3: boolean\r\n    // mp4: boolean\r\n  };\r\n\r\n  this.html5Only = false;   // determined at init time\r\n  this.ignoreFlash = false; // used for special cases (eg. iPad/iPhone/palm OS?)\r\n\r\n  /*\r\n   * a few private internals\r\n  */\r\n\r\n  var SMSound,\r\n  _s = this, _sm = 'soundManager', _smc = _sm+'::', _h5 = 'HTML5::', _id, _ua = navigator.userAgent, _win = window, _wl = _win.location.href.toString(), _fV = this.flashVersion, _doc = document, _doNothing, _init, _on_queue = [], _debugOpen = true, _debugTS, _didAppend = false, _appendSuccess = false, _didInit = false, _disabled = false, _windowLoaded = false, _wDS, _wdCount = 0, _initComplete, _mixin, _addOnEvent, _processOnEvents, _initUserOnload, _delayWaitForEI, _waitForEI, _setVersionInfo, _handleFocus, _strings, _initMovie, _dcLoaded, _didDCLoaded, _getDocument, _createMovie, _catchError, _setPolling, _initDebug, _debugLevels = ['log', 'info', 'warn', 'error'], _defaultFlashVersion = 8, _disableObject, _failSafely, _normalizeMovieURL, _oRemoved = null, _oRemovedHTML = null, _str, _flashBlockHandler, _getSWFCSS, _toggleDebug, _loopFix, _policyFix, _complain, _idCheck, _waitingForEI = false, _initPending = false, _smTimer, _onTimer, _startTimer, _stopTimer, _needsFlash = null, _featureCheck, _html5OK, _html5CanPlay, _html5Ext,  _dcIE, _testHTML5, _event, _slice = Array.prototype.slice, _useGlobalHTML5Audio = false, _hasFlash, _detectFlash, _badSafariFix, _html5_events, _showSupport,\r\n  _is_iDevice = _ua.match(/(ipad|iphone|ipod)/i), _likesHTML5 = (_ua.match(/(mobile|pre\\/|xoom)/i) || _is_iDevice), _isIE = _ua.match(/msie/i), _isWebkit = _ua.match(/webkit/i), _isSafari = (_ua.match(/safari/i) && !_ua.match(/chrome/i)), _isOpera = (_ua.match(/opera/i)), \r\n  _isBadSafari = (!_wl.match(/usehtml5audio/i) && !_wl.match(/sm2\\-ignorebadua/i) && _isSafari && _ua.match(/OS X 10_6_([3-7])/i)), // Safari 4 and 5 occasionally fail to load/play HTML5 audio on Snow Leopard 10.6.3 through 10.6.7 due to bug(s) in QuickTime X and/or other underlying frameworks. :/ Confirmed bug. https://bugs.webkit.org/show_bug.cgi?id=32159\r\n  _hasConsole = (typeof console !== 'undefined' && typeof console.log !== 'undefined'), _isFocused = (typeof _doc.hasFocus !== 'undefined'?_doc.hasFocus():null), _tryInitOnFocus = (_isSafari && typeof _doc.hasFocus === 'undefined'), _okToDisable = !_tryInitOnFocus, _flashMIME = /(mp3|mp4|mpa)/i,\r\n  _overHTTP = (_doc.location?_doc.location.protocol.match(/http/i):null),\r\n  _http = (!_overHTTP ? 'http:' : '');\r\n\r\n  this.useAltURL = !_overHTTP; // use altURL if not \"online\"\r\n  this._global_a = null;\r\n\r\n  if (_likesHTML5) {\r\n    // prefer HTML5 for mobile + tablet-like devices, probably more reliable vs. flash at this point.\r\n    _s.useHTML5Audio = true;\r\n    _s.preferFlash = false;\r\n    if (_is_iDevice) {\r\n      // by default, use global feature. iOS onfinish() -> next may fail otherwise.\r\n      _s.ignoreFlash = true;\r\n      _useGlobalHTML5Audio = true;\r\n    }\r\n  }\r\n\r\n  /*\r\n   * public soundManager API\r\n  */\r\n\r\n  this.ok = function() {\r\n    return (_needsFlash?(_didInit && !_disabled):(_s.useHTML5Audio && _s.hasHTML5));\r\n  };\r\n\r\n  this.supported = this.ok; // legacy\r\n\r\n  this.getMovie = function(smID) {\r\n    return _isIE?_win[smID]:(_isSafari?_id(smID) || _doc[smID]:_id(smID));\r\n  };\r\n\r\n  this.createSound = function(oOptions) {\r\n    var _cs = _sm+'.createSound(): ',\r\n    thisOptions = null, oSound = null, _tO = null;\r\n    if (!_didInit || !_s.ok()) {\r\n      _complain(_cs + _str(!_didInit?'notReady':'notOK'));\r\n      return false;\r\n    }\r\n    if (arguments.length === 2) {\r\n      // function overloading in JS! :) ..assume simple createSound(id,url) use case\r\n      oOptions = {\r\n        'id': arguments[0],\r\n        'url': arguments[1]\r\n      };\r\n    }\r\n    thisOptions = _mixin(oOptions); // inherit from defaultOptions\r\n    _tO = thisOptions; // alias\r\n    // <d>\r\n    if (_tO.id.toString().charAt(0).match(/^[0-9]$/)) {\r\n      _s._wD(_cs + _str('badID', _tO.id), 2);\r\n    }\r\n    _s._wD(_cs + _tO.id + ' (' + _tO.url + ')', 1);\r\n    // </d>\r\n    if (_idCheck(_tO.id, true)) {\r\n      _s._wD(_cs + _tO.id + ' exists', 1);\r\n      return _s.sounds[_tO.id];\r\n    }\r\n\r\n    function make() {\r\n      thisOptions = _loopFix(thisOptions);\r\n      _s.sounds[_tO.id] = new SMSound(_tO);\r\n      _s.soundIDs.push(_tO.id);\r\n      return _s.sounds[_tO.id];\r\n    }\r\n\r\n    if (_html5OK(_tO)) {\r\n      oSound = make();\r\n      _s._wD('Loading sound '+_tO.id+' via HTML5');\r\n      oSound._setup_html5(_tO);\r\n    } else {\r\n      if (_fV > 8 && _s.useMovieStar) {\r\n        if (_tO.isMovieStar === null) {\r\n          _tO.isMovieStar = ((_tO.serverURL || (_tO.type?_tO.type.match(_s.netStreamPattern):false)||_tO.url.match(_s.netStreamPattern))?true:false);\r\n        }\r\n        if (_tO.isMovieStar) {\r\n          _s._wD(_cs + 'using MovieStar handling');\r\n        }\r\n        if (_tO.isMovieStar) {\r\n          if (_tO.usePeakData) {\r\n            _wDS('noPeak');\r\n            _tO.usePeakData = false;\r\n          }\r\n          if (_tO.loops > 1) {\r\n            _wDS('noNSLoop');\r\n          }\r\n        }\r\n      }\r\n      _tO = _policyFix(_tO, _cs);\r\n      oSound = make();\r\n      if (_fV === 8) {\r\n        _s.o._createSound(_tO.id, _tO.onjustbeforefinishtime, _tO.loops||1, _tO.usePolicyFile);\r\n      } else {\r\n        _s.o._createSound(_tO.id, _tO.url, _tO.onjustbeforefinishtime, _tO.usePeakData, _tO.useWaveformData, _tO.useEQData, _tO.isMovieStar, (_tO.isMovieStar?_tO.bufferTime:false), _tO.loops||1, _tO.serverURL, _tO.duration||null, _tO.autoPlay, true, _tO.autoLoad, _tO.usePolicyFile);\r\n        if (!_tO.serverURL) {\r\n          // We are connected immediately\r\n          oSound.connected = true;\r\n          if (_tO.onconnect) {\r\n            _tO.onconnect.apply(oSound);\r\n          }\r\n        }\r\n      }\r\n\r\n      if (!_tO.serverURL && (_tO.autoLoad || _tO.autoPlay)) {\r\n        oSound.load(_tO); // call load for non-rtmp streams\r\n      }\r\n    }\r\n    if (!_tO.serverURL && _tO.autoPlay) { // rtmp will play in onconnect\r\n      oSound.play();\r\n    }\r\n    return oSound;\r\n  };\r\n\r\n  this.destroySound = function(sID, _bFromSound) {\r\n    // explicitly destroy a sound before normal page unload, etc.\r\n    if (!_idCheck(sID)) {\r\n      return false;\r\n    }\r\n    var oS = _s.sounds[sID], i;\r\n    oS._iO = {}; // Disable all callbacks while the sound is being destroyed\r\n    oS.stop();\r\n    oS.unload();\r\n    for (i = 0; i < _s.soundIDs.length; i++) {\r\n      if (_s.soundIDs[i] === sID) {\r\n        _s.soundIDs.splice(i, 1);\r\n        break;\r\n      }\r\n    }\r\n    if (!_bFromSound) {\r\n      // ignore if being called from SMSound instance\r\n      oS.destruct(true);\r\n    }\r\n    oS = null;\r\n    delete _s.sounds[sID];\r\n    return true;\r\n  };\r\n\r\n  this.load = function(sID, oOptions) {\r\n    if (!_idCheck(sID)) {\r\n      return false;\r\n    }\r\n    return _s.sounds[sID].load(oOptions);\r\n  };\r\n\r\n  this.unload = function(sID) {\r\n    if (!_idCheck(sID)) {\r\n      return false;\r\n    }\r\n    return _s.sounds[sID].unload();\r\n  };\r\n\r\n  this.play = function(sID, oOptions) {\r\n    var fN = _sm+'.play(): ';\r\n    if (!_didInit || !_s.ok()) {\r\n      _complain(fN + _str(!_didInit?'notReady':'notOK'));\r\n      return false;\r\n    }\r\n    if (!_idCheck(sID)) {\r\n      if (!(oOptions instanceof Object)) {\r\n        oOptions = {\r\n          url: oOptions\r\n        }; // overloading use case: play('mySound','/path/to/some.mp3');\r\n      }\r\n      if (oOptions && oOptions.url) {\r\n        // overloading use case, create+play: .play('someID',{url:'/path/to.mp3'});\r\n        _s._wD(fN + 'attempting to create \"' + sID + '\"', 1);\r\n        oOptions.id = sID;\r\n        return _s.createSound(oOptions).play();\r\n      } else {\r\n        return false;\r\n      }\r\n    }\r\n    return _s.sounds[sID].play(oOptions);\r\n  };\r\n\r\n  this.start = this.play; // just for convenience\r\n\r\n  this.setPosition = function(sID, nMsecOffset) {\r\n    if (!_idCheck(sID)) {\r\n      return false;\r\n    }\r\n    return _s.sounds[sID].setPosition(nMsecOffset);\r\n  };\r\n\r\n  this.stop = function(sID) {\r\n    if (!_idCheck(sID)) {\r\n      return false;\r\n    }\r\n    _s._wD(_sm+'.stop(' + sID + ')', 1);\r\n    return _s.sounds[sID].stop();\r\n  };\r\n\r\n  this.stopAll = function() {\r\n    var oSound;\r\n    _s._wD(_sm+'.stopAll()', 1);\r\n    for (oSound in _s.sounds) {\r\n      if (_s.sounds.hasOwnProperty(oSound)) {\r\n        _s.sounds[oSound].stop(); // apply only to sound objects\r\n      }\r\n    }\r\n  };\r\n\r\n  this.pause = function(sID) {\r\n    if (!_idCheck(sID)) {\r\n      return false;\r\n    }\r\n    return _s.sounds[sID].pause();\r\n  };\r\n\r\n  this.pauseAll = function() {\r\n    var i;\r\n    for (i = _s.soundIDs.length; i--;) {\r\n      _s.sounds[_s.soundIDs[i]].pause();\r\n    }\r\n  };\r\n\r\n  this.resume = function(sID) {\r\n    if (!_idCheck(sID)) {\r\n      return false;\r\n    }\r\n    return _s.sounds[sID].resume();\r\n  };\r\n\r\n  this.resumeAll = function() {\r\n    var i;\r\n    for (i = _s.soundIDs.length; i--;) {\r\n      _s.sounds[_s.soundIDs[i]].resume();\r\n    }\r\n  };\r\n\r\n  this.togglePause = function(sID) {\r\n    if (!_idCheck(sID)) {\r\n      return false;\r\n    }\r\n    return _s.sounds[sID].togglePause();\r\n  };\r\n\r\n  this.setPan = function(sID, nPan) {\r\n    if (!_idCheck(sID)) {\r\n      return false;\r\n    }\r\n    return _s.sounds[sID].setPan(nPan);\r\n  };\r\n\r\n  this.setVolume = function(sID, nVol) {\r\n    if (!_idCheck(sID)) {\r\n      return false;\r\n    }\r\n    return _s.sounds[sID].setVolume(nVol);\r\n  };\r\n\r\n  this.mute = function(sID) {\r\n    var fN = _sm+'.mute(): ',\r\n    i = 0;\r\n    if (typeof sID !== 'string') {\r\n      sID = null;\r\n    }\r\n    if (!sID) {\r\n      _s._wD(fN + 'Muting all sounds');\r\n      for (i = _s.soundIDs.length; i--;) {\r\n        _s.sounds[_s.soundIDs[i]].mute();\r\n      }\r\n      _s.muted = true;\r\n    } else {\r\n      if (!_idCheck(sID)) {\r\n        return false;\r\n      }\r\n      _s._wD(fN + 'Muting \"' + sID + '\"');\r\n      return _s.sounds[sID].mute();\r\n    }\r\n    return true;\r\n  };\r\n\r\n  this.muteAll = function() {\r\n    _s.mute();\r\n  };\r\n\r\n  this.unmute = function(sID) {\r\n    var fN = _sm+'.unmute(): ', i;\r\n    if (typeof sID !== 'string') {\r\n      sID = null;\r\n    }\r\n    if (!sID) {\r\n      _s._wD(fN + 'Unmuting all sounds');\r\n      for (i = _s.soundIDs.length; i--;) {\r\n        _s.sounds[_s.soundIDs[i]].unmute();\r\n      }\r\n      _s.muted = false;\r\n    } else {\r\n      if (!_idCheck(sID)) {\r\n        return false;\r\n      }\r\n      _s._wD(fN + 'Unmuting \"' + sID + '\"');\r\n      return _s.sounds[sID].unmute();\r\n    }\r\n    return true;\r\n  };\r\n\r\n  this.unmuteAll = function() {\r\n    _s.unmute();\r\n  };\r\n\r\n  this.toggleMute = function(sID) {\r\n    if (!_idCheck(sID)) {\r\n      return false;\r\n    }\r\n    return _s.sounds[sID].toggleMute();\r\n  };\r\n\r\n  this.getMemoryUse = function() {\r\n    // flash-only\r\n    var ram = 0;\r\n    if (_s.o && _fV !== 8) {\r\n      ram = parseInt(_s.o._getMemoryUse(), 10);\r\n    }\r\n    return ram;\r\n  };\r\n\r\n  this.disable = function(bNoDisable) {\r\n    // destroy all functions\r\n    var i;\r\n    if (typeof bNoDisable === 'undefined') {\r\n      bNoDisable = false;\r\n    }\r\n    if (_disabled) {\r\n      return false;\r\n    }\r\n    _disabled = true;\r\n    _wDS('shutdown', 1);\r\n    for (i = _s.soundIDs.length; i--;) {\r\n      _disableObject(_s.sounds[_s.soundIDs[i]]);\r\n    }\r\n    _initComplete(bNoDisable); // fire \"complete\", despite fail\r\n    _event.remove(_win, 'load', _initUserOnload);\r\n    return true;\r\n  };\r\n\r\n  this.canPlayMIME = function(sMIME) {\r\n    var result;\r\n    if (_s.hasHTML5) {\r\n      result = _html5CanPlay({type:sMIME});\r\n    }\r\n    if (!_needsFlash || result) {\r\n      // no flash, or OK\r\n      return result;\r\n    } else {\r\n      return (sMIME?(sMIME.match(_s.mimePattern)?true:false):null);\r\n    }\r\n  };\r\n\r\n  this.canPlayURL = function(sURL) {\r\n    var result;\r\n    if (_s.hasHTML5) {\r\n      result = _html5CanPlay({url: sURL});\r\n    }\r\n    if (!_needsFlash || result) {\r\n      // no flash, or OK\r\n      return result;\r\n    } else {\r\n      return (sURL?(sURL.match(_s.filePattern)?true:false):null);\r\n    }\r\n  };\r\n\r\n  this.canPlayLink = function(oLink) {\r\n    if (typeof oLink.type !== 'undefined' && oLink.type) {\r\n      if (_s.canPlayMIME(oLink.type)) {\r\n        return true;\r\n      }\r\n    }\r\n    return _s.canPlayURL(oLink.href);\r\n  };\r\n\r\n  this.getSoundById = function(sID, suppressDebug) {\r\n    if (!sID) {\r\n      throw new Error(_sm+'.getSoundById(): sID is null/undefined');\r\n    }\r\n    var result = _s.sounds[sID];\r\n    if (!result && !suppressDebug) {\r\n      _s._wD('\"' + sID + '\" is an invalid sound ID.', 2);\r\n    }\r\n    return result;\r\n  };\r\n\r\n  this.onready = function(oMethod, oScope) {\r\n    var sType = 'onready';\r\n    if (oMethod && oMethod instanceof Function) {\r\n      if (_didInit) {\r\n        _s._wD(_str('queue', sType));\r\n      }\r\n      if (!oScope) {\r\n        oScope = _win;\r\n      }\r\n      _addOnEvent(sType, oMethod, oScope);\r\n      _processOnEvents();\r\n      return true;\r\n    } else {\r\n      throw _str('needFunction', sType);\r\n    }\r\n  };\r\n\r\n  this.ontimeout = function(oMethod, oScope) {\r\n    var sType = 'ontimeout';\r\n    if (oMethod && oMethod instanceof Function) {\r\n      if (_didInit) {\r\n        _s._wD(_str('queue', sType));\r\n      }\r\n      if (!oScope) {\r\n        oScope = _win;\r\n      }\r\n      _addOnEvent(sType, oMethod, oScope);\r\n      _processOnEvents({type:sType});\r\n      return true;\r\n    } else {\r\n      throw _str('needFunction', sType);\r\n    }\r\n  };\r\n\r\n  this._writeDebug = function(sText, sType, bTimestamp) {\r\n    // pseudo-private console.log()-style output\r\n    // <d>\r\n    var sDID = 'soundmanager-debug', o, oItem, sMethod;\r\n    if (!_s.debugMode) {\r\n      return false;\r\n    }\r\n    if (typeof bTimestamp !== 'undefined' && bTimestamp) {\r\n      sText = sText + ' | ' + new Date().getTime();\r\n    }\r\n    if (_hasConsole && _s.useConsole) {\r\n      sMethod = _debugLevels[sType];\r\n      if (typeof console[sMethod] !== 'undefined') {\r\n        console[sMethod](sText);\r\n      } else {\r\n        console.log(sText);\r\n      }\r\n      if (_s.useConsoleOnly) {\r\n        return true;\r\n      }\r\n    }\r\n    try {\r\n      o = _id(sDID);\r\n      if (!o) {\r\n        return false;\r\n      }\r\n      oItem = _doc.createElement('div');\r\n      if (++_wdCount % 2 === 0) {\r\n        oItem.className = 'sm2-alt';\r\n      }\r\n      if (typeof sType === 'undefined') {\r\n        sType = 0;\r\n      } else {\r\n        sType = parseInt(sType, 10);\r\n      }\r\n      oItem.appendChild(_doc.createTextNode(sText));\r\n      if (sType) {\r\n        if (sType >= 2) {\r\n          oItem.style.fontWeight = 'bold';\r\n        }\r\n        if (sType === 3) {\r\n          oItem.style.color = '#ff3333';\r\n        }\r\n      }\r\n      // o.appendChild(oItem); // top-to-bottom\r\n      o.insertBefore(oItem, o.firstChild); // bottom-to-top\r\n    } catch(e) {\r\n      // oh well\r\n    }\r\n    o = null;\r\n    // </d>\r\n    return true;\r\n  };\r\n  this._wD = this._writeDebug; // alias\r\n\r\n  this._debug = function() {\r\n    // <d>\r\n    var i, j;\r\n    _wDS('currentObj', 1);\r\n    for (i = 0, j = _s.soundIDs.length; i < j; i++) {\r\n      _s.sounds[_s.soundIDs[i]]._debug();\r\n    }\r\n    // </d>\r\n  };\r\n\r\n  this.reboot = function() {\r\n    // attempt to reset and init SM2\r\n    _s._wD(_sm+'.reboot()');\r\n    if (_s.soundIDs.length) {\r\n      _s._wD('Destroying ' + _s.soundIDs.length + ' SMSound objects...');\r\n    }\r\n    var i, j;\r\n    for (i = _s.soundIDs.length; i--;) {\r\n      _s.sounds[_s.soundIDs[i]].destruct();\r\n    }\r\n    // trash ze flash\r\n    try {\r\n      if (_isIE) {\r\n        _oRemovedHTML = _s.o.innerHTML;\r\n      }\r\n      _oRemoved = _s.o.parentNode.removeChild(_s.o);\r\n      _s._wD('Flash movie removed.');\r\n    } catch(e) {\r\n      // uh-oh.\r\n      _wDS('badRemove', 2);\r\n    }\r\n    // actually, force recreate of movie.\r\n    _oRemovedHTML = _oRemoved = _needsFlash = null;\r\n    _s.enabled = _didDCLoaded = _didInit = _waitingForEI = _initPending = _didAppend = _appendSuccess = _disabled = _s.swfLoaded = false;\r\n    _s.soundIDs = _s.sounds = [];\r\n    _s.o = null;\r\n    for (i in _on_queue) {\r\n      if (_on_queue.hasOwnProperty(i)) {\r\n        for (j = _on_queue[i].length; j--;) {\r\n          _on_queue[i][j].fired = false;\r\n        }\r\n      }\r\n    }\r\n    _s._wD(_sm + ': Rebooting...');\r\n    _win.setTimeout(_s.beginDelayedInit, 20);\r\n  };\r\n\r\n  this.getMoviePercent = function() {\r\n    return (_s.o && typeof _s.o.PercentLoaded !== 'undefined' ? _s.o.PercentLoaded() : null);\r\n  };\r\n\r\n  this.beginDelayedInit = function() {\r\n    _windowLoaded = true;\r\n    _dcLoaded();\r\n    setTimeout(function() {\r\n      if (_initPending) {\r\n        return false;\r\n      }\r\n      _createMovie();\r\n      _initMovie();\r\n      _initPending = true;\r\n      return true;\r\n    }, 20);\r\n    _delayWaitForEI();\r\n  };\r\n\r\n  this.destruct = function() {\r\n    _s._wD(_sm+'.destruct()');\r\n    _s.disable(true);\r\n  };\r\n\r\n  /*\r\n   * internal HTML5 event handling\r\n  */\r\n\r\n  function _html5_event(oFn) {\r\n    // wrap html5 event handlers so we don't call them on destroyed sounds\r\n    return function(e) {\r\n      if (!this._t || !this._t._a) {\r\n        if (this._t && this._t.sID) {\r\n          _s._wD(_h5+'ignoring '+e.type+': '+this._t.sID);\r\n        } else {\r\n          _s._wD(_h5+'ignoring '+e.type);\r\n        }\r\n        return null;\r\n      } else {\r\n        return oFn.call(this, e);\r\n      }\r\n    };\r\n  }\r\n\r\n  _html5_events = {\r\n\r\n    // HTML5 event-name-to-handler map\r\n    abort: _html5_event(function(e) {\r\n      _s._wD(_h5+'abort: '+this._t.sID);\r\n    }),\r\n\r\n    // enough has loaded to play\r\n    canplay: _html5_event(function(e) {\r\n      if (this._t._html5_canplay) {\r\n        // this event has already fired. ignore.\r\n        return true;\r\n      }\r\n      this._t._html5_canplay = true;\r\n      _s._wD(_h5+'canplay: '+this._t.sID+', '+this._t.url);\r\n      this._t._onbufferchange(0);\r\n      var position1K = (!isNaN(this._t.position)?this._t.position/1000:null);\r\n      // set the position if position was set before the sound loaded\r\n      if (this._t.position && this.currentTime !== position1K) {\r\n        _s._wD(_h5+'canplay: setting position to '+position1K);\r\n        try {\r\n          this.currentTime = position1K;\r\n        } catch(ee) {\r\n          _s._wD(_h5+'setting position failed: '+ee.message, 2);\r\n        }\r\n      }\r\n    }),\r\n\r\n    load: _html5_event(function(e) {\r\n      if (!this._t.loaded) {\r\n        this._t._onbufferchange(0);\r\n        // should be 1, and the same\r\n        this._t._whileloading(this._t.bytesTotal, this._t.bytesTotal, this._t._get_html5_duration());\r\n        this._t._onload(true);\r\n      }\r\n    }),\r\n\r\n    emptied: _html5_event(function(e) {\r\n      _s._wD(_h5+'emptied: '+this._t.sID);\r\n    }),\r\n\r\n    ended: _html5_event(function(e) {\r\n      _s._wD(_h5+'ended: '+this._t.sID);\r\n      this._t._onfinish();\r\n    }),\r\n\r\n    error: _html5_event(function(e) {\r\n      _s._wD(_h5+'error: '+this.error.code);\r\n      // call load with error state?\r\n      this._t._onload(false);\r\n    }),\r\n\r\n    loadeddata: _html5_event(function(e) {\r\n      var t = this._t,\r\n          bytesTotal = t.bytesTotal || 1; // at least 1 byte, so math works\r\n      _s._wD(_h5+'loadeddata: '+this._t.sID);\r\n      if (!t._loaded && !_isSafari) { // safari seems to nicely report progress events, eventually totalling 100%\r\n        t.duration = t._get_html5_duration();\r\n        // fire whileloading() with 100% values\r\n        t._whileloading(bytesTotal, bytesTotal, t._get_html5_duration());\r\n        t._onload(true);\r\n      }\r\n    }),\r\n\r\n    loadedmetadata: _html5_event(function(e) {\r\n      _s._wD(_h5+'loadedmetadata: '+this._t.sID);\r\n    }),\r\n\r\n    loadstart: _html5_event(function(e) {\r\n      _s._wD(_h5+'loadstart: '+this._t.sID);\r\n      // assume buffering at first\r\n      this._t._onbufferchange(1);\r\n    }),\r\n\r\n    play: _html5_event(function(e) {\r\n      _s._wD(_h5+'play: '+this._t.sID+', '+this._t.url);\r\n      // once play starts, no buffering\r\n      this._t._onbufferchange(0);\r\n    }),\r\n\r\n    // TODO: verify if this is actually implemented anywhere yet.\r\n    playing: _html5_event(function(e) {\r\n      _s._wD(_h5+'playing: '+this._t.sID+', '+this._t.url);\r\n      // once play starts, no buffering\r\n      this._t._onbufferchange(0);\r\n    }),\r\n\r\n    progress: _html5_event(function(e) {\r\n\r\n      if (this._t.loaded) {\r\n        return false;\r\n      }\r\n\r\n      var i, j, str, buffered = 0,\r\n          isProgress = (e.type === 'progress'),\r\n          ranges = e.target.buffered,\r\n          loaded = (e.loaded||0), // firefox 3.6 implements e.loaded/total (bytes)\r\n          total = (e.total||1);\r\n\r\n      if (ranges && ranges.length) {\r\n\r\n        // if loaded is 0, try TimeRanges implementation as % of load\r\n        // https://developer.mozilla.org/en/DOM/TimeRanges\r\n        for (i=ranges.length; i--;) {\r\n          buffered = (ranges.end(i) - ranges.start(i));\r\n        }\r\n\r\n        // linear case, buffer sum; does not account for seeking and HTTP partials / byte ranges\r\n        loaded = buffered/e.target.duration;\r\n\r\n        // <d>\r\n        if (isProgress && ranges.length > 1) {\r\n          str = [];\r\n          j = ranges.length;\r\n          for (i=0; i<j; i++) {\r\n            str.push(e.target.buffered.start(i) +'-'+ e.target.buffered.end(i));\r\n          }\r\n          _s._wD(_h5+'progress: timeRanges: '+str.join(', '));\r\n        }\r\n        // </d>\r\n\r\n        if (isProgress && !isNaN(loaded)) {\r\n          _s._wD(_h5+'progress: '+this._t.sID+': ' + Math.floor(loaded*100)+'% loaded');\r\n        }\r\n\r\n      }\r\n\r\n      if (!isNaN(loaded)) {\r\n\r\n        this._t._onbufferchange(0); // if progress, likely not buffering\r\n        this._t._whileloading(loaded, total, this._t._get_html5_duration());\r\n\r\n        if (loaded && total && loaded === total) {\r\n          // in case \"onload\" doesn't fire (eg. gecko 1.9.2)\r\n          _html5_events.load.call(this, e);\r\n        }\r\n\r\n      }\r\n\r\n    }),\r\n\r\n    ratechange: _html5_event(function(e) {\r\n      _s._wD(_h5+'ratechange: '+this._t.sID);\r\n    }),\r\n\r\n    suspend: _html5_event(function(e) {\r\n      // download paused/stopped, may have finished (eg. onload)\r\n      _s._wD(_h5+'suspend: '+this._t.sID);\r\n      _html5_events.progress.call(this, e);\r\n    }),\r\n\r\n    stalled: _html5_event(function(e) {\r\n      _s._wD(_h5+'stalled: '+this._t.sID);\r\n    }),\r\n\r\n    timeupdate: _html5_event(function(e) {\r\n      this._t._onTimer();\r\n    }),\r\n\r\n    waiting: _html5_event(function(e) { // see also: seeking\r\n      _s._wD(_h5+'waiting: '+this._t.sID);\r\n      // playback faster than download rate, etc.\r\n      this._t._onbufferchange(1);\r\n    })\r\n\r\n  };\r\n\r\n  /*\r\n   * SMSound() (sound object) instance\r\n  */\r\n\r\n  SMSound = function(oOptions) {\r\n\r\n    var _t = this, _resetProperties, _stop_html5_timer, _start_html5_timer;\r\n    this.sID = oOptions.id;\r\n    this.url = oOptions.url;\r\n    this.options = _mixin(oOptions);\r\n    this.instanceOptions = this.options; // per-play-instance-specific options\r\n    this._iO = this.instanceOptions; // short alias\r\n    // assign property defaults\r\n    this.pan = this.options.pan;\r\n    this.volume = this.options.volume;\r\n    this._lastURL = null;\r\n    this.isHTML5 = false;\r\n    this._a = null;\r\n\r\n    // --- public methods ---\r\n\r\n    this.id3 = {};\r\n\r\n    this._debug = function() {\r\n      // <d>\r\n      // pseudo-private console.log()-style output\r\n      if (_s.debugMode) {\r\n        var stuff = null, msg = [], sF, sfBracket, maxLength = 64;\r\n        for (stuff in _t.options) {\r\n          if (_t.options[stuff] !== null) {\r\n            if (_t.options[stuff] instanceof Function) {\r\n              // handle functions specially\r\n              sF = _t.options[stuff].toString();\r\n              sF = sF.replace(/\\s\\s+/g, ' '); // normalize spaces\r\n              sfBracket = sF.indexOf('{');\r\n              msg.push(' ' + stuff + ': {' + sF.substr(sfBracket + 1, (Math.min(Math.max(sF.indexOf('\\n') - 1, maxLength), maxLength))).replace(/\\n/g, '') + '... }');\r\n            } else {\r\n              msg.push(' ' + stuff + ': ' + _t.options[stuff]);\r\n            }\r\n          }\r\n        }\r\n        _s._wD('SMSound() merged options: {\\n' + msg.join(', \\n') + '\\n}');\r\n      }\r\n      // </d>\r\n    };\r\n\r\n    // <d>\r\n    this._debug();\r\n    // </d>\r\n\r\n    this.load = function(oOptions) {\r\n      var oS = null;\r\n      if (typeof oOptions !== 'undefined') {\r\n        _t._iO = _mixin(oOptions, _t.options);\r\n        _t.instanceOptions = _t._iO;\r\n      } else {\r\n        oOptions = _t.options;\r\n        _t._iO = oOptions;\r\n        _t.instanceOptions = _t._iO;\r\n        if (_t._lastURL && _t._lastURL !== _t.url) {\r\n          _wDS('manURL');\r\n          _t._iO.url = _t.url;\r\n          _t.url = null;\r\n        }\r\n      }\r\n      if (!_t._iO.url) {\r\n        _t._iO.url = _t.url;\r\n      }\r\n      _s._wD('SMSound.load(): ' + _t._iO.url, 1);\r\n      if (_t._iO.url === _t.url && _t.readyState !== 0 && _t.readyState !== 2) {\r\n        _wDS('onURL', 1);\r\n        return _t;\r\n      }\r\n      _t._lastURL = _t.url;\r\n      _t.loaded = false;\r\n      _t.readyState = 1;\r\n      _t.playState = 0;\r\n      if (_html5OK(_t._iO)) {\r\n        oS = _t._setup_html5(_t._iO);\r\n        if (!oS._called_load) {\r\n          _s._wD(_h5+'load: '+_t.sID);\r\n          _t._html5_canplay = false;\r\n          oS.load();\r\n          oS._called_load = true;\r\n          if (_t._iO.autoPlay) {\r\n            _t.play();\r\n          }\r\n        } else {\r\n          _s._wD(_h5+'ignoring request to load again: '+_t.sID);\r\n        }\r\n      } else {\r\n        try {\r\n          _t.isHTML5 = false;\r\n          _t._iO = _policyFix(_loopFix(_t._iO));\r\n          if (_fV === 8) {\r\n            _s.o._load(_t.sID, _t._iO.url, _t._iO.stream, _t._iO.autoPlay, (_t._iO.whileloading?1:0), _t._iO.loops||1, _t._iO.usePolicyFile);\r\n          } else {\r\n            _s.o._load(_t.sID, _t._iO.url, _t._iO.stream?true:false, _t._iO.autoPlay?true:false, _t._iO.loops||1, _t._iO.autoLoad?true:false, _t._iO.usePolicyFile);\r\n          }\r\n        } catch(e) {\r\n          _wDS('smError', 2);\r\n          _debugTS('onload', false);\r\n          _catchError({type:'SMSOUND_LOAD_JS_EXCEPTION', fatal:true});\r\n        }\r\n      }\r\n      return _t;\r\n    };\r\n\r\n    this.unload = function() {\r\n      // Flash 8/AS2 can't \"close\" a stream - fake it by loading an empty MP3\r\n      // Flash 9/AS3: Close stream, preventing further load\r\n      if (_t.readyState !== 0) {\r\n        _s._wD('SMSound.unload(): \"' + _t.sID + '\"');\r\n        if (!_t.isHTML5) {\r\n          if (_fV === 8) {\r\n            _s.o._unload(_t.sID, _s.nullURL);\r\n          } else {\r\n            _s.o._unload(_t.sID);\r\n          }\r\n        } else {\r\n          _stop_html5_timer();\r\n          if (_t._a) {\r\n            // abort()-style method here, stop loading? (doesn't exist?)\r\n            _t._a.pause();\r\n            _t._a.src = ''; // https://developer.mozilla.org/En/Using_audio_and_video_in_Firefox#Stopping_the_download_of_media\r\n          }\r\n        }\r\n        // reset load/status flags\r\n        _resetProperties();\r\n      }\r\n      return _t;\r\n    };\r\n\r\n    this.destruct = function(_bFromSM) {\r\n      _s._wD('SMSound.destruct(): \"' + _t.sID + '\"');\r\n      if (!_t.isHTML5) {\r\n        // kill sound within Flash\r\n        // Disable the onfailure handler\r\n        _t._iO.onfailure = null;\r\n        _s.o._destroySound(_t.sID);\r\n      } else {\r\n        _stop_html5_timer();\r\n        if (_t._a) {\r\n          // abort()-style method here, stop loading? (doesn't exist?)\r\n          _t._a.pause();\r\n          _t._a.src = ''; // https://developer.mozilla.org/En/Using_audio_and_video_in_Firefox#Stopping_the_download_of_media\r\n          if (!_useGlobalHTML5Audio) {\r\n            _t._remove_html5_events();\r\n          }\r\n          _t._a._t = null; // break potential circular reference\r\n          _t._a = null;\r\n        }\r\n      }\r\n      if (!_bFromSM) {\r\n        _s.destroySound(_t.sID, true); // ensure deletion from controller\r\n      }\r\n    };\r\n\r\n    this.play = function(oOptions, _updatePlayState) {\r\n      var fN = 'SMSound.play(): ', allowMulti, a;\r\n      _updatePlayState = _updatePlayState === undefined ? true : _updatePlayState; // default to true\r\n      if (!oOptions) {\r\n        oOptions = {};\r\n      }\r\n      _t._iO = _mixin(oOptions, _t._iO);\r\n      _t._iO = _mixin(_t._iO, _t.options);\r\n      _t.instanceOptions = _t._iO;\r\n      if (_t._iO.serverURL && !_t.connected) {\r\n        if (!_t.getAutoPlay()) {\r\n          _s._wD(fN+' Netstream not connected yet - setting autoPlay');\r\n          _t.setAutoPlay(true);\r\n        }\r\n        return _t; // play will be called in _onconnect()\r\n      }\r\n      if (_html5OK(_t._iO)) {\r\n        _t._setup_html5(_t._iO);\r\n        _start_html5_timer();\r\n      }\r\n      if (_t.playState === 1 && !_t.paused) {\r\n        allowMulti = _t._iO.multiShot;\r\n        if (!allowMulti) {\r\n          _s._wD(fN + '\"' + _t.sID + '\" already playing (one-shot)', 1);\r\n          return _t;\r\n        } else {\r\n          _s._wD(fN + '\"' + _t.sID + '\" already playing (multi-shot)', 1);\r\n        }\r\n      }\r\n      if (!_t.loaded) {\r\n        if (_t.readyState === 0) {\r\n          _s._wD(fN + 'Attempting to load \"' + _t.sID + '\"', 1);\r\n          // try to get this sound playing ASAP\r\n          if (!_t.isHTML5) {\r\n            _t._iO.autoPlay = true; // assign directly because setAutoPlay() increments the instanceCount\r\n          }\r\n          _t.load(_t._iO);\r\n        } else if (_t.readyState === 2) {\r\n          _s._wD(fN + 'Could not load \"' + _t.sID + '\" - exiting', 2);\r\n          return _t;\r\n        } else {\r\n          _s._wD(fN + '\"' + _t.sID + '\" is loading - attempting to play..', 1);\r\n        }\r\n      } else {\r\n        _s._wD(fN + '\"' + _t.sID + '\"');\r\n      }\r\n      if (!_t.isHTML5 && _fV === 9 && _t.position > 0 && _t.position === _t.duration) {\r\n        // flash 9 needs a position reset if play() is called while at the end of a sound.\r\n        _s._wD(fN + '\"' + _t.sID + '\": Sound at end, resetting to position:0');\r\n        _t._iO.position = 0;\r\n      }\r\n      /*\r\n       * Streams will pause when their buffer is full if they are being loaded.\r\n       * In this case paused is true, but the song hasn't started playing yet.\r\n       * If we just call resume() the onplay() callback will never be called.\r\n       * So only call resume() if the position is > 0.\r\n       * Another reason is because options like volume won't have been applied yet.\r\n      */\r\n      if (_t.paused && _t.position && _t.position > 0) { // https://gist.github.com/37b17df75cc4d7a90bf6\r\n        _s._wD(fN + '\"' + _t.sID + '\" is resuming from paused state',1);\r\n        _t.resume();\r\n      } else {\r\n        _s._wD(fN+'\"'+ _t.sID+'\" is starting to play');\r\n        _t.playState = 1;\r\n        _t.paused = false;\r\n        if (!_t.instanceCount || _t._iO.multiShotEvents || (!_t.isHTML5 && _fV > 8 && !_t.getAutoPlay())) {\r\n          _t.instanceCount++;\r\n        }\r\n        _t.position = (typeof _t._iO.position !== 'undefined' && !isNaN(_t._iO.position)?_t._iO.position:0);\r\n        if (!_t.isHTML5) {\r\n          _t._iO = _policyFix(_loopFix(_t._iO));\r\n        }\r\n        if (_t._iO.onplay && _updatePlayState) {\r\n          _t._iO.onplay.apply(_t);\r\n          _t._onplay_called = true;\r\n        }\r\n        _t.setVolume(_t._iO.volume, true);\r\n        _t.setPan(_t._iO.pan, true);\r\n        if (!_t.isHTML5) {\r\n          _s.o._start(_t.sID, _t._iO.loops || 1, (_fV === 9?_t._iO.position:_t._iO.position / 1000));\r\n        } else {\r\n          _start_html5_timer();\r\n          a = _t._setup_html5();\r\n          _t.setPosition(_t._iO.position);\r\n          a.play();\r\n        }\r\n      }\r\n      return _t;\r\n    };\r\n\r\n    this.start = this.play; // just for convenience\r\n\r\n    this.stop = function(bAll) {\r\n      if (_t.playState === 1) {\r\n        _t._onbufferchange(0);\r\n        _t.resetOnPosition(0);\r\n        if (!_t.isHTML5) {\r\n          _t.playState = 0;\r\n        }\r\n        _t.paused = false;\r\n        if (_t._iO.onstop) {\r\n          _t._iO.onstop.apply(_t);\r\n        }\r\n        if (!_t.isHTML5) {\r\n          _s.o._stop(_t.sID, bAll);\r\n          // hack for netStream: just unload\r\n          if (_t._iO.serverURL) {\r\n            _t.unload();\r\n          }\r\n        } else {\r\n          if (_t._a) {\r\n            _t.setPosition(0); // act like Flash, though\r\n            _t._a.pause(); // html5 has no stop()\r\n            _t.playState = 0;\r\n            _t._onTimer(); // and update UI\r\n            _stop_html5_timer();\r\n            _t.unload();\r\n          }\r\n        }\r\n        _t.instanceCount = 0;\r\n        _t._iO = {};\r\n      }\r\n      return _t;\r\n    };\r\n\r\n    this.setAutoPlay = function(autoPlay) {\r\n      _s._wD('sound '+_t.sID+' turned autoplay ' + (autoPlay ? 'on' : 'off'));\r\n      _t._iO.autoPlay = autoPlay;\r\n      if (!_t.isHTML5) {\r\n        _s.o._setAutoPlay(_t.sID, autoPlay);\r\n        if (autoPlay) {\r\n          // only increment the instanceCount if the sound isn't loaded (TODO: verify RTMP)\r\n          if (!_t.instanceCount && _t.readyState === 1) {\r\n            _t.instanceCount++;\r\n            _s._wD('sound '+_t.sID+' incremented instance count to '+_t.instanceCount);\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    this.getAutoPlay = function() {\r\n      return _t._iO.autoPlay;\r\n    };\r\n\r\n    this.setPosition = function(nMsecOffset) {\r\n      if (nMsecOffset === undefined) {\r\n        nMsecOffset = 0;\r\n      }\r\n      // Use the duration from the instance options, if we don't have a track duration yet.\r\n      var original_pos, position, position1K,\r\n          offset = (_t.isHTML5 ? Math.max(nMsecOffset,0) : Math.min(_t.duration || _t._iO.duration, Math.max(nMsecOffset, 0))); // position >= 0 and <= current available (loaded) duration\r\n      original_pos = _t.position;\r\n      _t.position = offset;\r\n      position1K = _t.position/1000;\r\n      _t.resetOnPosition(_t.position);\r\n      _t._iO.position = offset;\r\n      if (!_t.isHTML5) {\r\n        position = (_fV === 9 ? _t.position : position1K);\r\n        if (_t.readyState && _t.readyState !== 2) {\r\n          _s.o._setPosition(_t.sID, position, (_t.paused || !_t.playState)); // if paused or not playing, will not resume (by playing)\r\n        }\r\n      } else if (_t._a) {\r\n        // Set the position in the canplay handler if the sound is not ready yet\r\n        if (_t._html5_canplay) {\r\n          if (_t._a.currentTime !== position1K) {\r\n            /*\r\n             * DOM/JS errors/exceptions to watch out for:\r\n             * if seek is beyond (loaded?) position, \"DOM exception 11\"\r\n             * \"INDEX_SIZE_ERR\": DOM exception 1\r\n            */\r\n            _s._wD('setPosition('+position1K+'): setting position');\r\n            try {\r\n              _t._a.currentTime = position1K;\r\n              if (_t.playState === 0 || _t.paused) {\r\n                // allow seek without auto-play/resume\r\n                _t._a.pause();\r\n              }\r\n            } catch(e) {\r\n              _s._wD('setPosition('+position1K+'): setting position failed: '+e.message, 2);\r\n            }\r\n          }\r\n        } else {\r\n          _s._wD('setPosition('+position1K+'): delaying, sound not ready');\r\n        }\r\n      }\r\n      if (_t.isHTML5) {\r\n        if (_t.paused) { // if paused, refresh UI right away\r\n          _t._onTimer(true); // force update\r\n        }\r\n      }\r\n      return _t;\r\n    };\r\n\r\n    this.pause = function(bCallFlash) {\r\n      if (_t.paused || (_t.playState === 0 && _t.readyState !== 1)) {\r\n        return _t;\r\n      }\r\n      _s._wD('SMSound.pause()');\r\n      _t.paused = true;\r\n      if (!_t.isHTML5) {\r\n        if (bCallFlash || bCallFlash === undefined) {\r\n          _s.o._pause(_t.sID);\r\n        }\r\n      } else {\r\n        _t._setup_html5().pause();\r\n        _stop_html5_timer();\r\n      }\r\n      if (_t._iO.onpause) {\r\n        _t._iO.onpause.apply(_t);\r\n      }\r\n      return _t;\r\n    };\r\n\r\n    /*\r\n     * When auto-loaded streams pause on buffer full they have a playState of 0.\r\n     * We need to make sure that the playState is set to 1 when these streams \"resume\".\r\n     * When a paused stream is resumed, we need to trigger the onplay() callback if it\r\n     * hasn't been called already. In this case since the sound is being played for the\r\n     * first time, I think it's more appropriate to call onplay() rather than onresume().\r\n    */\r\n    this.resume = function() {\r\n      if (!_t.paused) {\r\n        return _t;\r\n      }\r\n      _s._wD('SMSound.resume()');\r\n      _t.paused = false;\r\n      _t.playState = 1;\r\n      if (!_t.isHTML5) {\r\n        if (_t._iO.isMovieStar) {\r\n          // Bizarre Webkit bug (Chrome reported via 8tracks.com dudes): AAC content paused for 30+ seconds(?) will not resume without a reposition.\r\n          _t.setPosition(_t.position);\r\n        }\r\n        _s.o._pause(_t.sID); // flash method is toggle-based (pause/resume)\r\n      } else {\r\n        _t._setup_html5().play();\r\n        _start_html5_timer();\r\n      }\r\n      if (!_t._onplay_called && _t._iO.onplay) {\r\n        _t._iO.onplay.apply(_t);\r\n        _t._onplay_called = true;\r\n      } else if (_t._iO.onresume) {\r\n        _t._iO.onresume.apply(_t);\r\n      }\r\n      return _t;\r\n    };\r\n\r\n    this.togglePause = function() {\r\n      _s._wD('SMSound.togglePause()');\r\n      if (_t.playState === 0) {\r\n        _t.play({\r\n          position: (_fV === 9 && !_t.isHTML5 ? _t.position : _t.position / 1000)\r\n        });\r\n        return _t;\r\n      }\r\n      if (_t.paused) {\r\n        _t.resume();\r\n      } else {\r\n        _t.pause();\r\n      }\r\n      return _t;\r\n    };\r\n\r\n    this.setPan = function(nPan, bInstanceOnly) {\r\n      if (typeof nPan === 'undefined') {\r\n        nPan = 0;\r\n      }\r\n      if (typeof bInstanceOnly === 'undefined') {\r\n        bInstanceOnly = false;\r\n      }\r\n      if (!_t.isHTML5) {\r\n        _s.o._setPan(_t.sID, nPan);\r\n      } // else { no HTML5 pan? }\r\n      _t._iO.pan = nPan;\r\n      if (!bInstanceOnly) {\r\n        _t.pan = nPan;\r\n        _t.options.pan = nPan;\r\n      }\r\n      return _t;\r\n    };\r\n\r\n    this.setVolume = function(nVol, bInstanceOnly) {\r\n      if (typeof nVol === 'undefined') {\r\n        nVol = 100;\r\n      }\r\n      if (typeof bInstanceOnly === 'undefined') {\r\n        bInstanceOnly = false;\r\n      }\r\n      if (!_t.isHTML5) {\r\n        _s.o._setVolume(_t.sID, (_s.muted && !_t.muted) || _t.muted?0:nVol);\r\n      } else if (_t._a) {\r\n        _t._a.volume = Math.max(0, Math.min(1, nVol/100)); // valid range: 0-1\r\n      }\r\n      _t._iO.volume = nVol;\r\n      if (!bInstanceOnly) {\r\n        _t.volume = nVol;\r\n        _t.options.volume = nVol;\r\n      }\r\n      return _t;\r\n    };\r\n\r\n    this.mute = function() {\r\n      _t.muted = true;\r\n      if (!_t.isHTML5) {\r\n        _s.o._setVolume(_t.sID, 0);\r\n      } else if (_t._a) {\r\n        _t._a.muted = true;\r\n      }\r\n      return _t;\r\n    };\r\n\r\n    this.unmute = function() {\r\n      _t.muted = false;\r\n      var hasIO = typeof _t._iO.volume !== 'undefined';\r\n      if (!_t.isHTML5) {\r\n        _s.o._setVolume(_t.sID, hasIO?_t._iO.volume:_t.options.volume);\r\n      } else if (_t._a) {\r\n        _t._a.muted = false;\r\n      }\r\n      return _t;\r\n    };\r\n\r\n    this.toggleMute = function() {\r\n      return (_t.muted?_t.unmute():_t.mute());\r\n    };\r\n\r\n    this.onposition = function(nPosition, oMethod, oScope) {\r\n      // TODO: allow for ranges, too? eg. (nPosition instanceof Array)\r\n      _t._onPositionItems.push({\r\n        position: nPosition,\r\n        method: oMethod,\r\n        scope: (typeof oScope !== 'undefined'?oScope:_t),\r\n        fired: false\r\n      });\r\n      return _t;\r\n    };\r\n\r\n    this.processOnPosition = function() {\r\n      var i, item, j = _t._onPositionItems.length;\r\n      if (!j || !_t.playState || _t._onPositionFired >= j) {\r\n        return false;\r\n      }\r\n      for (i=j; i--;) {\r\n        item = _t._onPositionItems[i];\r\n        if (!item.fired && _t.position >= item.position) {\r\n          item.method.apply(item.scope,[item.position]);\r\n          item.fired = true;\r\n          _s._onPositionFired++;\r\n        }\r\n      }\r\n      return true;\r\n    };\r\n\r\n    this.resetOnPosition = function(nPosition) {\r\n      // reset \"fired\" for items interested in this position\r\n      var i, item, j = _t._onPositionItems.length;\r\n      if (!j) {\r\n        return false;\r\n      }\r\n      for (i=j; i--;) {\r\n        item = _t._onPositionItems[i];\r\n        if (item.fired && nPosition <= item.position) {\r\n          item.fired = false;\r\n          _s._onPositionFired--;\r\n        }\r\n      }\r\n      return true;\r\n    };\r\n\r\n    /*\r\n     * private internals\r\n    */\r\n\r\n    _start_html5_timer = function() {\r\n      if (_t.isHTML5) {\r\n        _startTimer(_t);\r\n      }\r\n    };\r\n\r\n    _stop_html5_timer = function() {\r\n      if (_t.isHTML5) {\r\n        _stopTimer(_t);\r\n      }\r\n    };\r\n\r\n    _resetProperties = function() {\r\n      _t._onPositionItems = [];\r\n      _t._onPositionFired = 0;\r\n      _t._hasTimer = null;\r\n      _t._onplay_called = false;\r\n      _t._a = null;\r\n      _t._html5_canplay = false;\r\n      _t.bytesLoaded = null;\r\n      _t.bytesTotal = null;\r\n      _t.position = null;\r\n      _t.duration = (_t._iO && _t._iO.duration?_t._iO.duration:null);\r\n      _t.durationEstimate = null;\r\n      _t.failures = 0;\r\n      _t.loaded = false;\r\n      _t.playState = 0;\r\n      _t.paused = false;\r\n      _t.readyState = 0; // 0 = uninitialised, 1 = loading, 2 = failed/error, 3 = loaded/success\r\n      _t.muted = false;\r\n      _t.didBeforeFinish = false;\r\n      _t.didJustBeforeFinish = false;\r\n      _t.isBuffering = false;\r\n      _t.instanceOptions = {};\r\n      _t.instanceCount = 0;\r\n      _t.peakData = {\r\n        left: 0,\r\n        right: 0\r\n      };\r\n      _t.waveformData = {\r\n        left: [],\r\n        right: []\r\n      };\r\n      _t.eqData = []; // legacy: 1D array\r\n      _t.eqData.left = [];\r\n      _t.eqData.right = [];\r\n    };\r\n\r\n    _resetProperties();\r\n\r\n    /*\r\n     * pseudo-private SMSound internals\r\n    */\r\n\r\n    this._onTimer = function(bForce) {\r\n      // HTML5-only _whileplaying() etc.\r\n      var time, x = {};\r\n      if (_t._hasTimer || bForce) {\r\n        if (_t._a && (bForce || ((_t.playState > 0 || _t.readyState === 1) && !_t.paused))) { // TODO: May not need to track readyState (1 = loading)\r\n          _t.duration = _t._get_html5_duration();\r\n          _t.durationEstimate = _t.duration;\r\n          time = _t._a.currentTime?_t._a.currentTime*1000:0;\r\n          _t._whileplaying(time,x,x,x,x);\r\n          return true;\r\n        } else {\r\n         _s._wD('_onTimer: Warn for \"'+_t.sID+'\": '+(!_t._a?'Could not find element. ':'')+(_t.playState === 0?'playState bad, 0?':'playState = '+_t.playState+', OK'));\r\n          return false;\r\n        }\r\n      }\r\n    };\r\n\r\n    this._get_html5_duration = function() {\r\n      var d = (_t._a ? _t._a.duration*1000 : (_t._iO ? _t._iO.duration : undefined)),\r\n          result = (d && !isNaN(d) && d !== Infinity ? d : (_t._iO ? _t._iO.duration : null));\r\n      return result;\r\n    };\r\n\r\n    this._setup_html5 = function(oOptions) {\r\n      var _iO = _mixin(_t._iO, oOptions), d = decodeURI,\r\n          _a = _useGlobalHTML5Audio ? _s._global_a : _t._a,\r\n          _dURL = d(_iO.url),\r\n          _oldIO = (_a && _a._t ? _a._t.instanceOptions : null);\r\n      if (_a) {\r\n        if (_a._t && _oldIO.url === _iO.url && (!_t._lastURL || (_t._lastURL === _oldIO.url))) {\r\n          return _a; // same url, ignore request\r\n        }\r\n        _s._wD('setting new URL on existing object: ' + _dURL + (_t._lastURL ? ', old URL: ' + _t._lastURL : ''));\r\n        /*\r\n         * \"First things first, I, Poppa..\" (reset the previous state of the old sound, if playing)\r\n         * Fixes case with devices that can only play one sound at a time\r\n         * Otherwise, other sounds in mid-play will be terminated without warning and in a stuck state\r\n        */\r\n        if (_useGlobalHTML5Audio && _a._t && _a._t.playState && _iO.url !== _oldIO.url) {\r\n          _a._t.stop();\r\n        }\r\n        _resetProperties(); // new URL, so reset load/playstate and so on\r\n        _a.src = _iO.url;\r\n        _t.url = _iO.url;\r\n        _t._lastURL = _iO.url;\r\n        _a._called_load = false;\r\n      } else {\r\n        _s._wD('creating HTML5 Audio() element with URL: '+_dURL);\r\n        _a = new Audio(_iO.url);\r\n        _a._called_load = false;\r\n        if (_useGlobalHTML5Audio) {\r\n          _s._global_a = _a;\r\n        }\r\n      }\r\n      _t.isHTML5 = true;\r\n      _t._a = _a; // store a ref on the track\r\n      _a._t = _t; // store a ref on the audio\r\n      _t._add_html5_events();\r\n      _a.loop = (_iO.loops>1?'loop':'');\r\n      if (_iO.autoLoad || _iO.autoPlay) {\r\n        _a.autobuffer = 'auto'; // early HTML5 implementation (non-standard)\r\n        _a.preload = 'auto'; // standard\r\n        _t.load();\r\n        _a._called_load = true;\r\n      } else {\r\n        _a.autobuffer = false; // early HTML5 implementation (non-standard)\r\n        _a.preload = 'none'; // standard\r\n      }\r\n      _a.loop = (_iO.loops>1?'loop':''); // boolean instead of \"loop\", for webkit? - spec says string. http://www.w3.org/TR/html-markup/audio.html#audio.attrs.loop\r\n      return _a;\r\n    };\r\n\r\n    this._add_html5_events = function() {\r\n\r\n      if (_t._a._added_events) {\r\n        return false;\r\n      }\r\n\r\n      var f;\r\n\r\n      function add(oEvt, oFn, bCapture) {\r\n        return _t._a ? _t._a.addEventListener(oEvt, oFn, bCapture||false) : null;\r\n      }\r\n\r\n      _s._wD(_h5+'adding event listeners: '+_t.sID);\r\n      _t._a._added_events = true;\r\n\r\n      for (f in _html5_events) {\r\n        if (_html5_events.hasOwnProperty(f)) {\r\n          add(f, _html5_events[f]);\r\n        }\r\n      }\r\n\r\n      return true;\r\n\r\n    };\r\n\r\n    this._remove_html5_events = function() {\r\n\r\n      // Remove event listeners\r\n\r\n      var f;\r\n\r\n      function remove(oEvt, oFn, bCapture) {\r\n        return (_t._a ? _t._a.removeEventListener(oEvt, oFn, bCapture||false) : null);\r\n      }\r\n\r\n      _s._wD(_h5+'removing event listeners: '+_t.sID);\r\n      _t._a._added_events = false;\r\n\r\n      for (f in _html5_events) {\r\n        if (_html5_events.hasOwnProperty(f)) {\r\n          remove(f, _html5_events[f]);\r\n        }\r\n      }\r\n\r\n    };\r\n\r\n    /*\r\n     * pseudo-private event internals\r\n    */\r\n\r\n    this._onload = function(nSuccess) {\r\n      var fN = 'SMSound._onload(): ', loadOK = (nSuccess?true:false);\r\n      _s._wD(fN + '\"' + _t.sID + '\"' + (loadOK?' loaded.':' failed to load? - ' + _t.url), (loadOK?1:2));\r\n      // <d>\r\n      if (!loadOK && !_t.isHTML5) {\r\n        if (_s.sandbox.noRemote === true) {\r\n          _s._wD(fN + _str('noNet'), 1);\r\n        }\r\n        if (_s.sandbox.noLocal === true) {\r\n          _s._wD(fN + _str('noLocal'), 1);\r\n        }\r\n      }\r\n      // </d>\r\n      _t.loaded = loadOK;\r\n      _t.readyState = loadOK?3:2;\r\n      _t._onbufferchange(0);\r\n      if (_t._iO.onload) {\r\n        _t._iO.onload.apply(_t, [loadOK]);\r\n      }\r\n      return true;\r\n    };\r\n\r\n    this._onbufferchange = function(nIsBuffering) {\r\n      var fN = 'SMSound._onbufferchange()';\r\n      if (_t.playState === 0) {\r\n        // ignore if not playing\r\n        return false;\r\n      }\r\n      if ((nIsBuffering && _t.isBuffering) || (!nIsBuffering && !_t.isBuffering)) {\r\n        return false;\r\n      }\r\n      _t.isBuffering = (nIsBuffering === 1);\r\n      if (_t._iO.onbufferchange) {\r\n        _s._wD(fN + ': ' + nIsBuffering);\r\n        _t._iO.onbufferchange.apply(_t);\r\n      }\r\n      return true;\r\n    };\r\n\r\n    /*\r\n     * flash-only method, should fire only once at most\r\n     * at this point we just recreate failed sounds rather than trying to reconnect\r\n    */\r\n    this._onfailure = function(msg, level, code) {\r\n      _t.failures++;\r\n      _s._wD('SMSound._onfailure(): \"'+_t.sID+'\" count '+_t.failures);\r\n      if (_t._iO.onfailure && _t.failures === 1) {\r\n        _t._iO.onfailure(_t, msg, level, code);\r\n      } else {\r\n        _s._wD('SMSound._onfailure(): ignoring');\r\n      }\r\n    };\r\n\r\n    this._onbeforefinish = function() {\r\n      if (!_t.didBeforeFinish) {\r\n        _t.didBeforeFinish = true;\r\n        if (_t._iO.onbeforefinish) {\r\n          _s._wD('SMSound._onbeforefinish(): \"' + _t.sID + '\"');\r\n          _t._iO.onbeforefinish.apply(_t);\r\n        }\r\n      }\r\n    };\r\n\r\n    this._onjustbeforefinish = function(msOffset) {\r\n      if (!_t.didJustBeforeFinish) {\r\n        _t.didJustBeforeFinish = true;\r\n        if (_t._iO.onjustbeforefinish) {\r\n          _s._wD('SMSound._onjustbeforefinish(): \"' + _t.sID + '\"');\r\n          _t._iO.onjustbeforefinish.apply(_t);\r\n        }\r\n      }\r\n    };\r\n\r\n    this._onfinish = function() {\r\n      var _io_onfinish = _t._iO.onfinish; // store local copy before it gets trashed..\r\n      _t._onbufferchange(0);\r\n      _t.resetOnPosition(0);\r\n      if (_t._iO.onbeforefinishcomplete) {\r\n        _t._iO.onbeforefinishcomplete.apply(_t);\r\n      }\r\n      // reset some state items\r\n      _t.didBeforeFinish = false;\r\n      _t.didJustBeforeFinish = false;\r\n      if (_t.instanceCount) {\r\n        _t.instanceCount--;\r\n        if (!_t.instanceCount) {\r\n          // reset instance options\r\n          _t.playState = 0;\r\n          _t.paused = false;\r\n          _t.instanceCount = 0;\r\n          _t.instanceOptions = {};\r\n          _t._iO = {};\r\n          _stop_html5_timer();\r\n        }\r\n        if (!_t.instanceCount || _t._iO.multiShotEvents) {\r\n          // fire onfinish for last, or every instance\r\n          if (_io_onfinish) {\r\n            _s._wD('SMSound._onfinish(): \"' + _t.sID + '\"');\r\n            _io_onfinish.apply(_t);\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    this._whileloading = function(nBytesLoaded, nBytesTotal, nDuration, nBufferLength) {\r\n      _t.bytesLoaded = nBytesLoaded;\r\n      _t.bytesTotal = nBytesTotal;\r\n      _t.duration = Math.floor(nDuration);\r\n      _t.bufferLength = nBufferLength;\r\n      if (!_t._iO.isMovieStar) {\r\n        if (_t._iO.duration) {\r\n          // use options, if specified and larger\r\n          _t.durationEstimate = (_t.duration > _t._iO.duration) ? _t.duration : _t._iO.duration;\r\n        } else {\r\n          _t.durationEstimate = parseInt((_t.bytesTotal / _t.bytesLoaded) * _t.duration, 10);\r\n        }\r\n        if (_t.durationEstimate === undefined) {\r\n          _t.durationEstimate = _t.duration;\r\n        }\r\n        if (_t.readyState !== 3 && _t._iO.whileloading) {\r\n          _t._iO.whileloading.apply(_t);\r\n        }\r\n      } else {\r\n        _t.durationEstimate = _t.duration;\r\n        if (_t.readyState !== 3 && _t._iO.whileloading) {\r\n          _t._iO.whileloading.apply(_t);\r\n        }\r\n      }\r\n    };\r\n\r\n    this._whileplaying = function(nPosition, oPeakData, oWaveformDataLeft, oWaveformDataRight, oEQData) {\r\n      if (isNaN(nPosition) || nPosition === null) {\r\n        return false; // flash safety net\r\n      }\r\n      _t.position = nPosition;\r\n      _t.processOnPosition();\r\n      if (!_t.isHTML5 && _fV > 8) {\r\n        if (_t._iO.usePeakData && typeof oPeakData !== 'undefined' && oPeakData) {\r\n          _t.peakData = {\r\n            left: oPeakData.leftPeak,\r\n            right: oPeakData.rightPeak\r\n          };\r\n        }\r\n        if (_t._iO.useWaveformData && typeof oWaveformDataLeft !== 'undefined' && oWaveformDataLeft) {\r\n          _t.waveformData = {\r\n            left: oWaveformDataLeft.split(','),\r\n            right: oWaveformDataRight.split(',')\r\n          };\r\n        }\r\n        if (_t._iO.useEQData) {\r\n          if (typeof oEQData !== 'undefined' && oEQData && oEQData.leftEQ) {\r\n            var eqLeft = oEQData.leftEQ.split(',');\r\n            _t.eqData = eqLeft;\r\n            _t.eqData.left = eqLeft;\r\n            if (typeof oEQData.rightEQ !== 'undefined' && oEQData.rightEQ) {\r\n              _t.eqData.right = oEQData.rightEQ.split(',');\r\n            }\r\n          }\r\n        }\r\n      }\r\n      if (_t.playState === 1) {\r\n        // special case/hack: ensure buffering is false if loading from cache (and not yet started)\r\n        if (!_t.isHTML5 && _s.flashVersion === 8 && !_t.position && _t.isBuffering) {\r\n          _t._onbufferchange(0);\r\n        }\r\n        if (_t._iO.whileplaying) {\r\n          _t._iO.whileplaying.apply(_t); // flash may call after actual finish\r\n        }\r\n        if ((_t.loaded || (!_t.loaded && _t._iO.isMovieStar)) && _t._iO.onbeforefinish && _t._iO.onbeforefinishtime && !_t.didBeforeFinish && _t.duration - _t.position <= _t._iO.onbeforefinishtime) {\r\n          _t._onbeforefinish();\r\n        }\r\n      }\r\n      return true;\r\n    };\r\n\r\n    this._onid3 = function(oID3PropNames, oID3Data) {\r\n      // oID3PropNames: string array (names)\r\n      // ID3Data: string array (data)\r\n      _s._wD('SMSound._onid3(): \"' + this.sID + '\" ID3 data received.');\r\n      var oData = [], i, j;\r\n      for (i = 0, j = oID3PropNames.length; i < j; i++) {\r\n        oData[oID3PropNames[i]] = oID3Data[i];\r\n      }\r\n      _t.id3 = _mixin(_t.id3, oData);\r\n      if (_t._iO.onid3) {\r\n        _t._iO.onid3.apply(_t);\r\n      }\r\n    };\r\n\r\n    // flash + RTMP\r\n    this._onconnect = function(bSuccess) {\r\n      var fN = 'SMSound._onconnect(): ';\r\n      bSuccess = (bSuccess === 1);\r\n      _s._wD(fN+'\"'+_t.sID+'\"'+(bSuccess?' connected.':' failed to connect? - '+_t.url), (bSuccess?1:2));\r\n      _t.connected = bSuccess;\r\n      if (bSuccess) {\r\n        _t.failures = 0;\r\n        if (_idCheck(_t.sID)) {\r\n          if (_t.getAutoPlay()) {\r\n            _t.play(undefined, _t.getAutoPlay()); // only update the play state if auto playing\r\n          } else if (_t._iO.autoLoad) {\r\n            _t.load();\r\n          }\r\n        }\r\n        if (_t._iO.onconnect) {\r\n          _t._iO.onconnect.apply(_t,[bSuccess]);\r\n        }\r\n      }\r\n    };\r\n\r\n    this._ondataerror = function(sError) {\r\n      // flash 9 wave/eq data handler\r\n      if (_t.playState > 0) { // hack: called at start, and end from flash at/after onfinish()\r\n        _s._wD('SMSound._ondataerror(): ' + sError);\r\n        if (_t._iO.ondataerror) {\r\n          _t._iO.ondataerror.apply(_t);\r\n        }\r\n      }\r\n    };\r\n\r\n  }; // SMSound()\r\n\r\n  /*\r\n   * private soundManager internals\r\n  */\r\n\r\n  _getDocument = function() {\r\n    return (_doc.body || _doc._docElement || _doc.getElementsByTagName('div')[0]);\r\n  };\r\n\r\n  _id = function(sID) {\r\n    return _doc.getElementById(sID);\r\n  };\r\n\r\n  _mixin = function(oMain, oAdd) {\r\n    // non-destructive merge\r\n    var o1 = {}, i, o2, o;\r\n    for (i in oMain) { // clone c1\r\n      if (oMain.hasOwnProperty(i)) {\r\n        o1[i] = oMain[i];\r\n      }\r\n    }\r\n    o2 = (typeof oAdd === 'undefined'?_s.defaultOptions:oAdd);\r\n    for (o in o2) {\r\n      if (o2.hasOwnProperty(o) && typeof o1[o] === 'undefined') {\r\n        o1[o] = o2[o];\r\n      }\r\n    }\r\n    return o1;\r\n  };\r\n\r\n  _event = (function() {\r\n\r\n    var old = (_win.attachEvent),\r\n    evt = {\r\n      add: (old?'attachEvent':'addEventListener'),\r\n      remove: (old?'detachEvent':'removeEventListener')\r\n    };\r\n\r\n    function getArgs(oArgs) {\r\n      var args = _slice.call(oArgs), len = args.length;\r\n      if (old) {\r\n        args[1] = 'on' + args[1]; // prefix\r\n        if (len > 3) {\r\n          args.pop(); // no capture\r\n        }\r\n      } else if (len === 3) {\r\n        args.push(false);\r\n      }\r\n      return args;\r\n    }\r\n\r\n    function apply(args, sType) {\r\n      var element = args.shift(),\r\n          method = [evt[sType]];\r\n      if (old) {\r\n        element[method](args[0], args[1]);\r\n      } else {\r\n        element[method].apply(element, args);\r\n      }\r\n    }\r\n\r\n    function add() {\r\n      apply(getArgs(arguments), 'add');\r\n    }\r\n\r\n    function remove() {\r\n      apply(getArgs(arguments), 'remove');\r\n    }\r\n\r\n    return {\r\n      'add': add,\r\n      'remove': remove\r\n    };\r\n\r\n  }());\r\n\r\n  _html5OK = function(iO) {\r\n    return (!iO.serverURL && (iO.type?_html5CanPlay({type:iO.type}):_html5CanPlay({url:iO.url})||_s.html5Only)); // Use type, if specified. If HTML5-only mode, no other options, so just give 'er\r\n  };\r\n\r\n  _html5CanPlay = function(o) {\r\n\r\n    /*\r\n     * try to find MIME, test and return truthiness\r\n     * o = {\r\n     *  url: '/path/to/an.mp3',\r\n     *  type: 'audio/mp3'\r\n     * }\r\n    */\r\n\r\n    if (!_s.useHTML5Audio || !_s.hasHTML5) {\r\n      return false;\r\n    }\r\n\r\n    var url = (o.url || null),\r\n        mime = (o.type || null),\r\n        aF = _s.audioFormats,\r\n        result,\r\n        offset,\r\n        fileExt,\r\n        item;\r\n\r\n    function preferFlashCheck(kind) {\r\n      // whether flash should play a given type\r\n      return (_s.preferFlash && _hasFlash && !_s.ignoreFlash && (typeof _s.flash[kind] !== 'undefined' && _s.flash[kind]));\r\n    }\r\n\r\n    // account for known cases like audio/mp3\r\n    if (mime && _s.html5[mime] !== 'undefined') {\r\n      return (_s.html5[mime] && !preferFlashCheck(mime));\r\n    }\r\n\r\n    if (!_html5Ext) {\r\n      _html5Ext = [];\r\n      for (item in aF) {\r\n        if (aF.hasOwnProperty(item)) {\r\n          _html5Ext.push(item);\r\n          if (aF[item].related) {\r\n            _html5Ext = _html5Ext.concat(aF[item].related);\r\n          }\r\n        }\r\n      }\r\n      _html5Ext = new RegExp('\\\\.('+_html5Ext.join('|')+')(\\\\?.*)?$','i');\r\n    }\r\n\r\n    fileExt = (url ? url.toLowerCase().match(_html5Ext) : null); // TODO: Strip URL queries, etc.\r\n\r\n    if (!fileExt || !fileExt.length) {\r\n      if (!mime) {\r\n        return false;\r\n      } else {\r\n        // audio/mp3 -> mp3, result should be known\r\n        offset = mime.indexOf(';');\r\n        fileExt = (offset !== -1?mime.substr(0,offset):mime).substr(6); // strip \"audio/X; codecs..\"\r\n      }\r\n    } else {\r\n      fileExt = fileExt[1]; // match the raw extension name - \"mp3\", for example\r\n    }\r\n\r\n    if (fileExt && typeof _s.html5[fileExt] !== 'undefined') {\r\n      // result known\r\n      return (_s.html5[fileExt] && !preferFlashCheck(fileExt));\r\n    } else {\r\n      mime = 'audio/'+fileExt;\r\n      result = _s.html5.canPlayType({type:mime});\r\n      _s.html5[fileExt] = result;\r\n      // _s._wD('canPlayType, found result: '+result);\r\n      return (result && _s.html5[mime] && !preferFlashCheck(mime));\r\n    }\r\n\r\n  };\r\n\r\n  _testHTML5 = function() {\r\n\r\n    if (!_s.useHTML5Audio || typeof Audio === 'undefined') {\r\n      return false;\r\n    }\r\n\r\n    // double-whammy: Opera 9.64 throws WRONG_ARGUMENTS_ERR if no parameter passed to Audio(), and Webkit + iOS happily tries to load \"null\" as a URL. :/\r\n    var a = (typeof Audio !== 'undefined' ? (_isOpera ? new Audio(null) : new Audio()) : null),\r\n        item, support = {}, aF, i;\r\n\r\n    function _cp(m) {\r\n      var canPlay, i, j, isOK = false;\r\n      if (!a || typeof a.canPlayType !== 'function') {\r\n        return false;\r\n      }\r\n      if (m instanceof Array) {\r\n        // iterate through all mime types, return any successes\r\n        for (i=0, j=m.length; i<j && !isOK; i++) {\r\n          if (_s.html5[m[i]] || a.canPlayType(m[i]).match(_s.html5Test)) {\r\n            isOK = true;\r\n            _s.html5[m[i]] = true;\r\n            // if flash can play and preferred, also mark it for use.\r\n            _s.flash[m[i]] = !!(_s.preferFlash && _hasFlash && m[i].match(_flashMIME));\r\n          }\r\n        }\r\n        return isOK;\r\n      } else {\r\n        canPlay = (a && typeof a.canPlayType === 'function' ? a.canPlayType(m) : false);\r\n        return !!(canPlay && (canPlay.match(_s.html5Test)));\r\n      }\r\n    }\r\n\r\n    // test all registered formats + codecs\r\n    aF = _s.audioFormats;\r\n    for (item in aF) {\r\n      if (aF.hasOwnProperty(item)) {\r\n        support[item] = _cp(aF[item].type);\r\n        support['audio/'+item] = support[item]; // write back generic type too, eg. audio/mp3\r\n        // assign flash\r\n        if (_s.preferFlash && !_s.ignoreFlash && item.match(_flashMIME)) {\r\n          _s.flash[item] = true;\r\n        } else {\r\n          _s.flash[item] = false;\r\n        }\r\n        // assign result to related formats, too\r\n        if (aF[item] && aF[item].related) {\r\n          for (i=aF[item].related.length; i--;) {\r\n            support['audio/'+aF[item].related[i]] = support[item]; // eg. audio/m4a\r\n            _s.html5[aF[item].related[i]] = support[item];\r\n            _s.flash[aF[item].related[i]] = support[item];\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    support.canPlayType = (a?_cp:null);\r\n    _s.html5 = _mixin(_s.html5, support);\r\n    return true;\r\n\r\n  };\r\n\r\n  _strings = {\r\n    // <d>\r\n    notReady: 'Not loaded yet - wait for soundManager.onload()/onready()',\r\n    notOK: 'Audio support is not available.',\r\n    domError: _smc + 'createMovie(): appendChild/innerHTML call failed. DOM not ready or other error.',\r\n    spcWmode: _smc + 'createMovie(): Removing wmode, preventing known SWF loading issue(s)',\r\n    swf404: _sm + ': Verify that %s is a valid path.',\r\n    tryDebug: 'Try ' + _sm + '.debugFlash = true for more security details (output goes to SWF.)',\r\n    checkSWF: 'See SWF output for more debug info.',\r\n    localFail: _sm + ': Non-HTTP page (' + _doc.location.protocol + ' URL?) Review Flash player security settings for this special case:\\nhttp://www.macromedia.com/support/documentation/en/flashplayer/help/settings_manager04.html\\nMay need to add/allow path, eg. c:/sm2/ or /users/me/sm2/',\r\n    waitFocus: _sm + ': Special case: Waiting for focus-related event..',\r\n    waitImpatient: _sm + ': Getting impatient, still waiting for Flash%s...',\r\n    waitForever: _sm + ': Waiting indefinitely for Flash (will recover if unblocked)...',\r\n    needFunction: _sm + ': Function object expected for %s',\r\n    badID: 'Warning: Sound ID \"%s\" should be a string, starting with a non-numeric character',\r\n    noMS: 'MovieStar mode not enabled. Exiting.',\r\n    currentObj: '--- ' + _sm + '._debug(): Current sound objects ---',\r\n    waitEI: _smc + 'initMovie(): Waiting for ExternalInterface call from Flash..',\r\n    waitOnload: _sm + ': Waiting for window.onload()',\r\n    docLoaded: _sm + ': Document already loaded',\r\n    onload: _smc + 'initComplete(): calling soundManager.onload()',\r\n    onloadOK: _sm + '.onload() complete',\r\n    init: _smc + 'init()',\r\n    didInit: _smc + 'init(): Already called?',\r\n    flashJS: _sm + ': Attempting to call Flash from JS..',\r\n    noPolling: _sm + ': Polling (whileloading()/whileplaying() support) is disabled.',\r\n    secNote: 'Flash security note: Network/internet URLs will not load due to security restrictions. Access can be configured via Flash Player Global Security Settings Page: http://www.macromedia.com/support/documentation/en/flashplayer/help/settings_manager04.html',\r\n    badRemove: 'Warning: Failed to remove flash movie.',\r\n    noPeak: 'Warning: peakData features unsupported for movieStar formats',\r\n    shutdown: _sm + '.disable(): Shutting down',\r\n    queue: _sm + ': Queueing %s handler',\r\n    smFail: _sm + ': Failed to initialise.',\r\n    smError: 'SMSound.load(): Exception: JS-Flash communication failed, or JS error.',\r\n    fbTimeout: 'No flash response, applying .'+_s.swfCSS.swfTimedout+' CSS..',\r\n    fbLoaded: 'Flash loaded',\r\n    fbHandler: _smc+'flashBlockHandler()',\r\n    manURL: 'SMSound.load(): Using manually-assigned URL',\r\n    onURL: _sm + '.load(): current URL already assigned.',\r\n    badFV: _sm + '.flashVersion must be 8 or 9. \"%s\" is invalid. Reverting to %s.',\r\n    as2loop: 'Note: Setting stream:false so looping can work (flash 8 limitation)',\r\n    noNSLoop: 'Note: Looping not implemented for MovieStar formats',\r\n    needfl9: 'Note: Switching to flash 9, required for MP4 formats.',\r\n    mfTimeout: 'Setting flashLoadTimeout = 0 (infinite) for off-screen, mobile flash case',\r\n    mfOn: 'mobileFlash::enabling on-screen flash repositioning',\r\n    policy: 'Enabling usePolicyFile for data access'\r\n    // </d>\r\n  };\r\n\r\n  _str = function() { // o [,items to replace]\r\n    // <d>\r\n    var args = _slice.call(arguments), // real array, please\r\n    o = args.shift(), // first arg\r\n    str = (_strings && _strings[o]?_strings[o]:''), i, j;\r\n    if (str && args && args.length) {\r\n      for (i = 0, j = args.length; i < j; i++) {\r\n        str = str.replace('%s', args[i]);\r\n      }\r\n    }\r\n    return str;\r\n    // </d>\r\n  };\r\n\r\n  _loopFix = function(sOpt) {\r\n    // flash 8 requires stream = false for looping to work\r\n    if (_fV === 8 && sOpt.loops > 1 && sOpt.stream) {\r\n      _wDS('as2loop');\r\n      sOpt.stream = false;\r\n    }\r\n    return sOpt;\r\n  };\r\n\r\n  _policyFix = function(sOpt, sPre) {\r\n    if (sOpt && !sOpt.usePolicyFile && (sOpt.onid3 || sOpt.usePeakData || sOpt.useWaveformData || sOpt.useEQData)) {\r\n      _s._wD((sPre || '') + _str('policy'));\r\n      sOpt.usePolicyFile = true;\r\n    }\r\n    return sOpt;\r\n  };\r\n\r\n  _complain = function(sMsg) {\r\n    if (typeof console !== 'undefined' && typeof console.warn !== 'undefined') {\r\n      console.warn(sMsg);\r\n    } else {\r\n      _s._wD(sMsg);\r\n    }\r\n  };\r\n\r\n  _doNothing = function() {\r\n    return false;\r\n  };\r\n\r\n  _disableObject = function(o) {\r\n    var oProp;\r\n    for (oProp in o) {\r\n      if (o.hasOwnProperty(oProp) && typeof o[oProp] === 'function') {\r\n        o[oProp] = _doNothing;\r\n      }\r\n    }\r\n    oProp = null;\r\n  };\r\n\r\n  _failSafely = function(bNoDisable) {\r\n    // general failure exception handler\r\n    if (typeof bNoDisable === 'undefined') {\r\n      bNoDisable = false;\r\n    }\r\n    if (_disabled || bNoDisable) {\r\n      _wDS('smFail', 2);\r\n      _s.disable(bNoDisable);\r\n    }\r\n  };\r\n\r\n  _normalizeMovieURL = function(smURL) {\r\n    var urlParams = null;\r\n    if (smURL) {\r\n      if (smURL.match(/\\.swf(\\?.*)?$/i)) {\r\n        urlParams = smURL.substr(smURL.toLowerCase().lastIndexOf('.swf?') + 4);\r\n        if (urlParams) {\r\n          return smURL; // assume user knows what they're doing\r\n        }\r\n      } else if (smURL.lastIndexOf('/') !== smURL.length - 1) {\r\n        smURL = smURL + '/';\r\n      }\r\n    }\r\n    return (smURL && smURL.lastIndexOf('/') !== - 1?smURL.substr(0, smURL.lastIndexOf('/') + 1):'./') + _s.movieURL;\r\n  };\r\n\r\n  _setVersionInfo = function() {\r\n\r\n    if (_fV !== 8 && _fV !== 9) {\r\n      _s._wD(_str('badFV', _fV, _defaultFlashVersion));\r\n      _s.flashVersion = _defaultFlashVersion;\r\n    }\r\n    var isDebug = (_s.debugMode || _s.debugFlash?'_debug.swf':'.swf'); // debug flash movie, if applicable\r\n    if (_s.useHTML5Audio && !_s.html5Only && _s.audioFormats.mp4.required && _s.flashVersion < 9) {\r\n      _s._wD(_str('needfl9'));\r\n      _s.flashVersion = 9;\r\n    }\r\n    _fV = _s.flashVersion; // short-hand for internal use\r\n    _s.version = _s.versionNumber + (_s.html5Only?' (HTML5-only mode)':(_fV === 9?' (AS3/Flash 9)':' (AS2/Flash 8)'));\r\n    // set up default options\r\n    if (_fV > 8) {\r\n      _s.defaultOptions = _mixin(_s.defaultOptions, _s.flash9Options);\r\n      _s.features.buffering = true;\r\n    }\r\n    if (_fV > 8 && _s.useMovieStar) {\r\n      // flash 9+ support for movieStar formats as well as MP3\r\n      _s.defaultOptions = _mixin(_s.defaultOptions, _s.movieStarOptions);\r\n      _s.filePatterns.flash9 = new RegExp('\\\\.(mp3|' + _s.netStreamTypes.join('|') + ')(\\\\?.*)?$', 'i');\r\n      _s.mimePattern = _s.netStreamMimeTypes;\r\n      _s.features.movieStar = true;\r\n    } else {\r\n      _s.useMovieStar = false;\r\n      _s.features.movieStar = false;\r\n    }\r\n    _s.filePattern = _s.filePatterns[(_fV !== 8?'flash9':'flash8')];\r\n    _s.movieURL = (_fV === 8?'soundmanager2.swf':'soundmanager2_flash9.swf').replace('.swf',isDebug);\r\n    _s.features.peakData = _s.features.waveformData = _s.features.eqData = (_fV > 8);\r\n  };\r\n\r\n  _setPolling = function(bPolling, bHighPerformance) {\r\n    if (!_s.o || !_s.allowPolling) {\r\n      return false;\r\n    }\r\n    _s.o._setPolling(bPolling, bHighPerformance);\r\n  };\r\n\r\n  _initDebug = function() {\r\n    if (_s.debugURLParam.test(_wl)) {\r\n      _s.debugMode = true; // allow force of debug mode via URL\r\n    }\r\n    // <d>\r\n    if (_id(_s.debugID)) {\r\n      return false;\r\n    }\r\n    var oD, oDebug, oTarget, oToggle, tmp;\r\n    if (_s.debugMode && !_id(_s.debugID) && ((!_hasConsole || !_s.useConsole) || (_s.useConsole && _hasConsole && !_s.consoleOnly))) {\r\n      oD = _doc.createElement('div');\r\n      oD.id = _s.debugID + '-toggle';\r\n      oToggle = {\r\n        'position': 'fixed',\r\n        'bottom': '0px',\r\n        'right': '0px',\r\n        'width': '1.2em',\r\n        'height': '1.2em',\r\n        'lineHeight': '1.2em',\r\n        'margin': '2px',\r\n        'textAlign': 'center',\r\n        'border': '1px solid #999',\r\n        'cursor': 'pointer',\r\n        'background': '#fff',\r\n        'color': '#333',\r\n        'zIndex': 10001\r\n      };\r\n      oD.appendChild(_doc.createTextNode('-'));\r\n      oD.onclick = _toggleDebug;\r\n      oD.title = 'Toggle SM2 debug console';\r\n      if (_ua.match(/msie 6/i)) {\r\n        oD.style.position = 'absolute';\r\n        oD.style.cursor = 'hand';\r\n      }\r\n      for (tmp in oToggle) {\r\n        if (oToggle.hasOwnProperty(tmp)) {\r\n          oD.style[tmp] = oToggle[tmp];\r\n        }\r\n      }\r\n      oDebug = _doc.createElement('div');\r\n      oDebug.id = _s.debugID;\r\n      oDebug.style.display = (_s.debugMode?'block':'none');\r\n      if (_s.debugMode && !_id(oD.id)) {\r\n        try {\r\n          oTarget = _getDocument();\r\n          oTarget.appendChild(oD);\r\n        } catch(e2) {\r\n          throw new Error(_str('domError')+' \\n'+e2.toString());\r\n        }\r\n        oTarget.appendChild(oDebug);\r\n      }\r\n    }\r\n    oTarget = null;\r\n    // </d>\r\n  };\r\n\r\n  _idCheck = this.getSoundById;\r\n\r\n  // <d>\r\n  _wDS = function(o, errorLevel) {\r\n    if (!o) {\r\n      return '';\r\n    } else {\r\n      return _s._wD(_str(o), errorLevel);\r\n    }\r\n  };\r\n\r\n  // last-resort debugging option\r\n  if (_wl.indexOf('sm2-debug=alert') + 1 && _s.debugMode) {\r\n    _s._wD = function(sText) {window.alert(sText);};\r\n  }\r\n\r\n  _toggleDebug = function() {\r\n    var o = _id(_s.debugID),\r\n    oT = _id(_s.debugID + '-toggle');\r\n    if (!o) {\r\n      return false;\r\n    }\r\n    if (_debugOpen) {\r\n      // minimize\r\n      oT.innerHTML = '+';\r\n      o.style.display = 'none';\r\n    } else {\r\n      oT.innerHTML = '-';\r\n      o.style.display = 'block';\r\n    }\r\n    _debugOpen = !_debugOpen;\r\n  };\r\n\r\n  _debugTS = function(sEventType, bSuccess, sMessage) {\r\n    // troubleshooter debug hooks\r\n    if (typeof sm2Debugger !== 'undefined') {\r\n      try {\r\n        sm2Debugger.handleEvent(sEventType, bSuccess, sMessage);\r\n      } catch(e) {\r\n        // oh well\r\n      }\r\n    }\r\n    return true;\r\n  };\r\n  // </d>\r\n\r\n  _getSWFCSS = function() {\r\n    var css = [];\r\n    if (_s.debugMode) {\r\n      css.push(_s.swfCSS.sm2Debug);\r\n    }\r\n    if (_s.debugFlash) {\r\n      css.push(_s.swfCSS.flashDebug);\r\n    }\r\n    if (_s.useHighPerformance) {\r\n      css.push(_s.swfCSS.highPerf);\r\n    }\r\n    return css.join(' ');\r\n  };\r\n\r\n  _flashBlockHandler = function() {\r\n    // *possible* flash block situation.\r\n    var name = _str('fbHandler'),\r\n        p = _s.getMoviePercent(),\r\n        css = _s.swfCSS,\r\n        error = {type:'FLASHBLOCK'};\r\n    if (_s.html5Only) {\r\n      return false;\r\n    }\r\n    if (!_s.ok()) {\r\n      if (_needsFlash) {\r\n        // make the movie more visible, so user can fix\r\n        _s.oMC.className = _getSWFCSS() + ' ' + css.swfDefault + ' ' + (p === null?css.swfTimedout:css.swfError);\r\n        _s._wD(name+': '+_str('fbTimeout')+(p?' ('+_str('fbLoaded')+')':''));\r\n      }\r\n      _s.didFlashBlock = true;\r\n      _processOnEvents({type:'ontimeout', ignoreInit:true, error:error}); // fire onready(), complain lightly\r\n      _catchError(error);\r\n    } else {\r\n      // SM2 loaded OK (or recovered)\r\n      if (_s.didFlashBlock) {\r\n        _s._wD(name+': Unblocked');\r\n      }\r\n      if (_s.oMC) {\r\n        _s.oMC.className = [_getSWFCSS(), css.swfDefault, css.swfLoaded + (_s.didFlashBlock?' '+css.swfUnblocked:'')].join(' ');\r\n      }\r\n    }\r\n  };\r\n\r\n  _addOnEvent = function(sType, oMethod, oScope) {\r\n    if (typeof _on_queue[sType] === 'undefined') {\r\n      _on_queue[sType] = [];\r\n    }\r\n    _on_queue[sType].push({\r\n      'method': oMethod,\r\n      'scope': (oScope || null),\r\n      'fired': false\r\n    });\r\n  };\r\n\r\n  _processOnEvents = function(oOptions) {\r\n    if (!oOptions) { // assume onready, if unspecified\r\n      oOptions = {\r\n        type: 'onready'\r\n      };\r\n    }\r\n    if (!_didInit && oOptions && !oOptions.ignoreInit) {\r\n      // not ready yet.\r\n      return false;\r\n    }\r\n    if (oOptions.type === 'ontimeout' && _s.ok()) {\r\n      // invalid case\r\n      return false;\r\n    }\r\n    var status = {\r\n          success: (oOptions && oOptions.ignoreInit?_s.ok():!_disabled)\r\n        },\r\n        srcQueue = (oOptions && oOptions.type?_on_queue[oOptions.type]||[]:[]), // queue specified by type, or none\r\n        queue = [], i, j,\r\n        args = [status],\r\n        canRetry = (_needsFlash && _s.useFlashBlock && !_s.ok());\r\n    if (oOptions.error) {\r\n      args[0].error = oOptions.error;\r\n    }\r\n    for (i = 0, j = srcQueue.length; i < j; i++) {\r\n      if (srcQueue[i].fired !== true) {\r\n        queue.push(srcQueue[i]);\r\n      }\r\n    }\r\n    if (queue.length) {\r\n      _s._wD(_sm + ': Firing ' + queue.length + ' '+oOptions.type+'() item' + (queue.length === 1?'':'s'));\r\n      for (i = 0, j = queue.length; i < j; i++) {\r\n        if (queue[i].scope) {\r\n          queue[i].method.apply(queue[i].scope, args);\r\n        } else {\r\n          queue[i].method.apply(this, args);\r\n        }\r\n        if (!canRetry) { // flashblock case doesn't count here\r\n          queue[i].fired = true;\r\n        }\r\n      }\r\n    }\r\n    return true;\r\n  };\r\n\r\n  _initUserOnload = function() {\r\n    _win.setTimeout(function() {\r\n      if (_s.useFlashBlock) {\r\n        _flashBlockHandler();\r\n      }\r\n      _processOnEvents();\r\n      // call user-defined \"onload\", scoped to window\r\n      if (_s.onload instanceof Function) {\r\n        _wDS('onload', 1);\r\n        _s.onload.apply(_win);\r\n        _wDS('onloadOK', 1);\r\n      }\r\n      if (_s.waitForWindowLoad) {\r\n        _event.add(_win, 'load', _initUserOnload);\r\n      }\r\n    },1);\r\n  };\r\n\r\n  _detectFlash = function() {\r\n\r\n    // hat tip: Flash Detect library (BSD, (C) 2007) by Carl \"DocYes\" S. Yestrau - http://featureblend.com/javascript-flash-detection-library.html / http://featureblend.com/license.txt\r\n\r\n    if (_hasFlash !== undefined) {\r\n      // this work has already been done.\r\n      return _hasFlash;\r\n    }\r\n\r\n    var hasPlugin = false, n = navigator, nP = n.plugins, obj, type, types, AX = _win.ActiveXObject;\r\n\r\n    if (nP && nP.length) {\r\n\r\n      type = 'application/x-shockwave-flash';\r\n      types = n.mimeTypes;\r\n      if (types && types[type] && types[type].enabledPlugin && types[type].enabledPlugin.description) {\r\n        hasPlugin = true;\r\n      }\r\n\r\n    } else if (typeof AX !== 'undefined') {\r\n\r\n      try {\r\n        obj = new AX('ShockwaveFlash.ShockwaveFlash');\r\n      } catch(e) {\r\n        // oh well\r\n      }\r\n      hasPlugin = (!!obj);\r\n\r\n    }\r\n\r\n    _hasFlash = hasPlugin;\r\n\r\n    return hasPlugin;\r\n\r\n  };\r\n\r\n  _featureCheck = function() {\r\n\r\n    var needsFlash, item,\r\n        isSpecial = (_ua.match(/iphone os (1|2|3_0|3_1)/i)?true:false); // iPhone <= 3.1 has broken HTML5 audio(), but firmware 3.2 (iPad) + iOS4 works.\r\n\r\n    if (isSpecial) {\r\n      _s.hasHTML5 = false; // has Audio(), but is broken; let it load links directly.\r\n      _s.html5Only = true; // ignore flash case, however\r\n      if (_s.oMC) {\r\n        _s.oMC.style.display = 'none';\r\n      }\r\n      return false;\r\n    }\r\n\r\n    if (_s.useHTML5Audio) {\r\n      if (!_s.html5 || !_s.html5.canPlayType) {\r\n        _s._wD('SoundManager: No HTML5 Audio() support detected.');\r\n        _s.hasHTML5 = false;\r\n        return true;\r\n      } else {\r\n        _s.hasHTML5 = true;\r\n      }\r\n      if (_isBadSafari) {\r\n        _s._wD(_smc+'Note: Buggy HTML5 Audio in Safari on this OS X release, see https://bugs.webkit.org/show_bug.cgi?id=32159 - '+(!_hasFlash?' would use flash fallback for MP3/MP4, but none detected.':'will use flash fallback for MP3/MP4, if available'),1);\r\n        if (_detectFlash()) {\r\n          return true;\r\n        }\r\n      }\r\n    } else {\r\n      // flash needed (or, HTML5 needs enabling.)\r\n      return true;\r\n    }\r\n\r\n    for (item in _s.audioFormats) {\r\n      if (_s.audioFormats.hasOwnProperty(item)) {\r\n        if ( (_s.audioFormats[item].required && !_s.html5.canPlayType(_s.audioFormats[item].type)) || _s.flash[item] || _s.flash[_s.audioFormats[item].type]) {\r\n          // flash may be required, or preferred for this format\r\n          needsFlash = true;\r\n        }\r\n      }\r\n    }\r\n\r\n    // sanity check..\r\n    if (_s.ignoreFlash) {\r\n      needsFlash = false;\r\n    }\r\n\r\n    _s.html5Only = (_s.hasHTML5 && _s.useHTML5Audio && !needsFlash);\r\n\r\n    return (!_s.html5Only);\r\n\r\n  };\r\n\r\n  _startTimer = function(oSound) {\r\n    if (!oSound._hasTimer) {\r\n      oSound._hasTimer = true;\r\n    }\r\n  };\r\n\r\n  _stopTimer = function(oSound) {\r\n    if (oSound._hasTimer) {\r\n      oSound._hasTimer = false;\r\n    }\r\n  };\r\n\r\n  _catchError = function(options) {\r\n    options = (typeof options !== 'undefined' ? options : {});\r\n    if (_s.onerror instanceof Function) {\r\n      _s.onerror.apply(_win, [{type:(typeof options.type !== 'undefined' ? options.type : null)}]);\r\n    }\r\n    if (typeof options.fatal !== 'undefined' && options.fatal) {\r\n      _s.disable();\r\n    }\r\n  };\r\n\r\n  _badSafariFix = function() {\r\n    // special case: \"bad\" Safari (OS X 10.3 - 10.7) must fall back to flash for MP3/MP4\r\n    if (!_isBadSafari || !_detectFlash()) {\r\n      return false; // doesn't apply\r\n    }\r\n    var aF = _s.audioFormats, i, item;\r\n    for (item in aF) {\r\n      if (aF.hasOwnProperty(item)) {\r\n        if (item === 'mp3' || item === 'mp4') {\r\n          _s._wD(_sm+': Using flash fallback for '+item+' format');\r\n          _s.html5[item] = false;\r\n          // assign result to related formats, too\r\n          if (aF[item] && aF[item].related) {\r\n            for (i = aF[item].related.length; i--;) {\r\n              _s.html5[aF[item].related[i]] = false;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  /*\r\n   * pseudo-private flash/ExternalInterface methods\r\n  */\r\n\r\n  this._setSandboxType = function(sandboxType) {\r\n    // <d>\r\n    var sb = _s.sandbox;\r\n    sb.type = sandboxType;\r\n    sb.description = sb.types[(typeof sb.types[sandboxType] !== 'undefined'?sandboxType:'unknown')];\r\n    _s._wD('Flash security sandbox type: ' + sb.type);\r\n    if (sb.type === 'localWithFile') {\r\n      sb.noRemote = true;\r\n      sb.noLocal = false;\r\n      _wDS('secNote', 2);\r\n    } else if (sb.type === 'localWithNetwork') {\r\n      sb.noRemote = false;\r\n      sb.noLocal = true;\r\n    } else if (sb.type === 'localTrusted') {\r\n      sb.noRemote = false;\r\n      sb.noLocal = false;\r\n    }\r\n    // </d>\r\n  };\r\n\r\n  this._externalInterfaceOK = function(flashDate) {\r\n    // flash callback confirming flash loaded, EI working etc.\r\n    // flashDate = approx. timing/delay info for JS/flash bridge\r\n    if (_s.swfLoaded) {\r\n      return false;\r\n    }\r\n    var eiTime = new Date().getTime();\r\n    _s._wD(_smc+'externalInterfaceOK()' + (flashDate?' (~' + (eiTime - flashDate) + ' ms)':''));\r\n    _debugTS('swf', true);\r\n    _debugTS('flashtojs', true);\r\n    _s.swfLoaded = true;\r\n    _tryInitOnFocus = false;\r\n    if (_isBadSafari) {\r\n      _badSafariFix();\r\n    }\r\n    if (_isIE) {\r\n      // IE needs a timeout OR delay until window.onload - may need TODO: investigating\r\n      setTimeout(_init, 100);\r\n    } else {\r\n      _init();\r\n    }\r\n  };\r\n\r\n  /*\r\n   * private initialization helpers\r\n  */\r\n\r\n  _createMovie = function(smID, smURL) {\r\n\r\n    if (_didAppend && _appendSuccess) {\r\n      return false; // ignore if already succeeded\r\n    }\r\n\r\n    function _initMsg() {\r\n      _s._wD('-- SoundManager 2 ' + _s.version + (!_s.html5Only && _s.useHTML5Audio?(_s.hasHTML5?' + HTML5 audio':', no HTML5 audio support'):'') + (!_s.html5Only ? (_s.useMovieStar?', MovieStar mode':'') + (_s.useHighPerformance?', high performance mode, ':', ') + (( _s.flashPollingInterval ? 'custom (' + _s.flashPollingInterval + 'ms)' : (_s.useFastPolling?'fast':'normal')) + ' polling') + (_s.wmode?', wmode: ' + _s.wmode:'') + (_s.debugFlash?', flash debug mode':'') + (_s.useFlashBlock?', flashBlock mode':'') : '') + ' --', 1);\r\n    }\r\n\r\n    if (_s.html5Only) {\r\n      // 100% HTML5 mode\r\n      _setVersionInfo();\r\n      _initMsg();\r\n      _s.oMC = _id(_s.movieID);\r\n      _init();\r\n      // prevent multiple init attempts\r\n      _didAppend = true;\r\n      _appendSuccess = true;\r\n      return false;\r\n    }\r\n\r\n    // flash path\r\n    var remoteURL = (smURL || _s.url),\r\n    localURL = (_s.altURL || remoteURL),\r\n    swfTitle = 'JS/Flash audio component (SoundManager 2)',\r\n    oEmbed, oMovie, oTarget = _getDocument(), tmp, movieHTML, oEl, extraClass = _getSWFCSS(), s, x, sClass, side = 'auto', isRTL = null, html = _doc.getElementsByTagName('html')[0];\r\n\r\n    isRTL = (html && html.dir && html.dir.match(/rtl/i));\r\n    smID = (typeof smID === 'undefined'?_s.id:smID);\r\n\r\n    function param(name, value) {\r\n      return '<param name=\"'+name+'\" value=\"'+value+'\" />';\r\n    }\r\n\r\n    // safety check for legacy (change to Flash 9 URL)\r\n    _setVersionInfo();\r\n    _s.url = _normalizeMovieURL(_overHTTP?remoteURL:localURL);\r\n    smURL = _s.url;\r\n\r\n    _s.wmode = (!_s.wmode && _s.useHighPerformance && !_s.useMovieStar?'transparent':_s.wmode);\r\n\r\n    if (_s.wmode !== null && (_ua.match(/msie 8/i) || (!_isIE && !_s.useHighPerformance)) && navigator.platform.match(/win32|win64/i)) {\r\n      /*\r\n       * extra-special case: movie doesn't load until scrolled into view when using wmode = anything but 'window' here\r\n       * does not apply when using high performance (position:fixed means on-screen), OR infinite flash load timeout\r\n       * wmode breaks IE 8 on Vista + Win7 too in some cases, as of January 2011 (?)\r\n      */\r\n      _s.specialWmodeCase = true;\r\n      _wDS('spcWmode');\r\n      _s.wmode = null;\r\n    }\r\n\r\n    oEmbed = {\r\n      'name': smID,\r\n      'id': smID,\r\n      'src': smURL,\r\n      'width': side,\r\n      'height': side,\r\n      'quality': 'high',\r\n      'allowScriptAccess': _s.allowScriptAccess,\r\n      'bgcolor': _s.bgColor,\r\n      'pluginspage': _http+'//www.macromedia.com/go/getflashplayer',\r\n      'title': swfTitle,\r\n      'type': 'application/x-shockwave-flash',\r\n      'wmode': _s.wmode,\r\n      'hasPriority': 'true' // http://help.adobe.com/en_US/as3/mobile/WS4bebcd66a74275c36cfb8137124318eebc6-7ffd.html\r\n    };\r\n\r\n    if (_s.debugFlash) {\r\n      oEmbed.FlashVars = 'debug=1';\r\n    }\r\n\r\n    if (!_s.wmode) {\r\n      delete oEmbed.wmode; // don't write empty attribute\r\n    }\r\n\r\n    if (_isIE) {\r\n\r\n      // IE is \"special\".\r\n      oMovie = _doc.createElement('div');\r\n      movieHTML = [\r\n        '<object id=\"' + smID + '\" data=\"' + smURL + '\" type=\"' + oEmbed.type + '\" title=\"' + oEmbed.title +'\" classid=\"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\" codebase=\"' + _http+'//download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,40,0\" width=\"' + oEmbed.width + '\" height=\"' + oEmbed.height + '\">',\r\n        param('movie', smURL),\r\n        param('AllowScriptAccess', _s.allowScriptAccess),\r\n        param('quality', oEmbed.quality),\r\n        (_s.wmode? param('wmode', _s.wmode): ''),\r\n        param('bgcolor', _s.bgColor),\r\n        param('hasPriority', 'true'),\r\n        (_s.debugFlash ? param('FlashVars', oEmbed.FlashVars) : ''),\r\n        '</object>'\r\n      ].join('');\r\n\r\n    } else {\r\n\r\n      oMovie = _doc.createElement('embed');\r\n      for (tmp in oEmbed) {\r\n        if (oEmbed.hasOwnProperty(tmp)) {\r\n          oMovie.setAttribute(tmp, oEmbed[tmp]);\r\n        }\r\n      }\r\n\r\n    }\r\n\r\n    _initDebug();\r\n    extraClass = _getSWFCSS();\r\n    oTarget = _getDocument();\r\n\r\n    if (oTarget) {\r\n\r\n      _s.oMC = (_id(_s.movieID) || _doc.createElement('div'));\r\n\r\n      if (!_s.oMC.id) {\r\n\r\n        _s.oMC.id = _s.movieID;\r\n        _s.oMC.className = _s.swfCSS.swfDefault + ' ' + extraClass;\r\n        s = null;\r\n        oEl = null;\r\n\r\n        if (!_s.useFlashBlock) {\r\n          if (_s.useHighPerformance) {\r\n            // on-screen at all times\r\n            s = {\r\n              'position': 'fixed',\r\n              'width': '8px',\r\n              'height': '8px',\r\n              // >= 6px for flash to run fast, >= 8px to start up under Firefox/win32 in some cases. odd? yes.\r\n              'bottom': '0px',\r\n              'left': '0px',\r\n              'overflow': 'hidden'\r\n            };\r\n          } else {\r\n            // hide off-screen, lower priority\r\n            s = {\r\n              'position': 'absolute',\r\n              'width': '6px',\r\n              'height': '6px',\r\n              'top': '-9999px',\r\n              'left': '-9999px'\r\n            };\r\n            if (isRTL) {\r\n              s.left = Math.abs(parseInt(s.left,10))+'px';\r\n            }\r\n          }\r\n        }\r\n\r\n        if (_isWebkit) {\r\n          _s.oMC.style.zIndex = 10000; // soundcloud-reported render/crash fix, safari 5\r\n        }\r\n\r\n        if (!_s.debugFlash) {\r\n          for (x in s) {\r\n            if (s.hasOwnProperty(x)) {\r\n              _s.oMC.style[x] = s[x];\r\n            }\r\n          }\r\n        }\r\n\r\n        try {\r\n          if (!_isIE) {\r\n            _s.oMC.appendChild(oMovie);\r\n          }\r\n          oTarget.appendChild(_s.oMC);\r\n          if (_isIE) {\r\n            oEl = _s.oMC.appendChild(_doc.createElement('div'));\r\n            oEl.className = _s.swfCSS.swfBox;\r\n            oEl.innerHTML = movieHTML;\r\n          }\r\n          _appendSuccess = true;\r\n        } catch(e) {\r\n          throw new Error(_str('domError')+' \\n'+e.toString());\r\n        }\r\n\r\n      } else {\r\n\r\n        // SM2 container is already in the document (eg. flashblock use case)\r\n        sClass = _s.oMC.className;\r\n        _s.oMC.className = (sClass?sClass+' ':_s.swfCSS.swfDefault) + (extraClass?' '+extraClass:'');\r\n        _s.oMC.appendChild(oMovie);\r\n        if (_isIE) {\r\n          oEl = _s.oMC.appendChild(_doc.createElement('div'));\r\n          oEl.className = _s.swfCSS.swfBox;\r\n          oEl.innerHTML = movieHTML;\r\n        }\r\n        _appendSuccess = true;\r\n\r\n      }\r\n\r\n    }\r\n\r\n    _didAppend = true;\r\n    _initMsg();\r\n    _s._wD(_smc+'createMovie(): Trying to load ' + smURL + (!_overHTTP && _s.altURL?' (alternate URL)':''), 1);\r\n\r\n    return true;\r\n\r\n  };\r\n\r\n  _initMovie = function() {\r\n\r\n    if (_s.html5Only) {\r\n      _createMovie();\r\n      return false;\r\n    }\r\n\r\n    // attempt to get, or create, movie\r\n    if (_s.o) {\r\n      return false; // may already exist\r\n    }\r\n\r\n    _s.o = _s.getMovie(_s.id); // inline markup\r\n\r\n    if (!_s.o) {\r\n      if (!_oRemoved) {\r\n        // try to create\r\n        _createMovie(_s.id, _s.url);\r\n      } else {\r\n        // try to re-append removed movie after reboot()\r\n        if (!_isIE) {\r\n          _s.oMC.appendChild(_oRemoved);\r\n        } else {\r\n          _s.oMC.innerHTML = _oRemovedHTML;\r\n        }\r\n        _oRemoved = null;\r\n        _didAppend = true;\r\n      }\r\n      _s.o = _s.getMovie(_s.id);\r\n    }\r\n\r\n    if (_s.o) {\r\n      _wDS('waitEI');\r\n    }\r\n\r\n    if (_s.oninitmovie instanceof Function) {\r\n      setTimeout(_s.oninitmovie, 1);\r\n    }\r\n\r\n    return true;\r\n\r\n  };\r\n\r\n  _delayWaitForEI = function() {\r\n    setTimeout(_waitForEI, 1000);\r\n  };\r\n\r\n  _waitForEI = function() {\r\n\r\n    if (_waitingForEI) {\r\n      return false;\r\n    }\r\n\r\n    _waitingForEI = true;\r\n    _event.remove(_win, 'load', _delayWaitForEI);\r\n\r\n    if (_tryInitOnFocus && !_isFocused) {\r\n      // giant Safari 3.1 hack - assume mousemove = focus given lack of focus event\r\n      _wDS('waitFocus');\r\n      return false;\r\n    }\r\n\r\n    var p;\r\n    if (!_didInit) {\r\n      p = _s.getMoviePercent();\r\n      _s._wD(_str('waitImpatient', (p === 100?' (SWF loaded)':(p > 0?' (SWF ' + p + '% loaded)':''))));\r\n    }\r\n\r\n    setTimeout(function() {\r\n\r\n      p = _s.getMoviePercent();\r\n\r\n      if (!_didInit) {\r\n        _s._wD(_sm + ': No Flash response within expected time.\\nLikely causes: ' + (p === 0?'Loading ' + _s.movieURL + ' may have failed (and/or Flash ' + _fV + '+ not present?), ':'') + 'Flash blocked or JS-Flash security error.' + (_s.debugFlash?' ' + _str('checkSWF'):''), 2);\r\n        if (!_overHTTP && p) {\r\n          _wDS('localFail', 2);\r\n          if (!_s.debugFlash) {\r\n            _wDS('tryDebug', 2);\r\n          }\r\n        }\r\n        if (p === 0) {\r\n          // if 0 (not null), probably a 404.\r\n          _s._wD(_str('swf404', _s.url));\r\n        }\r\n        _debugTS('flashtojs', false, ': Timed out' + _overHTTP?' (Check flash security or flash blockers)':' (No plugin/missing SWF?)');\r\n      }\r\n\r\n      // give up / time-out, depending\r\n      if (!_didInit && _okToDisable) {\r\n        if (p === null) {\r\n          // SWF failed. Maybe blocked.\r\n          if (_s.useFlashBlock || _s.flashLoadTimeout === 0) {\r\n            if (_s.useFlashBlock) {\r\n              _flashBlockHandler();\r\n            }\r\n            _wDS('waitForever');\r\n          } else {\r\n            // old SM2 behaviour, simply fail\r\n            _failSafely(true);\r\n          }\r\n\r\n        } else {\r\n          // flash loaded? Shouldn't be a blocking issue, then.\r\n          if (_s.flashLoadTimeout === 0) {\r\n             _wDS('waitForever');\r\n          } else {\r\n            _failSafely(true);\r\n          }\r\n        }\r\n      }\r\n\r\n    }, _s.flashLoadTimeout);\r\n\r\n  };\r\n\r\n  _handleFocus = function() {\r\n    function cleanup() {\r\n      _event.remove(_win, 'focus', _handleFocus);\r\n      _event.remove(_win, 'load', _handleFocus);\r\n    }\r\n    if (_isFocused || !_tryInitOnFocus) {\r\n      cleanup();\r\n      return true;\r\n    }\r\n    _okToDisable = true;\r\n    _isFocused = true;\r\n    _s._wD(_smc+'handleFocus()');\r\n    if (_isSafari && _tryInitOnFocus) {\r\n      _event.remove(_win, 'mousemove', _handleFocus);\r\n    }\r\n    // allow init to restart\r\n    _waitingForEI = false;\r\n    cleanup();\r\n    return true;\r\n  };\r\n\r\n  _initComplete = function(bNoDisable) {\r\n    if (_didInit) {\r\n      return false;\r\n    }\r\n    if (_s.html5Only) {\r\n      // all good.\r\n      _s._wD('-- SoundManager 2: loaded --');\r\n      _didInit = true;\r\n      _initUserOnload();\r\n      _debugTS('onload', true);\r\n      return true;\r\n    }\r\n    var wasTimeout = (_s.useFlashBlock && _s.flashLoadTimeout && !_s.getMoviePercent()),\r\n        error;\r\n    if (!wasTimeout) {\r\n      _didInit = true;\r\n      if (_disabled) {\r\n        error = {type: (!_hasFlash && _needsFlash ? 'NO_FLASH' : 'INIT_TIMEOUT')};\r\n      }\r\n    }\r\n    _s._wD('-- SoundManager 2 ' + (_disabled?'failed to load':'loaded') + ' (' + (_disabled?'security/load error':'OK') + ') --', 1);\r\n    if (_disabled || bNoDisable) {\r\n      if (_s.useFlashBlock && _s.oMC) {\r\n        _s.oMC.className = _getSWFCSS() + ' ' + (_s.getMoviePercent() === null?_s.swfCSS.swfTimedout:_s.swfCSS.swfError);\r\n      }\r\n      _processOnEvents({type:'ontimeout', error:error});\r\n      _debugTS('onload', false);\r\n      _catchError(error);\r\n      return false;\r\n    } else {\r\n      _debugTS('onload', true);\r\n    }\r\n    _event.add(_win, 'unload', _doNothing); // prevent browser from showing cached state via back button, because flash will be dead\r\n    if (_s.waitForWindowLoad && !_windowLoaded) {\r\n      _wDS('waitOnload');\r\n      _event.add(_win, 'load', _initUserOnload);\r\n      return false;\r\n    } else {\r\n      if (_s.waitForWindowLoad && _windowLoaded) {\r\n        _wDS('docLoaded');\r\n      }\r\n      _initUserOnload();\r\n    }\r\n    return true;\r\n  };\r\n\r\n  _showSupport = function() {\r\n\r\n    var item, tests = [];\r\n    if (_s.useHTML5Audio && _s.hasHTML5) {\r\n      for (item in _s.audioFormats) {\r\n        if (_s.audioFormats.hasOwnProperty(item)) {\r\n          tests.push(item + ': ' + _s.html5[item] + (!_s.html5[item] && _hasFlash && _s.flash[item] ? ' (using flash)' : (_s.preferFlash && _s.flash[item] && _hasFlash ? ' (preferring flash)': (!_s.html5[item] ? ' (' + (_s.audioFormats[item].required ? 'required, ':'') + 'and no flash support)' : ''))));\r\n        }\r\n      }\r\n      _s._wD('-- SoundManager 2: HTML5 support tests ('+_s.html5Test+'): '+tests.join(', ')+' --',1);\r\n    }\r\n\r\n  };\r\n\r\n  _init = function() {\r\n\r\n    _wDS('init');\r\n\r\n    // called after onload()\r\n    if (_didInit) {\r\n      _wDS('didInit');\r\n      return false;\r\n    }\r\n\r\n    function _cleanup() {\r\n      _event.remove(_win, 'load', _s.beginDelayedInit);\r\n    }\r\n\r\n    if (_s.html5Only) {\r\n      if (!_didInit) {\r\n        // we don't need no steenking flash!\r\n        _cleanup();\r\n        _s.enabled = true;\r\n        _initComplete();\r\n      }\r\n      return true;\r\n    }\r\n\r\n    // flash path\r\n    _initMovie();\r\n\r\n    try {\r\n      _wDS('flashJS');\r\n      _s.o._externalInterfaceTest(false); // attempt to talk to Flash\r\n      if (!_s.allowPolling) {\r\n        _wDS('noPolling', 1);\r\n      } else {\r\n        _setPolling(true, (_s.flashPollingInterval || (_s.useFastPolling ? 10 : 50)));\r\n      }\r\n      if (!_s.debugMode) {\r\n        _s.o._disableDebug();\r\n      }\r\n      _s.enabled = true;\r\n      _debugTS('jstoflash', true);\r\n    } catch(e) {\r\n      _s._wD('js/flash exception: ' + e.toString());\r\n      _debugTS('jstoflash', false);\r\n      _catchError({type:'JS_TO_FLASH_EXCEPTION', fatal:true});\r\n      _failSafely(true); // don't disable, for reboot()\r\n      _initComplete();\r\n      return false;\r\n    }\r\n\r\n    _initComplete();\r\n    // event cleanup\r\n    _cleanup();\r\n    return true;\r\n\r\n  };\r\n\r\n  _dcLoaded = function() {\r\n    if (_didDCLoaded) {\r\n      return false;\r\n    }\r\n    _didDCLoaded = true;\r\n    _initDebug();\r\n\r\n    /*\r\n     * Temporary feature: allow force of HTML5 via URL params: sm2-usehtml5audio=0 or 1\r\n     * Ditto for sm2-preferFlash, too.\r\n    */\r\n    // <d>\r\n    (function(){\r\n      var a = 'sm2-usehtml5audio=', l = _wl.toLowerCase(), b = null,\r\n      a2 = 'sm2-preferflash=', b2 = null, hasCon = (typeof console !== 'undefined' && typeof console.log !== 'undefined');\r\n      if (l.indexOf(a) !== -1) {\r\n        b = (l.charAt(l.indexOf(a)+a.length) === '1');\r\n        if (hasCon) {\r\n          console.log((b?'Enabling ':'Disabling ')+'useHTML5Audio via URL parameter');\r\n        }\r\n        _s.useHTML5Audio = b;\r\n      }\r\n      if (l.indexOf(a2) !== -1) {\r\n        b2 = (l.charAt(l.indexOf(a2)+a2.length) === '1');\r\n        if (hasCon) {\r\n          console.log((b2?'Enabling ':'Disabling ')+'preferFlash via URL parameter');\r\n        }\r\n        _s.preferFlash = b2;\r\n      }\r\n    }());\r\n    // </d>\r\n\r\n    if (!_hasFlash && _s.hasHTML5) {\r\n      _s._wD('SoundManager: No Flash detected'+(!_s.useHTML5Audio?', enabling HTML5.':'. Trying HTML5-only mode.'));\r\n      _s.useHTML5Audio = true;\r\n      // make sure we aren't preferring flash, either\r\n      // TODO: preferFlash should not matter if flash is not installed. Currently, stuff breaks without the below tweak.\r\n      _s.preferFlash = false;\r\n    }\r\n\r\n    _testHTML5();\r\n    _s.html5.usingFlash = _featureCheck();\r\n    _needsFlash = _s.html5.usingFlash;\r\n\r\n    _showSupport();\r\n\r\n    if (!_hasFlash && _needsFlash) {\r\n      _s._wD('SoundManager: Fatal error: Flash is needed to play some required formats, but is not available.');\r\n      // TODO: Fatal here vs. timeout approach, etc.\r\n      _s.flashLoadTimeout = 1; // hack: fail sooner.\r\n    }\r\n\r\n    if (_doc.removeEventListener) {\r\n      _doc.removeEventListener('DOMContentLoaded', _dcLoaded, false);\r\n    }\r\n    _initMovie();\r\n    return true;\r\n  };\r\n\r\n  _dcIE = function() {\r\n    if (_doc.readyState === 'complete') {\r\n      _dcLoaded();\r\n      _doc.detachEvent('onreadystatechange', _dcIE);\r\n    }\r\n    return true;\r\n  };\r\n\r\n  // sniff up-front\r\n  _detectFlash();\r\n\r\n  // focus and window load, init (primarily flash-driven)\r\n  _event.add(_win, 'focus', _handleFocus);\r\n  _event.add(_win, 'load', _handleFocus);\r\n  _event.add(_win, 'load', _delayWaitForEI);\r\n  if (_isSafari && _tryInitOnFocus) {\r\n    _event.add(_win, 'mousemove', _handleFocus); // massive Safari 3.1 focus hack\r\n  }\r\n\r\n  if (_doc.addEventListener) {\r\n    _doc.addEventListener('DOMContentLoaded', _dcLoaded, false);\r\n  } else if (_doc.attachEvent) {\r\n    _doc.attachEvent('onreadystatechange', _dcIE);\r\n  } else {\r\n    // no add/attachevent support - safe to assume no JS -> Flash either\r\n    _debugTS('onload', false);\r\n    _catchError({type:'NO_DOM2_EVENTS', fatal:true});\r\n  }\r\n\r\n  if (_doc.readyState === 'complete') {\r\n    setTimeout(_dcLoaded,100);\r\n  }\r\n\r\n} // SoundManager()\r\n","pre":true},"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/util/underscore.js":{"path":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/util/underscore.js","friendlyPath":"util.underscore","directory":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/util/","filename":"underscore.js","src":"//     Underscore.js 1.2.1\n//     (c) 2011 Jeremy Ashkenas, DocumentCloud Inc.\n//     Underscore is freely distributable under the MIT license.\n//     Portions of Underscore are inspired or borrowed from Prototype,\n//     Oliver Steele's Functional, and John Resig's Micro-Templating.\n//     For all details and documentation:\n//     http://documentcloud.github.com/underscore\n(function() {\n\n  // Baseline setup\n  // --------------\n  // Establish the root object, `window` in the browser, or `global` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Establish the object that gets returned to break out of a loop iteration.\n  var breaker = {};\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype,\n      ObjProto = Object.prototype,\n      FuncProto = Function.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var slice = ArrayProto.slice,\n      unshift = ArrayProto.unshift,\n      toString = ObjProto.toString,\n      hasOwnProperty = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var\n  nativeForEach = ArrayProto.forEach,\n      nativeMap = ArrayProto.map,\n      nativeReduce = ArrayProto.reduce,\n      nativeReduceRight = ArrayProto.reduceRight,\n      nativeFilter = ArrayProto.filter,\n      nativeEvery = ArrayProto.every,\n      nativeSome = ArrayProto.some,\n      nativeIndexOf = ArrayProto.indexOf,\n      nativeLastIndexOf = ArrayProto.lastIndexOf,\n      nativeIsArray = Array.isArray,\n      nativeKeys = Object.keys,\n      nativeBind = FuncProto.bind;\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) {\n    return new wrapper(obj);\n  };\n\n  // Export the Underscore object for **Node.js** and **\"CommonJS\"**, with\n  // backwards-compatibility for the old `require()` API. If we're not in\n  // CommonJS, add `_` to the global object.\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else if (typeof define === 'function' && define.amd) {\n    // Register as a named module with AMD.\n    define('underscore', function() {\n      return _;\n    });\n  } else {\n    // Exported as a string, for Closure Compiler \"advanced\" mode.\n    root['_'] = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.2.1';\n\n  // Collection Functions\n  // --------------------\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles objects with the built-in `forEach`, arrays, and raw objects.\n  // Delegates to **ECMAScript 5**'s native `forEach` if available.\n  var each = _.each = _.forEach = function(obj, iterator, context) {\n    if (obj == null) return;\n    if (nativeForEach && obj.forEach === nativeForEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length === +obj.length) {\n      for (var i = 0, l = obj.length; i < l; i++) {\n        if (i in obj && iterator.call(context, obj[i], i, obj) === breaker) return;\n      }\n    } else {\n      for (var key in obj) {\n        if (hasOwnProperty.call(obj, key)) {\n          if (iterator.call(context, obj[key], key, obj) === breaker) return;\n        }\n      }\n    }\n  };\n\n  // Return the results of applying the iterator to each element.\n  // Delegates to **ECMAScript 5**'s native `map` if available.\n  _.map = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);\n    each(obj, function(value, index, list) {\n      results[results.length] = iterator.call(context, value, index, list);\n    });\n    return results;\n  };\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.\n  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {\n    var initial = memo !== void 0;\n    if (obj == null) obj = [];\n    if (nativeReduce && obj.reduce === nativeReduce) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);\n    }\n    each(obj, function(value, index, list) {\n      if (!initial) {\n        memo = value;\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, value, index, list);\n      }\n    });\n    if (!initial) throw new TypeError(\"Reduce of empty array with no initial value\");\n    return memo;\n  };\n\n  // The right-associative version of reduce, also known as `foldr`.\n  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.\n  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {\n    if (obj == null) obj = [];\n    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {\n      if (context) iterator = _.bind(iterator, context);\n      return memo !== void 0 ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);\n    }\n    var reversed = (_.isArray(obj) ? obj.slice() : _.toArray(obj)).reverse();\n    return _.reduce(reversed, iterator, memo, context);\n  };\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, iterator, context) {\n    var result;\n    any(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) {\n        result = value;\n        return true;\n      }\n    });\n    return result;\n  };\n\n  // Return all the elements that pass a truth test.\n  // Delegates to **ECMAScript 5**'s native `filter` if available.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);\n    each(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) results[results.length] = value;\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    each(obj, function(value, index, list) {\n      if (!iterator.call(context, value, index, list)) results[results.length] = value;\n    });\n    return results;\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Delegates to **ECMAScript 5**'s native `every` if available.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, iterator, context) {\n    var result = true;\n    if (obj == null) return result;\n    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);\n    each(obj, function(value, index, list) {\n      if (!(result = result && iterator.call(context, value, index, list))) return breaker;\n    });\n    return result;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Delegates to **ECMAScript 5**'s native `some` if available.\n  // Aliased as `any`.\n  var any = _.some = _.any = function(obj, iterator, context) {\n    iterator = iterator || _.identity;\n    var result = false;\n    if (obj == null) return result;\n    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);\n    each(obj, function(value, index, list) {\n      if (result |= iterator.call(context, value, index, list)) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if a given value is included in the array or object using `===`.\n  // Aliased as `contains`.\n  _.include = _.contains = function(obj, target) {\n    var found = false;\n    if (obj == null) return found;\n    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;\n    found = any(obj, function(value) {\n      if (value === target) return true;\n    });\n    return found;\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function(obj, method) {\n    var args = slice.call(arguments, 2);\n    return _.map(obj, function(value) {\n      return (method.call ? method || value : value[method]).apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, function(value) {\n      return value[key];\n    });\n  };\n\n  // Return the maximum element or (element-based computation).\n  _.max = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj)) return Math.max.apply(Math, obj);\n    if (!iterator && _.isEmpty(obj)) return -Infinity;\n    var result = {\n      computed: -Infinity\n    };\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed >= result.computed && (result = {\n        value: value,\n        computed: computed\n      });\n    });\n    return result.value;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj)) return Math.min.apply(Math, obj);\n    if (!iterator && _.isEmpty(obj)) return Infinity;\n    var result = {\n      computed: Infinity\n    };\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed < result.computed && (result = {\n        value: value,\n        computed: computed\n      });\n    });\n    return result.value;\n  };\n\n  // Shuffle an array.\n  _.shuffle = function(obj) {\n    var shuffled = [],\n        rand;\n    each(obj, function(value, index, list) {\n      if (index == 0) {\n        shuffled[0] = value;\n      } else {\n        rand = Math.floor(Math.random() * (index + 1));\n        shuffled[index] = shuffled[rand];\n        shuffled[rand] = value;\n      }\n    });\n    return shuffled;\n  };\n\n  // Sort the object's values by a criterion produced by an iterator.\n  _.sortBy = function(obj, iterator, context) {\n    return _.pluck(_.map(obj, function(value, index, list) {\n      return {\n        value: value,\n        criteria: iterator.call(context, value, index, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria,\n          b = right.criteria;\n      return a < b ? -1 : a > b ? 1 : 0;\n    }), 'value');\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = function(obj, val) {\n    var result = {};\n    var iterator = _.isFunction(val) ? val : function(obj) {\n      return obj[val];\n    };\n    each(obj, function(value, index) {\n      var key = iterator(value, index);\n      (result[key] || (result[key] = [])).push(value);\n    });\n    return result;\n  };\n\n  // Use a comparator function to figure out at what index an object should\n  // be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iterator) {\n    iterator || (iterator = _.identity);\n    var low = 0,\n        high = array.length;\n    while (low < high) {\n      var mid = (low + high) >> 1;\n      iterator(array[mid]) < iterator(obj) ? low = mid + 1 : high = mid;\n    }\n    return low;\n  };\n\n  // Safely convert anything iterable into a real, live array.\n  _.toArray = function(iterable) {\n    if (!iterable) return [];\n    if (iterable.toArray) return iterable.toArray();\n    if (_.isArray(iterable)) return slice.call(iterable);\n    if (_.isArguments(iterable)) return slice.call(iterable);\n    return _.values(iterable);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    return _.toArray(obj).length;\n  };\n\n  // Array Functions\n  // ---------------\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head`. The **guard** check allows it to work\n  // with `_.map`.\n  _.first = _.head = function(array, n, guard) {\n    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];\n  };\n\n  // Returns everything but the last entry of the array. Especcialy useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N. The **guard** check allows it to work with\n  // `_.map`.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array. The **guard** check allows it to work with `_.map`.\n  _.last = function(array, n, guard) {\n    return (n != null) && !guard ? slice.call(array, array.length - n) : array[array.length - 1];\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail`.\n  // Especially useful on the arguments object. Passing an **index** will return\n  // the rest of the values in the array from that index onward. The **guard**\n  // check allows it to work with `_.map`.\n  _.rest = _.tail = function(array, index, guard) {\n    return slice.call(array, (index == null) || guard ? 1 : index);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, function(value) {\n      return !!value;\n    });\n  };\n\n  // Return a completely flattened version of an array.\n  _.flatten = function(array, shallow) {\n    return _.reduce(array, function(memo, value) {\n      if (_.isArray(value)) return memo.concat(shallow ? value : _.flatten(value));\n      memo[memo.length] = value;\n      return memo;\n    }, []);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function(array) {\n    return _.difference(array, slice.call(arguments, 1));\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iterator) {\n    var initial = iterator ? _.map(array, iterator) : array;\n    var result = [];\n    _.reduce(initial, function(memo, el, i) {\n      if (0 == i || (isSorted === true ? _.last(memo) != el : !_.include(memo, el))) {\n        memo[memo.length] = el;\n        result[result.length] = array[i];\n      }\n      return memo;\n    }, []);\n    return result;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = function() {\n    return _.uniq(_.flatten(arguments, true));\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays. (Aliased as \"intersect\" for back-compat.)\n  _.intersection = _.intersect = function(array) {\n    var rest = slice.call(arguments, 1);\n    return _.filter(_.uniq(array), function(item) {\n      return _.every(rest, function(other) {\n        return _.indexOf(other, item) >= 0;\n      });\n    });\n  };\n\n  // Take the difference between one array and another.\n  // Only the elements present in just the first array will remain.\n  _.difference = function(array, other) {\n    return _.filter(array, function(value) {\n      return !_.include(other, value);\n    });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function() {\n    var args = slice.call(arguments);\n    var length = _.max(_.pluck(args, 'length'));\n    var results = new Array(length);\n    for (var i = 0; i < length; i++) results[i] = _.pluck(args, \"\" + i);\n    return results;\n  };\n\n  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),\n  // we need this function. Return the position of the first occurrence of an\n  // item in an array, or -1 if the item is not included in the array.\n  // Delegates to **ECMAScript 5**'s native `indexOf` if available.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = function(array, item, isSorted) {\n    if (array == null) return -1;\n    var i, l;\n    if (isSorted) {\n      i = _.sortedIndex(array, item);\n      return array[i] === item ? i : -1;\n    }\n    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item);\n    for (i = 0, l = array.length; i < l; i++) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.\n  _.lastIndexOf = function(array, item) {\n    if (array == null) return -1;\n    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) return array.lastIndexOf(item);\n    var i = array.length;\n    while (i--) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (arguments.length <= 1) {\n      stop = start || 0;\n      start = 0;\n    }\n    step = arguments[2] || 1;\n\n    var len = Math.max(Math.ceil((stop - start) / step), 0);\n    var idx = 0;\n    var range = new Array(len);\n\n    while (idx < len) {\n      range[idx++] = start;\n      start += step;\n    }\n\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n  // Reusable constructor function for prototype setting.\n  var ctor = function() {};\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Binding with arguments is also known as `curry`.\n  // Delegates to **ECMAScript 5**'s native `Function.bind` if available.\n  // We check for `func.bind` first, to fail fast when `func` is undefined.\n  _.bind = function bind(func, context) {\n    var bound, args;\n    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    if (!_.isFunction(func)) throw new TypeError;\n    args = slice.call(arguments, 2);\n    return bound = function() {\n      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));\n      ctor.prototype = func.prototype;\n      var self = new ctor;\n      var result = func.apply(self, args.concat(slice.call(arguments)));\n      if (Object(result) === result) return result;\n      return self;\n    };\n  };\n\n  // Bind all of an object's methods to that object. Useful for ensuring that\n  // all callbacks defined on an object belong to it.\n  _.bindAll = function(obj) {\n    var funcs = slice.call(arguments, 1);\n    if (funcs.length == 0) funcs = _.functions(obj);\n    each(funcs, function(f) {\n      obj[f] = _.bind(obj[f], obj);\n    });\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memo = {};\n    hasher || (hasher = _.identity);\n    return function() {\n      var key = hasher.apply(this, arguments);\n      return hasOwnProperty.call(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));\n    };\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function(func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function() {\n      return func.apply(func, args);\n    }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = function(func) {\n    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));\n  };\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time.\n  _.throttle = function(func, wait) {\n    var timeout, context, args, throttling, finishThrottle;\n    finishThrottle = _.debounce(function() {\n      throttling = false;\n    }, wait);\n    return function() {\n      context = this;\n      args = arguments;\n      var throttler = function() {\n        timeout = null;\n        func.apply(context, args);\n        finishThrottle();\n      };\n      if (!timeout) timeout = setTimeout(throttler, wait);\n      if (!throttling) func.apply(context, args);\n      if (finishThrottle) finishThrottle();\n      throttling = true;\n    };\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds.\n  _.debounce = function(func, wait) {\n    var timeout;\n    return function() {\n      var context = this,\n          args = arguments;\n      var throttler = function() {\n        timeout = null;\n        func.apply(context, args);\n      };\n      clearTimeout(timeout);\n      timeout = setTimeout(throttler, wait);\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = function(func) {\n    var ran = false,\n        memo;\n    return function() {\n      if (ran) return memo;\n      ran = true;\n      return memo = func.apply(this, arguments);\n    };\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return function() {\n      var args = [func].concat(slice.call(arguments));\n      return wrapper.apply(this, args);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var funcs = slice.call(arguments);\n    return function() {\n      var args = slice.call(arguments);\n      for (var i = funcs.length - 1; i >= 0; i--) {\n        args = [funcs[i].apply(this, args)];\n      }\n      return args[0];\n    };\n  };\n\n  // Returns a function that will only be executed after being called N times.\n  _.after = function(times, func) {\n    return function() {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  };\n\n  // Object Functions\n  // ----------------\n  // Retrieve the names of an object's properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n  _.keys = nativeKeys ||\n  function(obj) {\n    if (obj !== Object(obj)) throw new TypeError('Invalid object');\n    var keys = [];\n    for (var key in obj) if (hasOwnProperty.call(obj, key)) keys[keys.length] = key;\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    return _.map(obj, _.identity);\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      for (var prop in source) {\n        if (source[prop] !== void 0) obj[prop] = source[prop];\n      }\n    });\n    return obj;\n  };\n\n  // Fill in a given object with default properties.\n  _.defaults = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      for (var prop in source) {\n        if (obj[prop] == null) obj[prop] = source[prop];\n      }\n    });\n    return obj;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Internal recursive comparison function.\n\n\n  function eq(a, b, stack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.\n    if (a === b) return a !== 0 || 1 / a == 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if ((a == null) || (b == null)) return a === b;\n    // Unwrap any wrapped objects.\n    if (a._chain) a = a._wrapped;\n    if (b._chain) b = b._wrapped;\n    // Invoke a custom `isEqual` method if one is provided.\n    if (_.isFunction(a.isEqual)) return a.isEqual(b);\n    if (_.isFunction(b.isEqual)) return b.isEqual(a);\n    // Compare object types.\n    var typeA = typeof a;\n    if (typeA != typeof b) return false;\n    // Optimization; ensure that both values are truthy or falsy.\n    if (!a != !b) return false;\n    // `NaN` values are equal.\n    if (_.isNaN(a)) return _.isNaN(b);\n    // Compare string objects by value.\n    var isStringA = _.isString(a),\n        isStringB = _.isString(b);\n    if (isStringA || isStringB) return isStringA && isStringB && String(a) == String(b);\n    // Compare number objects by value.\n    var isNumberA = _.isNumber(a),\n        isNumberB = _.isNumber(b);\n    if (isNumberA || isNumberB) return isNumberA && isNumberB && +a == +b;\n    // Compare boolean objects by value. The value of `true` is 1; the value of `false` is 0.\n    var isBooleanA = _.isBoolean(a),\n        isBooleanB = _.isBoolean(b);\n    if (isBooleanA || isBooleanB) return isBooleanA && isBooleanB && +a == +b;\n    // Compare dates by their millisecond values.\n    var isDateA = _.isDate(a),\n        isDateB = _.isDate(b);\n    if (isDateA || isDateB) return isDateA && isDateB && a.getTime() == b.getTime();\n    // Compare RegExps by their source patterns and flags.\n    var isRegExpA = _.isRegExp(a),\n        isRegExpB = _.isRegExp(b);\n    if (isRegExpA || isRegExpB) {\n      // Ensure commutative equality for RegExps.\n      return isRegExpA && isRegExpB && a.source == b.source && a.global == b.global && a.multiline == b.multiline && a.ignoreCase == b.ignoreCase;\n    }\n    // Ensure that both values are objects.\n    if (typeA != 'object') return false;\n    // Arrays or Arraylikes with different lengths are not equal.\n    if (a.length !== b.length) return false;\n    // Objects with different constructors are not equal.\n    if (a.constructor !== b.constructor) return false;\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n    var length = stack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (stack[length] == a) return true;\n    }\n    // Add the first object to the stack of traversed objects.\n    stack.push(a);\n    var size = 0,\n        result = true;\n    // Deep compare objects.\n    for (var key in a) {\n      if (hasOwnProperty.call(a, key)) {\n        // Count the expected number of properties.\n        size++;\n        // Deep compare each member.\n        if (!(result = hasOwnProperty.call(b, key) && eq(a[key], b[key], stack))) break;\n      }\n    }\n    // Ensure that both objects contain the same number of properties.\n    if (result) {\n      for (key in b) {\n        if (hasOwnProperty.call(b, key) && !size--) break;\n      }\n      result = !size;\n    }\n    // Remove the first object from the stack of traversed objects.\n    stack.pop();\n    return result;\n  }\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b, []);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;\n    for (var key in obj) if (hasOwnProperty.call(obj, key)) return false;\n    return true;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType == 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray ||\n  function(obj) {\n    return toString.call(obj) == '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    return obj === Object(obj);\n  };\n\n  // Is a given variable an arguments object?\n  if (toString.call(arguments) == '[object Arguments]') {\n    _.isArguments = function(obj) {\n      return toString.call(obj) == '[object Arguments]';\n    };\n  } else {\n    _.isArguments = function(obj) {\n      return !!(obj && hasOwnProperty.call(obj, 'callee'));\n    };\n  }\n\n  // Is a given value a function?\n  _.isFunction = function(obj) {\n    return toString.call(obj) == '[object Function]';\n  };\n\n  // Is a given value a string?\n  _.isString = function(obj) {\n    return toString.call(obj) == '[object String]';\n  };\n\n  // Is a given value a number?\n  _.isNumber = function(obj) {\n    return toString.call(obj) == '[object Number]';\n  };\n\n  // Is the given value `NaN`?\n  _.isNaN = function(obj) {\n    // `NaN` is the only value for which `===` is not reflexive.\n    return obj !== obj;\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n  };\n\n  // Is a given value a date?\n  _.isDate = function(obj) {\n    return toString.call(obj) == '[object Date]';\n  };\n\n  // Is the given value a regular expression?\n  _.isRegExp = function(obj) {\n    return toString.call(obj) == '[object RegExp]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Utility Functions\n  // -----------------\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iterators.\n  _.identity = function(value) {\n    return value;\n  };\n\n  // Run a function **n** times.\n  _.times = function(n, iterator, context) {\n    for (var i = 0; i < n; i++) iterator.call(context, i);\n  };\n\n  // Escape a string for HTML interpolation.\n  _.escape = function(string) {\n    return ('' + string).replace(/&(?!\\w+;|#\\d+;|#x[\\da-f]+;)/gi, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/'/g, '&#x27;').replace(/\\//g, '&#x2F;');\n  };\n\n  // Add your own custom functions to the Underscore object, ensuring that\n  // they're correctly added to the OOP wrapper as well.\n  _.mixin = function(obj) {\n    each(_.functions(obj), function(name) {\n      addToWrapper(name, _[name] = obj[name]);\n    });\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = idCounter++;\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate: /<%([\\s\\S]+?)%>/g,\n    interpolate: /<%=([\\s\\S]+?)%>/g,\n    escape: /<%-([\\s\\S]+?)%>/g\n  };\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  _.template = function(str, data) {\n    var c = _.templateSettings;\n    var tmpl = 'var __p=[],print=function(){__p.push.apply(__p,arguments);};' + 'with(obj||{}){__p.push(\\'' + str.replace(/\\\\/g, '\\\\\\\\').replace(/'/g, \"\\\\'\").replace(c.escape, function(match, code) {\n      return \"',_.escape(\" + code.replace(/\\\\'/g, \"'\") + \"),'\";\n    }).replace(c.interpolate, function(match, code) {\n      return \"',\" + code.replace(/\\\\'/g, \"'\") + \",'\";\n    }).replace(c.evaluate || null, function(match, code) {\n      return \"');\" + code.replace(/\\\\'/g, \"'\").replace(/[\\r\\n\\t]/g, ' ') + \"__p.push('\";\n    }).replace(/\\r/g, '\\\\r').replace(/\\n/g, '\\\\n').replace(/\\t/g, '\\\\t') + \"');}return __p.join('');\";\n    var func = new Function('obj', tmpl);\n    return data ? func(data) : func;\n  };\n\n  // The OOP Wrapper\n  // ---------------\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n  var wrapper = function(obj) {\n    this._wrapped = obj;\n  };\n\n  // Expose `wrapper.prototype` as `_.prototype`\n  _.prototype = wrapper.prototype;\n\n  // Helper function to continue chaining intermediate results.\n  var result = function(obj, chain) {\n    return chain ? _(obj).chain() : obj;\n  };\n\n  // A method to easily add functions to the OOP wrapper.\n  var addToWrapper = function(name, func) {\n    wrapper.prototype[name] = function() {\n      var args = slice.call(arguments);\n      unshift.call(args, this._wrapped);\n      return result(func.apply(_, args), this._chain);\n    };\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    wrapper.prototype[name] = function() {\n      method.apply(this._wrapped, arguments);\n      return result(this._wrapped, this._chain);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    wrapper.prototype[name] = function() {\n      return result(method.apply(this._wrapped, arguments), this._chain);\n    };\n  });\n\n  // Start chaining a wrapped Underscore object.\n  wrapper.prototype.chain = function() {\n    this._chain = true;\n    return this;\n  };\n\n  // Extracts the result from a wrapped and chained object.\n  wrapper.prototype.value = function() {\n    return this._wrapped;\n  };\n\n})();","pre":true},"../../../browser/lib/runtimeBrowser/device/initialize.js":{"path":"../../../browser/lib/runtimeBrowser/device/initialize.js","friendlyPath":"runtimeBrowser.device.initialize","directory":"../../../browser/lib/runtimeBrowser/device/","filename":"initialize.js","src":"jsio(\"import device\");\njsio(\"from util.browser import $\");\n\nvar onResize;\n\nif (device.isMobileBrowser) {\n\tdevice.setUseDOM(true);\n\n\tvar screen = device.screen;\n\tif (device.isIOS || device.isAndroid) {\n\t\t\n\t\tvar _isFocused = false;\n\t\twindow.addEventListener('focus', function(e) {\n\t\t\tvar tag = e.target.tagName;\n\t\t\tif (tag == 'TEXTAREA' || tag == 'INPUT') {\n\t\t\t\t_isFocused = true;\n\t\t\t}\n\t\t}, true);\n\t\t\n\t\tdocument.addEventListener('blur', function(e) {\n\t\t\tif (_isFocused) {\n\t\t\t\t_isFocused = false;\n\t\t\t}\n\t\t}, true);\n\t\t\n\t\tdevice.hideAddressBar = function() {\n\t\t\tif (_isFocused || !device.isMobileBrowser || !(device.isIOS || device.isAndroid)) { return; }\n\t\t\tif (device.isIOS) {\n\t\t\t\twindow.scrollTo(0, 1);\n\t\t\t\twindow.scrollTo(0, 0);\n\t\t\t} else {\n\t\t\t\twindow.scrollTo(0, -1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (!CONFIG.unlockViewport) {\n\t\t\twindow.addEventListener('touchstart', bind(device, 'hideAddressBar'), true);\n\t\t}\n\t}\n\t\n\tvar lastWidth, lastHeight, lastOrientation;\n\tonResize = function() {\n\t\tif (device.isIOS) {\n\t\t\tdevice.hideAddressBar();\n\t\t}\n\t\t\n\t\tvar w = window.outerWidth;\n\t\tvar h = window.outerHeight;\n\t\tvar o = window.orientation;\n\t\tif (lastWidth == w && lastHeight == h && lastOrientation == o) { return; }\n\t\t\n\t\tlastWidth = w;\n\t\tlastHeight = h;\n\t\tlastOrientation = o;\n\t\t\n\t\tvar isPortrait = screen.isPortrait = (h > w);\n\t\tvar isLandscape = screen.isLandscape = !screen.isPortrait;\n\t\t\n\t\tvar totalW = (isPortrait ? screen.width : screen.height);\n\t\tvar totalH = (isPortrait ? screen.height : screen.width);\n//\t\tdocument.body.style.height = Math.max(screen.width, screen.height) + 'px';\n//\t\tdevice.hideAddressBar();\n\n\t\tvar innerWidth = window.innerWidth;\n\t\tvar innerHeight = window.innerHeight;\n\t\tif (device.width != innerWidth || device.height != innerHeight || device.orientation != o) {\n\t\t\tdevice.width = innerWidth;\n\t\t\tdevice.height = innerHeight;\n\t\t\tdevice.orientation = o;\n\t\t\tdevice.screen.publish('Resize', device.width, device.height, device.orientation);\n\t\t}\n\t}\n} else {\n\tonResize = function() {\n\t\tvar doc = window.document,\n\t\t\twidth = window.innerWidth || (doc.clientWidth || doc.clientWidth),\n\t\t\theight = window.innerHeight || (doc.clientHeight || doc.clientHeight);\n\t\t\n\t\tif (width != device.width || height != device.height) {\n\t\t\tdevice.width = width;\n\t\t\tdevice.height = height;\n\t\t\tdevice.screen.width = width;\n\t\t\tdevice.screen.height = height;\n\n\t\t\tif (width > height) {\n\t\t\t\tdevice.screen.isPortrait = false;\n\t\t\t\tdevice.screen.isLandscape = true;\n\t\t\t\tdevice.screen.orientation = 'landscape';\n\t\t\t} else {\n\t\t\t\tdevice.screen.isPortrait = true;\n\t\t\t\tdevice.screen.isLandscape = false;\n\t\t\t\tdevice.screen.orientation = 'portrait';\n\t\t\t}\n\n\t\t\tdevice.screen.publish('Resize', width, height);\n\t\t}\n\t}\n}\n\n$.onEvent(window, 'resize', onResize, false);\n$.onEvent(window, 'orientationchange', onResize, false);\n\nonResize();\n","pre":true},"../../../browser/lib/runtimeBrowser/device/Input.js":{"path":"../../../browser/lib/runtimeBrowser/device/Input.js","friendlyPath":".Input","directory":"../../../browser/lib/runtimeBrowser/device/","filename":"Input.js","src":"/**\n * package timestep.env.browser.Input;\n *\n * This is imported as timestep.input.InputListener. This binds touch or mouse\n * events on the document (depending on what's specified in device). \n * Additionally, if a canvas option is passed in or setElement(el) is called,\n * mouse over/out and start events are attached to the element. Used on the\n * canvas as well as DOM bindings.\n */\n\njsio(\"import device\");\njsio(\"from util.browser import $\");\n\njsio(\"import event.input.dispatch as input\");\nvar eventTypes = input.eventTypes;\n\n// import ...FPSCounter;\n\nvar UID = -1;\n\nvar browser_lib_runtimeBrowser_device_Input=__class__;exports=browser_lib_runtimeBrowser_device_Input(function browser_lib_runtimeBrowser_device_Input(){return this.init&&this.init.apply(this,arguments)},function(supr) {\n\t\n\tthis.init = function(opts) {\n\n\t\tif (device.simulatingMobileNative || device.simulatingMobileBrowser) { this._simulateMobile = true; }\n\t\t\n\t\tthis._evtQueue = [];\n\t\t\n\t\tif (opts.el) {\n\t\t\tif (device.isMobileBrowser) {\n\t\t\t\tthis._toggleNode = $({parent:document.body});\n\t\t\t}\n\t\t\tthis.setElement(opts.el);\n\t\t}\n\n\t\t// Mouseover/out events do not fire for mobile browsers\n\t\t// that are driven solely by touch events, so in mobile\n\t\t// browsers, assume the canvas should always handle events.\n\t\t// Otherwise, only handle events if the mouse is over the\n\t\t// canvas.\n\t\tthis._isOver = false;\n\n\t\t// disable the key listener on focus of input elements\n\t\tthis._keyListener = opts.keyListener;\n\n\t\tif (device.useDOM) {\n\t\t\t$.onEvent(document, device.events.start, this, 'handleMouse', eventTypes.START);\n\t\t}\n\t\t\n\t\tthis.enable();\n\t\t\n\t\t// this._evtFps = new FPSCounter({name: \"mouse events\"});\n\t\t\n\t\tthis._hasFocus = false;\n\t\tif (document.addEventListener) {\n\t\t\tdocument.addEventListener('focus', bind(this, 'onFocusCapture'), true);\n\t\t\tdocument.addEventListener('blur', bind(this, 'onBlurCapture'), true);\n\t\t}\n\t}\n\n\tthis.enable = function() {\n\t\tthis._handleMove = $.onEvent(document, device.events.move, this, 'handleMouse', eventTypes.MOVE);\n\t\tthis._handleSelect = $.onEvent(document, device.events.end, this, 'handleMouse', eventTypes.SELECT);\n\t\tthis._handleScroll = $.onEvent(window, 'DOMMouseScroll', this, 'handleMouse', eventTypes.SCROLL); // FF\n\t\tthis._handleWheel = $.onEvent(window, 'mousewheel', this, 'handleMouse', eventTypes.SCROLL); // webkit\n\t};\n\n\tthis.disable = function() {\n\t\tif (this._handleMove) {\n\t\t\tthis._handleMove();\n\t\t\tthis._handleMove = false;\n\t\t}\n\t\tif (this._handleSelect) {\n\t\t\tthis._handleSelect();\n\t\t\tthis._handleSelect = false;\n\t\t}\n\t\tif (this._handleScroll) {\n\t\t\tthis._handleScroll();\n\t\t\tthis._handleScroll = false;\n\t\t}\n\t\tif (this._handleWheel) {\n\t\t\tthis._handleWheel();\n\t\t\tthis._handleWheel = false;\n\t\t}\n\t};\n\t\n\tthis.onFocusCapture = function(e) {\n\t\tvar tag = e.target.tagName;\n\t\tif (tag == 'TEXTAREA' || tag == 'INPUT') {\n\t\t\tthis._hasFocus = e.target;\n\t\t\tthis._keyListener && this._keyListener.setEnabled(false);\n\t\t}\n\t}\n\t\n\tthis.onBlurCapture = function(e) {\n\t\tif (this._hasFocus) {\n\t\t\tthis._hasFocus = null;\n\t\t\tthis._keyListener && this._keyListener.setEnabled(true);\n\t\t}\n\t}\n\t\n\tthis.setElement = function(el) {\n\t\tthis._el = el;\n\t\t\n\t\tif (this._elEvents) {\n\t\t\tfor(var i = 0, detach; detach = this._elEvents[i]; ++i) {\n\t\t\t\tdetach();\n\t\t\t}\n\t\t}\n\t\t\n\t\tel.ondragstart = function() { return false; }\n\t\tel.onselectstart = function() { return false; }\n\t\t\n\t\tthis._elEvents = [];\n\t\t\n\t\tif (!device.useDOM) {\n\t\t\tthis._elEvents.push($.onEvent(el, device.events.start, this, 'handleMouse', eventTypes.START));\n\t\t}\n\t\t\n\t\tif (!device.isMobileBrowser && !device.isNative) {\n\t\t\tthis._elEvents.push($.onEvent(el, 'mouseover', this, 'onMouseOver'));\n\t\t\tthis._elEvents.push($.onEvent(el, 'mouseout', this, 'onMouseOut'));\n\t\t}\n\t}\n\t\n\tthis.onMouseOver = function() { this._isOver = true; }\n\tthis.onMouseOut = function() { this._isOver = false; }\n\tthis.onMouseDown = function() { this._isMouseDown = true; }\n\tthis.onMouseUp = function() { this._isMouseUp = true; }\n\t\n\tthis.getEvents = function() { return this._evtQueue.splice(0, this._evtQueue.length); }\n\t\n\tthis.allowScrollEvents = function(allowScrollEvents) { this._allowScrollEvents = allowScrollEvents; }\n\t\n\tvar empty = function() {};\n\n\tthis.handleMouse = function(type, evt, recursive) {\n\t\tvar target = evt.target;\n\t\tif (this._hasFocus && this._hasFocus == target || target && target.getAttribute && target.getAttribute('noCapture')) { return; }\n\t\t\n\t\t// if (!recursive) {\n\t\t// \t// remove the empty callback to log the raw mouse event fps\n\t\t// \tthis._evtFps.tick(empty);\n\t\t// }\n\t\t\n\t\tvar isMobileBrowser = device.isMobileBrowser;\n\t\t\n\t\tif (!device.useDOM && !isMobileBrowser && !this._isDown && this._el && evt.target != this._el) { return; }\n\t\t\n\t\t// Cancel all events that occur on the canvas.  Optionally, pass scroll events\n\t\t// through to the page (apps that don't care about handling scroll events may\n\t\t// want to pass them through for easier browser debugging).\n\t\tif (isMobileBrowser) {\n\t\t\t$.stopEvent(evt);\n\t\t\tevt.returnValue = false;\n\t\t} else if (this._isOver && (!this._allowScrollEvents || type != eventTypes.SCROLL)) {\n\t\t\tif (evt.stopPropagation) { evt.stopPropagation(); }\n\t\t\tif (type != eventTypes.START) {\n\t\t\t\t$.stopEvent(evt);\n\t\t\t\tevt.returnValue = false;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// On ios devices, this event could correspond to multiple touches.  We recall\n\t\t// ourselves with each changed touch independently.\n\t\tif (evt.touches) {\n\t\t\tfor (var i = 0, t; t = evt.changedTouches[i]; ++i) {\n\t\t\t\tthis.handleMouse(type, t, true);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tvar x, y;\n\t\t// Figure out where in the canvas the event fired.\n\t\t// if (isMobileBrowser) {\n\t\t// \tpt = {\n\t\t// \t\tx: evt.pageX,\n\t\t// \t\ty: evt.pageY\n\t\t// \t};\n\t\t// } else \n\t\tif ('offsetX' in evt && !device.useDOM) {\n\t\t\t// Chrome makes life easy.  offsetX/offsetY is w.r.t. the target, which\n\t\t\t// for us should be the canvas.\n\t\t\tx = evt.offsetX;\n\t\t\ty = evt.offsetY;\n\t\t} else if (this._el.getBoundingClientRect) {\n\t\t\t// It's not too hard in other browsers that support getBoundingClientRect.\n\t\t\t// Get the absolute position of the canvas and do the math.\n\t\t\tvar rect = this._el.getBoundingClientRect();\n\t\t\tx = evt.pageX - rect.left;\n\t\t\ty = evt.pageY - rect.top;\n\t\t} else {\n\t\t\t// Without boundingClientRect, life is hard.  This is the general\n\t\t\t// idea, but we need to loop for offsetParent/scrollLeft/scrollTop\n\t\t\t// to be at least partially complete.  Other libraries handle this\n\t\t\t// better, but the code complexity for that is huge.\n\t\t\t// \n\t\t\t// TODO: older browsers will fail cause this code is buggy and untested?\n\t\t\tvar offsetX, offsetY, parent = this._el;\n\t\t\twhile (parent) {\n\t\t\t\toffsetX += parent.offsetTop;\n\t\t\t\toffsetY += parent.offsetLeft;\n\t\t\t\tparent = parent.parentNode;\n\t\t\t}\n\t\t\t\n\t\t\tx = evt.pageX - offsetX;\n\t\t\ty = evt.pageY - offsetY;\n\t\t}\n\t\t\n\t\tvar id = evt.identifier || UID;\n\t\t\n\t\tif (this._simulateMobile) {\n\t\t\tswitch (type) {\n\t\t\t\tcase eventTypes.START:\n\t\t\t\t\tthis._moveOK = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase eventTypes.MOVE:\n\t\t\t\t\tif (!this._moveOK) { return; }\n\t\t\t\t\tbreak;\n\t\t\t\tcase eventTypes.SELECT:\n\t\t\t\t\tthis._moveOK = false;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (type == eventTypes.START) {\n\t\t\tthis._isDown = true;\n\t\t} else if (type == eventTypes.SELECT) {\n\t\t\tthis._isDown = false;\n\t\t\t\n\t\t\tif (this._toggleNode) {\n\t\t\t\tdocument.body.removeChild(this._toggleNode);\n\t\t\t\tdocument.body.appendChild(this._toggleNode);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar inputEvent = new input.InputEvent(id, type, x, y);\n\t\tif (device.useDOM) {\n\t\t\twhile (target && !target._view) {\n\t\t\t\ttarget = target.parentNode;\n\t\t\t}\n\t\t\tif (!target) { return; }\n\t\t\tinputEvent.target = target._view;\n\t\t}\n\t\t\n\t\tif (type == eventTypes.SCROLL) {\n\t\t\t// try to normalize scroll events! :-(\n\t\t\t\n\t\t\t// some browsers send both horizontal and vertical offsets in one event! nice!\n\t\t\t// other browsers don't. This is awful, since this is the least common denominator!\n\t\t\t// so we have to send two events even if the browser only sends one.\n\t\t\tif ('wheelDeltaX' in evt) {\n\t\t\t\t// default to Y\n\t\t\t\tinputEvent.scrollDelta = evt.wheelDeltaY / 120;\n\t\t\t\tinputEvent.scrollAxis = input.VERTICAL_AXIS;\n\n\t\t\t\t// if we also have X, then send it as a separate event\n\t\t\t\tif (evt.wheelDeltaX && evt.wheelDeltaY) {\n\t\t\t\t\tvar e = inputEvent.clone();\n\t\t\t\t\te.scrollDelta = evt.wheelDeltaX / 120;\n\t\t\t\t\te.scrollAxis = input.HORIZONTAL_AXIS;\n\t\t\t\t\tthis._evtQueue.push(e);\n\t\t\t\t} else if (evt.wheelDeltaX) {\n\t\t\t\t\t// we only have one of (X, Y) and it's X, so use X\n\t\t\t\t\tinputEvent.scrollDelta = evt.wheelDeltaX / 120;\n\t\t\t\t\tinputEvent.scrollAxis = input.HORIZONTAL_AXIS;\n\t\t\t\t}\n\n\t\t\t} else if (evt.detail) {\n\t\t\t\tinputEvent.scrollDelta = -evt.detail;\n\t\t\t\tinputEvent.scrollAxis = 'axis' in evt ? evt.axis == evt.VERTICAL_AXIS ? input.VERTICAL_AXIS : input.HORIZONTAL_AXIS : input.VERTICAL_AXIS;\n\t\t\t} else if (evt.wheelDelta) { // IE/Opera\n\t\t\t\tinputEvent.scrollDelta = (window.opera ? 1 : -1) * evt.wheelDelta / 120;\n\t\t\t\tinputEvent.scrollAxis = input.VERTICAL_AXIS;\n\t\t\t}\n\t\t}\n\n\t\tthis._evtQueue.push(inputEvent);\n\t}\n\t\n});\n","pre":true},"../../../browser/lib/runtimeBrowser/device/InputPrompt.js":{"path":"../../../browser/lib/runtimeBrowser/device/InputPrompt.js","friendlyPath":".InputPrompt","directory":"../../../browser/lib/runtimeBrowser/device/","filename":"InputPrompt.js","src":"/**\n * package timestep.env.browser.InputPrompt;\n *\n * Prompt the user manually for input.\n *\n * ??? TODO Move this to debug, probably. A native modal prompt has no place\n *          in game code.\n */\n\nvar browser_lib_runtimeBrowser_device_InputPrompt=__class__;exports=browser_lib_runtimeBrowser_device_InputPrompt(function browser_lib_runtimeBrowser_device_InputPrompt(){return this.init&&this.init.apply(this,arguments)},function() {\n\tvar defaults = {\n\t\tonChange: function() {},\n\t\ttitle: '',\n\t\tmessage: '',\n\t\tvalue: '',\n\t\tprompt: ''\n\t}\n\n\tthis.init = function(opts) {\n\t\topts = merge(opts, defaults);\n\t\tthis.onChange = opts.onChange;\n\t\tthis._value = opts.value;\n\t\tthis._message = opts.title || opts.message || opts.prompt;\n\t}\n\n\tthis.show = function() {\n\t\tvar value = window.prompt(this._message, this._value);\n\t\tif (value !== null) { // returns null if user presses cancel\n\t\t\tthis._value = value;\n\t\t\tthis.onChange(value);\n\t\t} else {\n\t\t\t// TODO: do something else on cancel?\n\t\t\tthis.onChange(value);\n\t\t}\n\t}\n\n\tthis.getValue = function() {\n\t\treturn this._value;\n\t}\n\n\tthis.setMessage = function(message) {\n\t\tthis._message = message;\n\t}\n});\n","pre":true},"../../../browser/lib/runtimeBrowser/device/KeyListener.js":{"path":"../../../browser/lib/runtimeBrowser/device/KeyListener.js","friendlyPath":".KeyListener","directory":"../../../browser/lib/runtimeBrowser/device/","filename":"KeyListener.js","src":"/**\n * package timestep.env.browser.KeyListener;\n *\n * Listen to pressed keys and expose them using a altogether too public API.\n * An independent KeyListener is exposed for the Application Engine and any\n * Views with a Focus Manager.\n */\n\njsio(\"import lib.PubSub as PubSub\");\njsio(\"import lib.Enum\");\n\njsio(\"import event.input.keys as keyConstants\");\njsio(\"import device\");\njsio(\"import timer\");\n\njsio(\"from util.browser import $\");\n\nvar gListenerSingleton = null;\nvar gCancelKeys = lib.Enum(keyConstants.SPACE, keyConstants.LEFT, keyConstants.RIGHT, keyConstants.UP, keyConstants.DOWN);\n\nvar browser_lib_runtimeBrowser_device_KeyListener=__class__;exports=browser_lib_runtimeBrowser_device_KeyListener(function browser_lib_runtimeBrowser_device_KeyListener(){return this.init&&this.init.apply(this,arguments)},function() {\n\tthis.init = function(el, events) {\n\t\tif (gListenerSingleton) { return gListenerSingleton; }\n\t\tgListenerSingleton = this;\n\t\t\n\t\tthis._el = el = el || document;\n\t\tthis._events = [];\n\t\tthis._shortcuts = [];\n\t\tthis._isEnabled = true;\n\t\tthis._keyMap = {};\n\t\t\n\t\t$.onEvent(el, 'keydown', this, 'onKeyDown');\n\t\t$.onEvent(el, 'keypress', this, 'onKeyPress');\n\t\t$.onEvent(el, 'keyup', this, 'onKeyUp');\n\t\t$.onEvent(window, 'blur', this, 'liftAll');\n\t}\n\t\n\tthis.setEnabled = function(isEnabled) { this._isEnabled = isEnabled; }\n\n\tthis.captureShortcut = function(shortcut) {\n\t\tthis._shortcuts.push(shortcut);\n\t}\n\t\n\tthis.getPressed = function() { return this._keyMap; }\n\n\tthis.onKeyDown = function(e) {\n\t\t\n\t\tif (!this._isEnabled) { return; }\n\t\t\n\t\tvar evt = {\n\t\t\tcode: e.keyCode,\n\t\t\tctrl: e.ctrlKey,\n\t\t\tshift: e.shiftKey,\n\t\t\talt: e.altKey,\n\t\t\tmeta: e.metaKey, // for mac keyboards\n\t\t\tlifted: false,\n\t\t\tdt: timer.getTickProgress()\n\t\t};\n\t\t\n\t\tif (evt.ctrl || evt.shift || evt.alt || evt.meta) {\n\t\t\tvar captured = false;\n\t\t\tfor (var i = 0, s; s = this._shortcuts[i]; ++i) {\n\t\t\t\tif (s.compare(evt)) {\n\t\t\t\t\ts.publish('Down', evt);\n\t\t\t\t\tcaptured = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (captured) { $.stopEvent(e); }\n\t\t\treturn;\n\t\t} else {\n\t\t\t// MUST cancel event if we're enabled to prevent browser\n\t\t\t// default behaviors (e.g. scrolling)\n\t\t\t$.stopEvent(e);\n\t\t}\n\t\t\n\t\t// We already know that key is down; ignore repeat events.\n\t\tif (e.keyCode in this._keyMap) { return; }\n\t\t\n\t\tthis._events.push(evt);\n\t\tthis._keyMap[e.keyCode] = +new Date();\n\t}\n\t\n\tthis.liftAll = function() {\n\t\tvar progressDt = timer.getTickProgress();\n\t\tfor (var code in this._keyMap) {\n\t\t\tthis._events.push({\n\t\t\t\tcode: code,\n\t\t\t\tlifted: true,\n\t\t\t\tdt: progressDt\n\t\t\t});\n\t\t}\n\t\tthis._keyMap = {};\n\t}\n\t\n\tthis.onKeyUp = function(e) {\n\t\tvar progressDt = timer.getTickProgress();\n\t\tdelete this._keyMap[e.keyCode];\n\t\tthis._events.push({\n\t\t\tcode: e.keyCode,\n\t\t\tlifted: true,\n\t\t\tdt: progressDt\n\t\t});\n\t\t$.stopEvent(e);\n\t}\n\t\n\tthis.onKeyPress = function(e) {\n\t\tif (!this._isEnabled) { return; }\n\t\tif (e.keyCode in gCancelKeys) {\n\t\t\t$.stopEvent(e);\n\t\t}\n\t}\n\t\n\tthis.peekEvents = function() { return this._events; }\n\tthis.popEvents = function() { return this._events.splice(0, this._events.length); }\n});\n\n// TODO: for maximum compatibility, especially with foreign keyboards, this needs to be inferred from the browser.  I think we can rely on a single DOM key event to get the constants in most browsers.\nmerge(exports.prototype, keyConstants);\n\nexports.Shortcut=__class__;exports.Shortcut=exports.Shortcut(function exports_Shortcut(){return this.init&&this.init.apply(this,arguments)},PubSub, function() {\n\tthis.init = function(keyCode, ctrl, shift, alt, meta) {\n\t\tthis.ctrl = !!ctrl;\n\t\tthis.shift = !!shift;\n\t\tthis.alt = !!alt;\n\t\tthis.meta = !!meta;\n\t\tthis.code = !!keyCode;\n\t}\n\t\n\tthis.compare = function(shortcut) {\n\t\treturn this.ctrl == shortcut.ctrl \n\t\t\t&& this.alt == shortcut.alt\n\t\t\t&& this.meta == shortcut.meta\n\t\t\t&& this.shift == shortcut.shift\n\t\t\t&& this.code == shortcut.code;\n\t}\n});\n","pre":true},"../../../../sdk/timestep/event/input/keys.js":{"path":"../../../../sdk/timestep/event/input/keys.js","friendlyPath":"event.input.keys","directory":"../../../../sdk/timestep/event/input/","filename":"keys.js","src":"/**\n * @module event.input.keys\n * Map browser keycodes to corresponding keys.\n */\n\nexports = {\n\tBACKSPACE: 8,\n\tTAB: 9,\n\tENTER: 13,\n\tSHIFT: 16,\n\tCTRL: 17,\n\tALT: 18,\n\tPAUSE: 19,\n\tBREAK: 19,\n\tCAPS: 20,\n\tCAPS_LOCK: 20,\n\tESCAPE: 27,\n\tSPACE: 32,\n\tPAGE_UP: 33,\n\tPAGE_DOWN: 34,\n\tEND: 35,\n\tHOME: 36,\n\tLEFT: 37,\n\tUP: 38,\n\tRIGHT: 39,\n\tDOWN: 40,\n\tPRINT_SCREEN: 44,\n\tINSERT: 45,\n\tDELETE: 46,\n\tMETA_LEFT: 91,\n\tWIN_LEFT: 91,\n\tMETA_RIGHT: 92,\n\tWIN_RIGHT: 92,\n\tSELECT: 93,\n\tEQUAL: 187,\n\tMINUS: 189,\n\tF1: 112,\n\tF2: 113,\n\tF3: 114,\n\tF4: 115,\n\tF5: 116,\n\tF6: 117,\n\tF7: 118,\n\tF8: 119,\n\tF9: 120,\n\tF10: 121,\n\tF11: 122,\n\tF12: 123,\n\tMUTE: 173,\n\tVOL_DOWN: 174,\n\tVOL_UP: 175,\n\tFORWARD: 176,\n\tBACK: 177,\n\tSTOP: 178,\n\tPLAY_PAUSE: 179\n};\n","pre":true},"../../../browser/lib/runtimeBrowser/device/MobileBrowserAPI.js":{"path":"../../../browser/lib/runtimeBrowser/device/MobileBrowserAPI.js","friendlyPath":".MobileBrowserAPI","directory":"../../../browser/lib/runtimeBrowser/device/","filename":"MobileBrowserAPI.js","src":"jsio(\"import lib.PubSub\");\njsio(\"import device\");\njsio(\"from util.underscore import _\");\n\n/**\n * @extends lib.PubSub\n */\nvar browser_lib_runtimeBrowser_device_MobileBrowserAPI=__class__;var AudioAPI = exports=browser_lib_runtimeBrowser_device_MobileBrowserAPI(function browser_lib_runtimeBrowser_device_MobileBrowserAPI(){return this.init&&this.init.apply(this,arguments)},lib.PubSub, function(supr) {\n\n\tvar defaults = {\n\t\toneChannelOnly: device.isMobileBrowser,\n\t\tcompiledFilename: 'compiled'\n\t};\n\n\tthis.init = function(opts) {\n\t\topts = merge(opts, defaults);\n\t\tsupr(this, 'init', [opts]);\n\t\tthis._opts = opts;\n\t\tthis._map = opts.map;\n\t\tthis._audios = {};\n\t\tthis.oneChannelOnly = opts.oneChannelOnly;\n\n\t\tsetInterval(bind(this, '_ontimeupdate'), 200);\n\t\t\n\t\tif (!this.oneChannelOnly) {\n\t\t\t_.each(opts.background, function(name) {\n\t\t\t\topts.map[name] = {'name': name}\n\t\t\t}, this);\n\t\t}\n\n\t\t// Install the event listener right away. Set usecapture=true so that\n\t\t// nothing else will affect us from intercepting this event.\n\n\t\tthis._load();\n\t\tif (this.oneChannelOnly) {\n\t\t\tthis._boundLoadHandler = bind(this, '_playFirst');\n\t\t\tdocument.body.addEventListener(device.events.start, \n\t\t\t\t\t\t\t\t\t\t   this._boundLoadHandler, true);\n\t\t}\n\t\twindow.addEventListener('pagehide', bind(this, 'pause'), false);\n\t}\n\n\tthis._createChannel = function(name, src) {\n\t\tvar audio = new Audio(src);\n\t\tthis._audios[name] = audio;\n\n\t\taudio.addEventListener('error', bind(this, '_onerror'));\n\t\taudio.addEventListener('timeupdate', bind(this, '_ontimeupdate'));\n\n\t\taudio.load();\n\t}\n\n\tthis.setMuted = function(muted) {\n\t\tthis.muted = muted;\n\t\tif (muted) {\n\t\t\tthis.setVolume(0);\n\t\t}\n\t}\n\t\n\tthis.setVolume = function(volume) {\n\t\t_.each(this._audios, function(audio, key) {\n\t\t\taudio.volume = volume;\n\t\t});\n\t}\n\n\tthis.unload = function() {\n\t\tthis.pause();\n\t\t_.each(this._audios, function(audio, key) {\n\t\t\taudio.src = '';\n\t\t}, this);\n\t\t// TODO remove event listeners\n\t}\n\n\tthis._load = function() {\n\t\n\t\tthis._audios = {};\n\t\tvar path = this._opts.path.replace(/\\/$/, '');\n\t\tif (this.oneChannelOnly) {\n\t\t\tthis._createChannel('AUDIO', path + '/' + this._opts.compiledFilename + '.m4a');\n\t\t} else {\n\t\t\tfor (var key in this._map) if (this._map.hasOwnProperty(key)) {\n\t\t\t\tif (key == 'SILENCE') { continue; }\n\t\t\t\tthis._createChannel(key, path + '/' + key + '.mp3');\n\t\t\t}\n\t\t}\n\n\t\tlogger.info('now loading', this._opts.src);\n\n\t\tif (!this._publishedReady) {\n\t\t\tthis.publish('Ready'); // this is as close as we'll get with multiple sounds\n\t\t\tthis._publishedReady = true;\n\t\t}\n\t}\n\n\tthis._playFirst = function() {\n\t\tdocument.body.removeEventListener(device.events.start, \n\t\t\t\t\t\t\t\t\t\t  this._boundLoadHandler, true);\n\t\t\n\t\tthis._audios['AUDIO'].play();\n\t}\n\n\tthis._ontimeupdate = function(evt) {\n\t\t_.each(this._audios, function(audio, key) {\n\t\t\tif (audio.paused && !audio._pausedOnce) {\n\t\t\t\taudio.pause();\n\t\t\t\taudio._pausedOnce = true;\n\t\t\t\taudio._ready = true;\n\t\t\t}\n\n\t\t\tif (this.oneChannelOnly) {\n\t\t\t\tif (!this._nowPlaying || audio.currentTime >= this._nowPlaying.end) {\n\t\t\t\t\tthis.play('SILENCE');\n\t\t\t\t}\n\t\t\t}\n\t\t}, this);\n\n\t}\n\t\n\tthis._onerror = function(event) {\n\t\tvar s = '';\n\t\tfor (var key in event) {\n\t\t\ts += event[key] + ' ';\n\t\t}\n\t\tlogger.info('ERROR', s);\n\t\t// this.unload();\n\t\t// this.publish('AudioError', event);\n\t\t// this._status = 'error';\n\t}\n\n\tthis.canPlay = function(name) {\n\t\tif (!this._map[name]) { return false; }\n\n\t\tvar requiredEnd = null;\n\t\tif (this.oneChannelOnly) {\n\t\t\trequiredEnd = this._map[name].end;\n\t\t\tname = 'AUDIO';\n\t\t}\n\t\tvar audio = this._audios[name];\n\t\tif (!audio) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// if (!audio._ready) {\n\t\t// \treturn; // try downloading the whole file...\n\t\t// }\n\t\tif (audio._ready || !requiredEnd) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tvar end = audio.seekable.end()\n\t\t\t\treturn (requiredEnd <= end);\n\t\t\t} catch(e) {\n\t\t\t\tlogger.log(e);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\tthis.play = function(name, volume, loop) {\t\t\n\t\tif (this.muted) { return; }\n\n\t\tif (volume === undefined) {\n\t\t\tvolume = 1.0;\n\t\t}\n\t\tif (!this.canPlay(name)) {\n\t\t\tlogger.info('Not ready yet');\n\t\t\treturn;\n\t\t}\n\n\t\tvar audio = this._audios[this.oneChannelOnly ? 'AUDIO' : name];\n\t\ttry {\n\t\t\tif (!audio.paused) {\n\t\t\t\taudio.pause(); // it glitches if you move currentTime while playing?\n\t\t\t}\n\t\t\tvar startTime = 0;\n\t\t\tif (this.oneChannelOnly && this._map[name].start != null) {\n\t\t\t\tstartTime = this._map[name].start;\n\t\t\t}\n\t\t\tif (audio.currentTime != startTime) {\n\t\t\t\t// logger.log('SEEK to play',name, startTime, 'from',audio.currentTime); // \n\t\t\t\taudio.currentTime = startTime;\n\t\t\t}\n\t\t\taudio.volume = volume;\n\t\t\taudio.play();\n\t\t\tthis._nowPlaying = this._map[name];\n\t\t} catch(e) {\n\t\t\t\n\t\t}\n\t}\n\t\n\tthis.pause = function() {\n\t\t_.each(this._audios, function(audio, key) {\n\t\t\taudio.pause();\n\t\t}, this);\n\t}\n\n\tthis.playBackgroundMusic = function(name, volume) {\n\t\tif (this.muted) { return; }\n\n\t\tif (this.oneChannelOnly) {\n\t\t\treturn false; // cannot play bg music here.\n\t\t}\n\n\t\tthis._backgroundSoundPlaying = name;\n\t\tthis.play(name, volume);\n\t}\n\n\tthis.pauseBackgroundMusic = function() {\n\t\tif (!this._backgroundSoundPlaying) { return; }\n\t\tthis._audios[this._backgroundSoundPlaying].pause();\n\t}\n\n});\n","pre":true},"../../../browser/lib/runtimeBrowser/device/TextBox.js":{"path":"../../../browser/lib/runtimeBrowser/device/TextBox.js","friendlyPath":".TextBox","directory":"../../../browser/lib/runtimeBrowser/device/","filename":"TextBox.js","src":"\"use import\";\n\n/**\n * package timestep.env.browser.TextBox;\n *\n * A textbox for inputting user data.\n */\n\njsio(\"from util.browser import $\");\n\nvar browser_lib_runtimeBrowser_device_TextBox=__class__;exports=browser_lib_runtimeBrowser_device_TextBox(function browser_lib_runtimeBrowser_device_TextBox(){return this.init&&this.init.apply(this,arguments)},function() {\n\t\n\tvar defaultStyle = {\n\t\tpadding: 0,\n\t\tlineHeight: 1.4,\n\t\tborder: 'none',\n\t\tdisplay: 'none',\n\t\ttextAlign: 'center',\n\t\tverticalAlign: 'middle',\n\t\tfontSize: 16,\n\t\tfontFamily: null,\n\t\tfontWeight: '',\n\t\topacity: 1,\n\t\tposition: \"absolute\",\n\t\tbackgroundColor: \"transparent\",\n\t\ttop: 0,\n\t\tleft: 0\n\t};\n\t\n\tthis.init = function(opts) {\n\t\topts = merge(opts, {\n\t\t\tcolor: 'black',\n\t\t\theight: 20\n\t\t});\n\n\t\tvar style = merge({}, defaultStyle);\n\t\tif (opts.color) { style.color = opts.color; }\n\t\t\n\t\tthis._el = $({\n\t\t\ttag: opts.multiLine ? \"textarea\" : \"input\",\n\t\t\tattrs: {type: \"text\"}, \n\t\t\tstyle: style\n\t\t});\n\n\t\t$.onEvent(this._el, 'blur', this, 'onBlur');\n\t\t$.onEvent(this._el, 'focus', this, 'onFocus');\n\t\t$.onEvent(this._el, 'change', this, 'onChange');\n\t\t$.onEvent(this._el, 'click', this, 'onClick');\n\t}\n\t\n\tthis.onBlur = \n\tthis.onFocus =\n\tthis.onChange =\n\tthis.onClick = function() {}\n\t\n\tthis.destroy = function() {\n\t\t$.remove(this._el);\n\t\tthis._el = null;\n\t}\n\t\n\tthis.setApp = function(app) {\n\t\tif (app != this._app || !this._el.parentNode) {\n\t\t\tthis._app = app;\n\t\t\tvar canvas = app._ctx.canvas;\n\t\t\tlogger.log('setting parent', this._el);\n\t\t\tcanvas.parentNode.appendChild(this._el);\n\t\t}\n\t}\n\t\n\tthis.change = function() {\n\t\t\n\t}\n\t\n\tthis.click = function() {\n\t}\n\t\n\tthis.selectAll = function() {\n\t\tthis._el.focus();\n\t\tthis._el.select();\n\t}\n\t\n\tthis.show = function() { $.show(this._el); }\n\tthis.hide = function() { $.hide(this._el); }\n\t\n\tthis.setValue = function(value) { this._el.value = value; return this; }\n\tthis.setOpacity = function(o) { this._el.style.opacity = o; return this; }\n\tthis.setType = function(type) { this._el.type = type; return this; }\n\tthis.setVisible = function(isVisible) { return this[isVisible ? 'show': ' hide'](); }\n\tthis.getX = function() { return parseInt(this._el.style.left); }\n\tthis.getY = function() { return parseInt(this._el.style.top); }\n\tthis.getWidth = function() { return this._el.offsetWidth; }\n\tthis.getHeight = function() { return this._el.offsetHeight; }\n\tthis.getValue = function() { return this._el.value; }\n\tthis.getOpacity = function() { return this._el.style.opacity; }\n\tthis.getType = function() { return this._el.type; }\n\tthis.getVisible = function() { return this._el.parentNode && this._el.style.display == 'block'; }\n\t\n\tthis.setPosition = function(p) { this._el.style.top = p.y + 'px'; this._el.style.left = p.x + 'px'; }\n\tthis.getPosition = function() { return {x: this.getX(), y: this.getY()}; }\n\t\n\tthis.setDimensions = function(d) { this._el.style.width = d.width + 'px'; this._el.style.height = d.height + 'px'; return this; }\n\tthis.getDimensions = function() { return {width: this.getWidth(), height: this.getHeight()}; }\n});\n","pre":true},"../../../browser/lib/runtimeBrowser/device/TextInput.js":{"path":"../../../browser/lib/runtimeBrowser/device/TextInput.js","friendlyPath":".TextInput","directory":"../../../browser/lib/runtimeBrowser/device/","filename":"TextInput.js","src":"\"use import\";\n\n/**\n * package timestep.env.browser.TextInput;\n *\n * A textbox for inputting user data.\n */\n\njsio(\"import lib.PubSub\");\njsio(\"from util.browser import $\");\n\n/**\n * @extends lib.PubSub\n */\nvar browser_lib_runtimeBrowser_device_TextInput=__class__;exports=browser_lib_runtimeBrowser_device_TextInput(function browser_lib_runtimeBrowser_device_TextInput(){return this.init&&this.init.apply(this,arguments)},lib.PubSub, function() {\n\tthis.init = function(opts) {\n\t\tthis._el = $({\n\t\t\ttag: 'input',\n\t\t\tparent: document.body,\n\t\t\tstyle: {\n\t\t\t\tposition: 'absolute',\n\t\t\t\tleft: '-100px',\n\t\t\t\ttop: '-100px'\n\t\t\t},\n\t\t\tattrs: {\n\t\t\t\ttype: 'text',\n\t\t\t\tvalue: opts && opts.value || ''\n\t\t\t}\n\t\t});\n\t\tthis._value = this._el.value;\n\t\tthis._selectionStart = 0;\n\t\tthis._selectionEnd = 0;\n\t\t\n\t\t$.onEvent(this._el, 'keydown', this, 'checkValue');\n\t\t$.onEvent(this._el, 'keyup', this, 'checkValue');\n\t\t$.onEvent(this._el, 'keypress', this, 'checkValue');\n\t\t$.onEvent(this._el, 'focus', this, 'onFocus');\n\t\t$.onEvent(this._el, 'blur', this, 'onBlur');\n\t}\n\t\n\tthis.onFocus = function() { this.publish('Focus'); }\n\tthis.onBlur = function() { this.publish('Blur'); }\n\t\n\tthis.checkValue = function(evt) {\n\t\tvar target = evt.target,\n\t\t\tstart = target.selectionStart,\n\t\t\tend = target.selectionEnd;\n\t\t\n\t\tvar value = this._el.value;\n\t\t\n\t\tif (value != this._value) {\n\t\t\tthis.publish('ChangeValue', value);\n\t\t\tthis._value = value;\n\t\t}\n\t\t\n\t\tif (start != this._selectionStart) {\n\t\t\tthis._selectionStart = start;\n\t\t\tthis.publish('ChangeSelectionStart', start);\n\t\t}\n\t\t\n\t\tif (end != this._selectionEnd) {\n\t\t\tthis._selectionEnd = end;\n\t\t\tthis.publish('ChangeSelectionEnd', end);\n\t\t}\n\t}\n\t\n\tthis.focus = function() { logger.log('focus'); this._el.focus(); }\n\tthis.blur = function() { this._el.blur(); }\n});\n\n\n// Set desired tab- defaults to four space softtab\nvar tab = '    ',\n\ttabLength = 4;\n\nArray.prototype.map.call(document.getElementsByTagName('textarea'), function(el) {\n\tel.addEventListener('keydown', checkTab, false);\n});\n\nfunction checkTab(evt) {\n\tvar t = evt.target;\n\tvar ss = t.selectionStart;\n\tvar se = t.selectionEnd;\n \n\t// Tab key - insert tab expansion\n\tif (evt.keyCode == 9) {\n\t\tevt.preventDefault();\n\t\t\n\t\tif (evt.shiftKey) {\n\t\t\t// Special case of multi line selection\n\t\t\tif (ss != se && t.value.slice(ss,se).indexOf('\\n') != -1) {\n\t\t\t\t// In case selection was not of entire lines (e.g. selection begins in the middle of a line)\n\t\t\t\t// we ought to tab at the beginning as well as at the start of every following line.\n\t\t\t\tvar i = ss;\n\t\t\t\twhile(i && t.value.charAt(i - 1) != '\\n') { --i; }\n\t\t\t\tvar pre = t.value.slice(0, i);\n\t\t\t\tvar post = t.value.slice(se, t.value.length);\n\t\t\t\tvar sel = t.value.slice(i, se).replace(\n\t\t\t\t\tnew RegExp('(^|\\n)' + tab, 'g'),\n\t\t\t\t\tfunction(match) {\n\t\t\t\t\t\tse -= tab.length;\n\t\t\t\t\t\tif (match.charAt(0) == '\\n') {\n\t\t\t\t\t\t\treturn '\\n';\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tss -= tab.length;\n\t\t\t\t\t\t\treturn '';\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\tt.value = pre.concat(sel).concat(post);\n\n\t\t\t\tt.selectionStart = ss;\n\t\t\t\tt.selectionEnd = se;\n\t\t\t} else {\n\t\t\t\t// \"Normal\" case (no selection or selection on one line only)\n\n\t\t\t\tvar i = ss;\n\t\t\t\twhile(i && t.value.charAt(i - 1) != '\\n') { --i; }\n\t\t\t\tif (t.value.substring(i, i + tab.length) == tab) {\n\t\t\t\t\tt.value = t.value.slice(0, i).concat(t.value.slice(i + tab.length, t.value.length));\n\t\t\t\t\tif (ss == se) {\n\t\t\t\t\t\tt.selectionStart = t.selectionEnd = ss - (ss == i ? 0 : tab.length);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tt.selectionStart = ss - (ss == i ? 0 : tab.length);\n\t\t\t\t\t\tt.selectionEnd = se - tab.length;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// Special case of multi line selection\n\t\t\tif (ss != se && t.value.slice(ss,se).indexOf(\"\\n\") != -1) {\n\t\t\t\t// In case selection was not of entire lines (e.g. selection begins in the middle of a line)\n\t\t\t\t// we ought to tab at the beginning as well as at the start of every following line.\n\t\t\t\tvar i = ss;\n\t\t\t\twhile(i && t.value.charAt(i - 1) != '\\n') { --i; }\n\t\t\t\tvar pre = t.value.slice(0, i);\n\t\t\t\tvar post = t.value.slice(se, t.value.length);\n\t\t\t\tvar sel = t.value.slice(i, se).replace(/\\n/g, function() {\n\t\t\t\t\tse += tab.length;\n\t\t\t\t\treturn '\\n' + tab;\n\t\t\t\t});\n\t\t\t\tt.value = pre.concat(tab).concat(sel).concat(post);\n\n\t\t\t\tt.selectionStart = ss + tab.length;\n\t\t\t\tt.selectionEnd = se + tab.length;\n\t\t\t} else {\n\t\t\t\t// \"Normal\" case (no selection or selection on one line only)\n\n\t\t\t\tvar i = ss;\n\t\t\t\twhile(i && t.value.charAt(i - 1) != '\\n') { --i; }\n\n\t\t\t\tt.value = t.value.slice(0, i).concat(tab).concat(t.value.slice(i, t.value.length));\n\n\t\t\t\tif (ss == se) {\n\t\t\t\t\tt.selectionStart = t.selectionEnd = ss + tab.length;\n\t\t\t\t} else {\n\t\t\t\t\tt.selectionStart = ss + tab.length;\n\t\t\t\t\tt.selectionEnd = se + tab.length;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (evt.shiftKey || evt.metaKey || evt.ctrlKey) {\n\t\treturn;\n\t} else if (evt.keyCode == 8 && t.value.slice(ss - tabLength, ss) == tab) {\n\t\t// Backspace key - delete preceding tab expansion, if exists\n\t\tevt.preventDefault();\n\t\t\n\t\tt.value = t.value.slice(0,ss - tabLength).concat(t.value.slice(ss,t.value.length));\n\t\tt.selectionStart = t.selectionEnd = ss - tab.length;\n\t} else if (evt.keyCode == 46 && t.value.slice(se, se + tabLength) == tab) {\n\t\t// Delete key - delete following tab expansion, if exists\n\t\tevt.preventDefault();\n\t\t\n\t\tt.value = t.value.slice(0,ss).concat(t.value.slice(ss + tabLength,t.value.length));\n\t\tt.selectionStart = t.selectionEnd = ss;\n\t} else if (evt.keyCode == 37 && t.value.slice(ss - tabLength, ss) == tab) {\n\t\t// Left/right arrow keys - move across the tab in one go\n\t\tevt.preventDefault();\n\t\tt.selectionStart = t.selectionEnd = ss - tabLength;\n\t} else if (evt.keyCode == 39 && t.value.slice(ss, ss + tabLength) == tab) {\n\t\tevt.preventDefault();\n\t\tt.selectionStart = t.selectionEnd = ss + tabLength;\n\t}\n}\n","pre":true},"../../../browser/lib/runtimeBrowser/device/Timer.js":{"path":"../../../browser/lib/runtimeBrowser/device/Timer.js","friendlyPath":".Timer","directory":"../../../browser/lib/runtimeBrowser/device/","filename":"Timer.js","src":"/**\n * package timestep.env.browser.Timer;\n *\n * System timer exposed to the device.\n */\n\nvar _onTick = null,\n\tdisableRequestAnimFrame = false,\n\tdisablePostMessage = true,\n\tasFastAsPossible = false,\n\tMIN_DT = 16;\n\nif (window.postMessage) {\n\tfunction postMessageCb(evt) { if (evt.data == 'timestep.TICK') { onFrame(); }}\n\t\n\tif (window.addEventListener) {\n\t\twindow.addEventListener('message', postMessageCb, false);\n\t} else {\n\t\twindow.attachEvent('onmessage', postMessageCb);\n\t}\n} else {\n\tdisablePostMessage = true;\n\ttickNow = sendTimeoutNow;\n}\n\nfunction sendPostMessage() { window.postMessage('timestep.TICK', '*'); }\nfunction sendTimeout() { setTimeout(onFrame, MIN_DT); }\nfunction sendTimeoutNow() { setTimeout(onFrame, 0); }\n\nvar fastDriver = sendTimeoutNow,\n\tmainDriver = sendTimeout;\n\nif (asFastAsPossible) {\n\tif (!disablePostMessage) {\n\t\tfastDriver = mainDriver = sendPostMessage;\n\t} else {\n\t\tmainDriver = sendTimeoutNow;\n\t}\n} else {\n\tvar reqAnim = !disableRequestAnimFrame && (\n\t\t\t\t\twindow.requestAnimationFrame\n\t\t\t\t|| window.webkitRequestAnimationFrame\n\t\t\t\t|| window.mozRequestAnimationFrame\n\t\t\t\t|| window.oRequestAnimationFrame\n\t\t\t\t|| window.msRequestAnimationFrame);\n\t\n\tif (reqAnim) {\n\t\tfastDriver = mainDriver = reqAnim;\n\t} else if (!disablePostMessage) {\n\t\tfastDriver = sendPostMessage;\n\t}\n}\n\n/*\nvar frameDts = [];\nvar print = false, frames = 0, lastPrint = 0;\nsetInterval(function() { print = true; }, 1000)\n\nvar slow = 0, fast = 0;\n*/\n\nfunction onFrame() {\n\tif (_onTick) {\n\t\tvar now = +new Date(),\n\t\t\tdt = now - (exports.last || now);\n\t\t\n\t\texports.last = now;\n\t\t\n\t\t//try {\n\t\t\t_onTick(dt);\n\t\t/*} catch (e) {\n\t\t\tif (window.DEV_MODE) {\n\t\t\t\tvar err = '.dev_error';\n\t\t\t\tjsio('import ' + err).render(e);\n\t\t\t\texports.stop();\n\t\t\t}\n\t\t}*/\n\n\t\t/*\n\t\tframeDts.push(dt);\n\t\tvar delay = +new Date() - now;\n\t\t++frames;\n\t\tif (print) {\n\t\t\tlogger.log(fast, slow, JSON.stringify(frameDts), now - lastPrint, dt, frames, delay);\n\t\t\tframeDts = [];\n\t\t\tlastPrint = now;\n\t\t\tprint = false;\n\t\t\tframes = 0;\n\t\t\tslow = 0;\n\t\t\tfast = 0;\n\t\t}\n\t\t*/\n\t\t\n\t\tif (dt > MIN_DT) {\n\t\t//\t++fast;\n\t\t\tfastDriver.call(window, onFrame);\n\t\t} else {\n\t\t//\t++slow;\n\t\t\tmainDriver.call(window, onFrame);\n\t\t}\n\t}\n}\n\nexports.last = null;\n\nexports.start = function(onTick) {\n\t_onTick = onTick;\n\tmainDriver.call(window, onFrame);\n}\n\nexports.stop = function() { _onTick = null; }\n","pre":true},"../../../../sdk/timestep/ui/backend/dom/animate.js":{"path":"../../../../sdk/timestep/ui/backend/dom/animate.js","friendlyPath":".backend.dom.animate","directory":"../../../../sdk/timestep/ui/backend/dom/","filename":"animate.js","src":"/**\n * @package ui.backend.dom.animate;\n *\n * For now, this package simply forwards to Canvas' implementation.\n */\n\njsio(\"import ui.backend.canvas.animate as canvasAnimate\");\n\nexports = function(view) {\n\t// For DOM nodes, return only one singleton animation class.\n\tif ('_node' in view) {\n\t\treturn view.getAnimation();\n\t} else {\n\t\treturn canvasAnimate(view);\n\t}\n}\nexports.linear = canvasAnimate.linear;\nexports.easeIn = canvasAnimate.easeIn;\nexports.easeInOut = canvasAnimate.easeInOut;\nexports.easeOut = canvasAnimate.easeOut;\n","pre":true},"../../../../sdk/timestep/ui/backend/dom/ImageView.js":{"path":"../../../../sdk/timestep/ui/backend/dom/ImageView.js","friendlyPath":".backend.dom.ImageView","directory":"../../../../sdk/timestep/ui/backend/dom/","filename":"ImageView.js","src":"/**\n * @package ui.backend.dom.ImageView;\n *\n * Renders an image in a View for canvas.\n */\n\njsio(\"import ui.View as View\");\njsio(\"import ui.resource.Image as Image\");\n\nfunction getImageURL(image) {\n\tif (image.getSource) {\n\t\treturn image.getSource().src;\n\t} else {\n\t\treturn image;\n\t}\n}\n\n/**\n * @extends timestep.View\n */\nvar sdk_timestep_ui_backend_dom_ImageView=__class__;exports=sdk_timestep_ui_backend_dom_ImageView(function sdk_timestep_ui_backend_dom_ImageView(){return this.init&&this.init.apply(this,arguments)},View, function (supr) {\n\n\tthis.init = function (opts) {\n\t\topts = merge(opts, {\n\t\t\timage: null\n\t\t});\n\n\t\tsupr(this, \"init\", [opts]);\n\n\t\tif (opts.image) {\n\t\t\tthis.setImage(opts.image); \n\t\t}\n\t};\n\n\tthis.autoSize = function() {\n\t\tif (this._img) {\n\t\t\tthis.style.width = this._img.getWidth();\n\t\t\tthis.style.height = this._img.getHeight();\n\n\t\t\tif (this.style.fixedAspectRatio) {\n\t\t\t\tthis.style.updateAspectRatio();\n\t\t\t}\n\t\t}\n\t}\n\n\tthis.tick = function() {\n\t\tif (this._img) {\n\t\t\tvar boundsHash = JSON.stringify(this._img.getBounds());\n\t\t\tif (this._cachedBounds != boundsHash) {\n\t\t\t\tthis._cachedBounds = boundsHash;\n\t\t\t\tthis.updateImage();\n\t\t\t}\n\t\t}\n\t}\n\n\tthis.getImage = function() { return this._img; }\n\tthis.setImage = function(img) {\n\t\tif (!img) { return; }\n\t\tif (!img.getBounds) {\n\t\t\timg = new Image({url: img});\n\t\t}\n\t\t\n\t\tthis._img = img;\n\n\t\tif (this._opts.autoSize) {\n\t\t\timg.doOnLoad(this, 'autoSize');\n\t\t}\n\n\t\timg.doOnLoad(this, 'updateImage');\n\t}\n\n\tthis.reflow = function () {\n\t\tthis.updateImage();\n\t}\n\n\tthis.updateImage = function() {\n\t\tif (!this._img || !this._img.isReady()) { return; }\n\t\tvar img = this._img;\n\t\tvar s = this.__view._node.style;\n\t\tvar bounds = img.getBounds();\n\n\t\tvar sheetWidth = img.getOrigW();\n\t\tvar sheetHeight = img.getOrigH();\n\t\tvar imgWidth = bounds.width + bounds.marginLeft + bounds.marginRight;\n\t\tvar imgHeight = bounds.height + bounds.marginTop + bounds.marginBottom;\n\n\t\ts.padding = bounds.marginTop + 'px ' + bounds.marginRight + 'px ' + bounds.marginBottom + 'px ' + bounds.marginLeft + 'px';\n\n\t\tvar scaleX = this.style.width / imgWidth;\n\t\tvar scaleY = this.style.height / imgHeight;\n\n\t\t//s.overflow = 'hidden';\n\t\ts.webkitBackgroundClip = s.backgroundClip = 'content-box';\n\t\ts.backgroundImage = 'url(\"' + getImageURL(img) + '\")';\n\t\ts.backgroundPositionX = scaleX * (-bounds.x + bounds.marginLeft) + 'px';\n\t\ts.backgroundPositionY = scaleY * (-bounds.y + bounds.marginTop) + 'px';\n\t\ts.backgroundSize = sheetWidth * scaleX + 'px ' + sheetHeight * scaleY + 'px';\n\t}\n\n\tthis.getOrigWidth = this.getOrigW = function() { return this._img.getOrigW(); }\n\tthis.getOrigHeight = this.getOrigH = function() { return this._img.getOrigH(); }\n\n\tthis.doOnLoad = function() {\n\t\tif (arguments.length == 1) {\n\t\t\tthis._img.doOnLoad(this, arguments[0]);\n\t\t} else {\n\t\t\tthis._img.doOnLoad.apply(this._img, arguments);\n\t\t}\n\t\treturn this;\n\t}\n\n});\n","pre":true},"../../../../sdk/timestep/ui/resource/Image.js":{"path":"../../../../sdk/timestep/ui/resource/Image.js","friendlyPath":"ui.resource.Image","directory":"../../../../sdk/timestep/ui/resource/","filename":"Image.js","src":"/**\n * @class ui.resource.Image;\n * Model an Image for rendering. Supports taking a subset of images, to support\n * extracting from compacted sprite sheets. Also supports applying filters to\n * an image, usually by the View class.\n *\n * @doc http://doc.gameclosure.com/api/ui-imageview.html#class-ui.resource.image\n * @docsrc https://github.com/gameclosure/doc/blob/master/api/ui/imageview.md\n */\n\njsio(\"import event.Callback as Callback\");\njsio(\"import math.geom.Rect as Rect\");\njsio(\"import device\");\njsio(\"import ui.resource.loader as resourceLoader\");\n\n/**\n * Callback when images are loaded. This has a failsafe that runs up to a certain\n * threshold asynchronously, attempting to read the image size, before dying.\n */\n\nvar ImageCache = {};\n\nfunction imageOnLoad(success, evt, failCount) {\n\t// Some browsers report onLoad before the image width is available.\n\tif (success && !this.width) {\n\t\tif (failCount > 3) {\n\t\t\tthis.onLoad = this.onError = null;\n\t\t\treturn this.__cb.fire(false);\n\t\t}\n\n\t\treturn setTimeout(bind(this, imageOnLoad, success, evt, (failCount || 0) + 1), 0);\n\t}\n\n\tthis.__cb.fire(success);\n\tthis.onLoad = this.onError = null;\n}\n\n/**\n * This class models the region of a larger image that this \"Image\" references.\n */\n\nvar ImageMap = !GLOBAL.CONFIG.disableNativeViews && GLOBAL.NATIVE && GLOBAL.NATIVE.timestep && GLOBAL.NATIVE.timestep.ImageMap;\n\nif (!ImageMap) {\nImageMap=__class__;\tImageMap=ImageMap(function ImageMap(){return this.init&&this.init.apply(this,arguments)},function() {\n\t\tthis.init = function(parentImage, x, y, width, height, marginTop, marginRight, marginBottom, marginLeft, url) {\n\t\t\tthis.url = url;\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.width = width;\n\t\t\tthis.height = height;\n\t\t\tthis.marginTop = marginTop;\n\t\t\tthis.marginRight = marginRight;\n\t\t\tthis.marginBottom = marginBottom;\n\t\t\tthis.marginLeft = marginLeft;\n\t\t}\n\t});\n}\n\nvar sdk_timestep_ui_resource_Image=__class__;exports=sdk_timestep_ui_resource_Image(function sdk_timestep_ui_resource_Image(){return this.init&&this.init.apply(this,arguments)},function() {\n\tthis.init = function(opts) {\n\t\tif (!opts) { opts = {}; }\n\n\t\tthis._cb = new Callback();\n\t\tthis._map = new ImageMap(this, 0, 0, -1, -1, 0, 0, 0, 0, opts.url || '');\n\n\t\tthis._originalURL = opts.url;\n\n\t\tresourceLoader._updateImageMap(this._map, opts.url, opts.sourceX, opts.sourceY, opts.sourceW, opts.sourceH);\n\n\t\tthis._scale = opts.scale;\n\n\t\t// srcImage can be null, then setSrcImg will create one\n\t\t// (use the map's URL in case it was updated to a spritesheet)\n\t\tthis._setSrcImg(opts.srcImage, this._map.url);\n\t};\n\n\tthis._setSrcImg = function(img, url) {\n\t\tthis._cb.reset();\n\n\t\t// if we haven't found an image, look in the image cache\n\t\tif (!img && url && ImageCache[url]) {\n\t\t\timg = ImageCache[url];\n\t\t}\n\n\t\t// look up the base64 cache -- if it's been preloaded, we'll get back an image that's already loaded\n\t\t// if it has not been preloaded, we'll get back raw base64 in the b64 variable\n\t\tif (!img && Image.get) {\n\t\t\tvar b64 = Image.get(url);\n\t\t\tif (typeof b64 == 'object') {\n\t\t\t\timg = b64;\n\t\t\t} else if (b64) {\n\t\t\t\turl = b64;\n\t\t\t}\n\t\t}\n\n\t\t// if it's already loaded...\n\t\tif (img && img.complete) {\n\t\t\tthis._srcImg = img;\n\t\t\tthis._onLoad(true);\n\t\t} else {\n\t\t\t// add a callback and wait for it\n\n\t\t\t// create an image if we don't have one\n\t\t\tthis._srcImg = img = img || new Image();\n\n\t\t\tif (!img.__cb) {\n\t\t\t\timg.__cb = new Callback();\n\t\t\t\timg.addEventListener('load', bind(img, imageOnLoad, true), false);\n\t\t\t\timg.addEventListener('error', bind(img, imageOnLoad, false), false);\n\n\t\t\t\tif (url) { ImageCache[url] = img; }\n\t\t\t\tif (!img.src && url) {\n\t\t\t\t\tthis._srcImg.src = this._map.url = url;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\timg.__cb.run(this, '_onLoad');\n\t\t}\n\t};\n\n\tthis.setSource = this.setSrcImg = function(srcImg) {\n\t\tthis._setSrcImg(srcImg);\n\t};\n\n\tthis.__reload__ = function(cb) {\n\t\tif (this._srcImg) {\n\t\t\tvar chainedCb = cb.chain();\n\n\t\t\tvar onReload = bind(this, function() {\n\t\t\t\tthis._srcImg.removeEventListener('reload', onReload, false);\n\t\t\t\tchainedCb();\n\t\t\t});\n\n\t\t\tthis._srcImg.addEventListener('reload', onReload, false);\n\t\t}\n\t};\n\n\tthis.setURL = function(url) {\n\t\tresourceLoader._updateImageMap(this._map, url);\n\t\tthis._setSrcImg(null, this._map.url);\n\t};\n\n\tthis.getURL = function() { return this._map.url; };\n\tthis.getOriginalURL = function () { return this._originalURL; }\n\n\tthis.getSourceWidth = this.getOrigWidth = this.getOrigW = function() { return this._srcImg.width; };\n\tthis.getSourceHeight = this.getOrigHeight = this.getOrigH = function() { return this._srcImg.height; };\n\n\tthis.setSourceWidth = this.setSourceW = function(w) { this._map.width = w; };\n\tthis.setSourceHeight = this.setSourceH = function(h) { this._map.height = h; };\n\tthis.setSourceY = this.setSourceY = function(y) { this._map.y = y; };\n\tthis.setSourceX = this.setSourceX = function(x) { this._map.x = x; };\n\n\tthis.setMarginTop = function (n) { this._map.marginTop = n; };\n\tthis.setMarginRight = function (n) { this._map.marginRight = n; };\n\tthis.setMarginBottom = function (n) { this._map.marginBottom = n; };\n\tthis.setMarginLeft = function (n) { this._map.marginLeft = n; };\n\n\tthis.getURL = function() { return this._map.url; }\n\n\t/* @deprecated */\n\tthis.getSourceWidth = this.getOrigWidth = this.getOrigW = function() { return this._srcImg.width; }\n\t/* @deprecated */\n\tthis.getSourceHeight = this.getOrigHeight = this.getOrigH = function() { return this._srcImg.height; }\n\t/* @deprecated */\n\tthis.setSourceWidth = this.setSourceW = function(w) { this._map.width = w; }\n\t/* @deprecated */\n\tthis.setSourceHeight = this.setSourceH = function(h) { this._map.height = h; }\n\t/* @deprecated */\n\tthis.setSourceY = this.setSourceY = function(y) { this._map.y = y; }\n\t/* @deprecated */\n\tthis.setSourceX = this.setSourceX = function(x) { this._map.x = x; }\n\t/* @deprecated */\n\tthis.setMarginTop = function (n) { this._map.marginTop = n; }\n\t/* @deprecated */\n\tthis.setMarginRight = function (n) { this._map.marginRight = n; }\n\t/* @deprecated */\n\tthis.setMarginBottom = function (n) { this._map.marginBottom = n; }\n\t/* @deprecated */\n\tthis.setMarginLeft = function (n) { this._map.marginLeft = n; }\n\t\n\tthis.getSource = function() {\n\t\treturn this._srcImg;\n\t};\n\n\tthis.getWidth = function() {\n\t\treturn (this._map.width == -1\n\t\t\t? 0\n\t\t\t: this._map.width + this._map.marginLeft + this._map.marginRight) / this._map.scale;\n\t};\n\n\tthis.getHeight = function() {\n\t\treturn (this._map.height == -1 ? 0 :\n\t\t\t\t\t\t\t   this._map.height + this._map.marginTop + this._map.marginBottom) / this._map.scale;\n\t};\n\n\tthis.getMap =\n\tthis.getBounds = function() { return this._map; };\n\tthis.setBounds = function(x, y, w, h, marginTop, marginRight, marginBottom, marginLeft) {\n\t\tvar map = this._map;\n\t\tmap.x = x;\n\t\tmap.y = y;\n\t\tmap.width = w;\n\t\tmap.height = h;\n\t\tmap.marginTop = marginTop || 0;\n\t\tmap.marginRight = marginRight || 0;\n\t\tmap.marginBottom = marginBottom || 0;\n\t\tmap.marginLeft = marginLeft || 0;\n\t};\n\n\t/* @deprecated */\n\tthis.setBounds = this.setMap;\n\t\n\t// register a callback for onload\n\tthis.doOnLoad = function() { this._cb.forward(arguments); return this; };\n\n\t// internal onload handler for actual Image object\n\tthis._onLoad = function(didLoad) {\n\t\tif (!didLoad) {\n\t\t\t// TODO: something better?\n\t\t\tlogger.error('Image failed to load:', this._map.url);\n\t\t\tthis._cb.fire({NoImage: true});\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._srcImg.width == 0) { logger.warn('Image has no width', this._url); }\n\n\t\tvar map = this._map;\n\t\tif (this._scale && (map.width != -1 || map.height != -1)) {\n\t\t\t// requested scale & provided a width or height\n\t\t\tif (map.width == -1) {\n\t\t\t\t// by the above check, this._sourceH should not be -1\n\t\t\t\tmap.width = this._srcImg.width * map.height / this._srcImg.height;\n\t\t\t}\n\n\t\t\tif (map.height == -1) {\n\t\t\t\t// this._sourceW was initialized above\n\t\t\t\tmap.height = this._srcImg.height * map.width / this._srcImg.width;\n\t\t\t}\n\n\t\t\t// TODO: sourceImage might be shared so we can't actually modify width/height.  This is a bug.\n\t\t\tthis._srcImg.width = map.width;\n\t\t\tthis._srcImg.height = map.height;\n\t\t} else {\n\t\t\tif (map.width == -1) { map.width = this._srcImg.width; }\n\t\t\tif (map.height == -1) { map.height = this._srcImg.height; }\n\t\t}\n\n\t\tthis._map.url = this._srcImg.src;\n\n\t\tthis._cb.fire(null, this);\n\t};\n\n\tthis.isLoaded =\n\tthis.isReady = function() { return this._cb.fired(); };\n\n\tvar isNative = GLOBAL.NATIVE && !device.simulatingMobileNative;\n\tvar SLICE = Array.prototype.slice;\n\tif (!isNative) {\n\t\tvar Canvas = device.get('Canvas');\n\t\tvar _filterCanvas = new Canvas();\n\t\tvar _filterCtx = _filterCanvas.getContext('2d');\n\t};\n\n\tthis.render = function(ctx, destX, destY, destW, destH) {\n\t\tif (!this._cb.fired()) { return; }\n\n\t\ttry {\n\t\t\tvar args = arguments;\n\t\t\tvar map = this._map;\n\t\t\tvar scaleX;\n\t\t\tvar scaleY;\n\n\t\t\tif (!(ctx.filters && (ctx.filters.Multiply || ctx.filters.NegativeMask || ctx.filters.PositiveMask))) {\n\t\t\t\tif (args.length == 9) {\n\t\t\t\t\tctx.drawImage(this._srcImg, args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8]);\n\t\t\t\t} else if (destX instanceof Rect) {\n\t\t\t\t\tif (destY instanceof Rect) {\n\t\t\t\t\t\tvar srcRect = destX;\n\t\t\t\t\t\tvar destRect = destY;\n\t\t\t\t\t\tscaleX = destRect.width / (map.marginLeft + map.width + map.marginRight);\n\t\t\t\t\t\tscaleY = destRect.height / (map.marginTop + map.height + map.marginBottom);\n\t\t\t\t\t\tctx.drawImage(this._srcImg,\n\t\t\t\t\t\t\tsrcRect.x, srcRect.y, srcRect.width, srcRect.height,\n\t\t\t\t\t\t\tdestRect.x, destRect.y, destRect.width, destRect.height);\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar destRect = destX;\n\t\t\t\t\t\tscaleX = destRect.width / (map.marginLeft + map.width + map.marginRight);\n\t\t\t\t\t\tscaleY = destRect.height / (map.marginTop + map.height + map.marginBottom);\n\t\t\t\t\t\tctx.drawImage(this._srcImg,\n\t\t\t\t\t\t\t\t\t  map.x, map.y, map.width, map.height,\n\t\t\t\t\t\t\t\t\t  destRect.x + scaleX * map.marginLeft,\n\t\t\t\t\t\t\t\t\t  destRect.y + scaleY * map.marginTop,\n\t\t\t\t\t\t\t\t\t  scaleX * map.width,\n\t\t\t\t\t\t\t\t\t  scaleY * map.height);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tscaleX = destW / (map.marginLeft + map.width + map.marginRight);\n\t\t\t\t\tscaleY = destH / (map.marginTop + map.height + map.marginBottom);\n\n\t\t\t\t\tctx.drawImage(this._srcImg,\n\t\t\t\t\t\t\t\t  map.x, map.y, map.width, map.height,\n\t\t\t\t\t\t\t\t  (destX || 0) + scaleX * map.marginLeft,\n\t\t\t\t\t\t\t\t  (destY || 0) + scaleY * map.marginTop,\n\t\t\t\t\t\t\t\t  scaleX * map.width,\n\t\t\t\t\t\t\t\t  scaleY * map.height);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar renderArgs = arguments, img = this;\n\n\t\t\tfunction applyOperation(color, op1, op2) {\n\t\t\t\t_filterCanvas.width = destW;\n\t\t\t\t_filterCanvas.height = destH;\n\t\t\t\t_filterCtx.globalCompositeOperation = 'source-over';\n\t\t\t\timg.render.apply(img, [_filterCtx].concat(SLICE.call(renderArgs, 1)));\n\n\t\t\t\t_filterCtx.globalCompositeOperation = op1;\n\t\t\t\t_filterCtx.fillStyle = \"rgba(\" + color.r  + \",\" + color.g + \",\" + color.b + \",\" + color.a + \")\";\n\t\t\t\t_filterCtx.fillRect(destX || 0, destY || 0, destW || map.width, destH || map.height);\n\n\t\t\t\tvar oldCompositeOperation = ctx.globalCompositeOperation;\n\t\t\t\tctx.globalCompositeOperation = op2;\n\t\t\t\tctx.drawImage(_filterCanvas, destX || 0, destY || 0, destW || map.width, destH || map.height);\n\t\t\t\tctx.globalCompositeOperation = oldCompositeOperation;\n\t\t\t}\n\n\t\t\t// Rendering engine flags.\n\t\t\tvar isWebkit = /WebKit/.exec(navigator.appVersion);\n\t\t\tif (!isNative && ctx.filters) {\n\n\t\t\t\tif (ctx.filters.LinearAdd) {\n\t\t\t\t\tvar f = ctx.filters.LinearAdd.get();\n\t\t\t\t\tapplyOperation(f, 'source-in', 'lighter');\n\t\t\t\t}\n\n\t\t\t\tif (ctx.filters.Tint) {\n\t\t\t\t\tvar f = ctx.filters.Tint.get();\n\t\t\t\t\tvar color = {r: f.r, g: f.g, b: f.b, a: f.a};\n\t\t\t\t\tapplyOperation(color, 'source-in', 'source-over');\n\t\t\t\t}\n\n\t\t\t\tif (ctx.filters.Multiply) {\n\t\t\t\t\tvar f = ctx.filters.Multiply.get();\n\t\t\t\t\tvar imgData = this.getImageData();\n\t\t\t\t\tvar data = imgData.data;\n\t\t\t\t\t\n\t\t\t\t\tfor (var i = 0; i < data.length; i+=4) {\n\t\t\t\t\t\tdata[i] *= ((f.r / 255) * f.a); \n\t\t\t\t\t\tdata[i + 1] *= ((f.g / 255) * f.a); \n\t\t\t\t\t\tdata[i + 2] *= ((f.b / 255) * f.a); \n\t\t\t\t\t}\n\n\t\t\t\t\t_filterCanvas.width = imgData.width;\n\t\t\t\t\t_filterCanvas.height = imgData.height;\n\t\t\t\t\t_filterCtx.putImageData(imgData, 0, 0);\n\t\t\t\t\tctx.drawImage(_filterCanvas, destX || 0, destY || 0, destW || map.width, destH || map.height);\n\n\t\t\t\t}\n\n\t\t\t\tif (ctx.filters.NegativeMask) {\n\t\t\t\t\tvar f = ctx.filters.NegativeMask.get();\n\t\t\t\t\t_filterCanvas.width = destW;\n\t\t\t\t\t_filterCanvas.height = destH;\n\t\t\t\t\t_filterCtx.globalCompositeOperation = 'source-over';\n\t\t\t\t\tf.imgObject.render.apply(f.imgObject, [_filterCtx].concat(SLICE.call(renderArgs, 1)));\n\n\t\t\t\t\t_filterCtx.globalCompositeOperation = 'source-in';\n\t\t\t\t\timg.render.apply(img, [_filterCtx].concat(SLICE.call(renderArgs, 1)));\n\n\t\t\t\t\tvar oldCompositeOperation = ctx.globalCompositeOperation;\n\t\t\t\t\tctx.globalCompositeOperation = 'source-over';\n\t\t\t\t\tctx.drawImage(_filterCanvas, destX || 0, destY || 0, destW || map.width, destH || map.height);\n\t\t\t\t\tctx.globalCompositeOperation = oldCompositeOperation;\n\t\t\t\t}\n\n\t\t\t\tif (ctx.filters.PositiveMask) {\n\t\t\t\t\tvar f = ctx.filters.PositiveMask.get();\n\t\t\t\t\t_filterCanvas.width = destW;\n\t\t\t\t\t_filterCanvas.height = destH;\n\t\t\t\t\t_filterCtx.globalCompositeOperation = 'source-over';\n\t\t\t\t\tf.imgObject.render.apply(f.imgObject, [_filterCtx].concat(SLICE.call(renderArgs, 1)));\n\n\t\t\t\t\t_filterCtx.globalCompositeOperation = 'source-out';\n\t\t\t\t\timg.render.apply(img, [_filterCtx].concat(SLICE.call(renderArgs, 1)));\n\n\t\t\t\t\tvar oldCompositeOperation = ctx.globalCompositeOperation;\n\t\t\t\t\tctx.globalCompositeOperation = 'source-over';\n\t\t\t\t\tctx.drawImage(_filterCanvas, destX || 0, destY || 0, destW || map.width, destH || map.height);\n\t\t\t\t\tctx.globalCompositeOperation = oldCompositeOperation;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch(e) {}\n\t};\n\n\tthis.getImageData = function() {\n\t\tif (!GLOBAL.document || !document.createElement) { throw 'Not supported'; }\n\t\tif (!this._map.width || !this._map.height) { throw 'Not loaded'; }\n\n\t\tvar canvas = document.createElement('canvas');\n\t\tcanvas.width = this._map.width;\n\t\tcanvas.height = this._map.height;\n\t\tvar ctx = canvas.getContext('2d');\n\n\t\tthis.render(ctx, 0, 0, this._map.width, this._map.height);\n\n\t\tvar imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n\n\t\treturn imageData;\n\t};\n\n\tthis.setImageData = function(data) { };\n\n\tthis.destroy = function() {\n\t\tthis._srcImg.destroy();\n\t};\n});\n\nexports.__clearCache__ = function () {\n\tImageCache = {};\n};\n","pre":true},"../../../../sdk/timestep/event/Callback.js":{"path":"../../../../sdk/timestep/event/Callback.js","friendlyPath":"event.Callback","directory":"../../../../sdk/timestep/event/","filename":"Callback.js","src":"/**\n * @class event.Callback;\n * Namespace shim to bring in Callback from jsio.\n *\n * @doc http://doc.gameclosure.com/api/event.html#class-event.callback\n * @docsrc https://github.com/gameclosure/doc/blob/master/api/event.md\n */\n\njsio(\"import lib.Callback as exports\");\n","pre":true},"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/lib/Callback.js":{"path":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/lib/Callback.js","friendlyPath":"lib.Callback","directory":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/lib/","filename":"Callback.js","src":"var Users_arnovandervegt_gameclosure_basil_sdk_jsio_lib_Callback=__class__;exports=Users_arnovandervegt_gameclosure_basil_sdk_jsio_lib_Callback(function Users_arnovandervegt_gameclosure_basil_sdk_jsio_lib_Callback(){return this.init&&this.init.apply(this,arguments)},function() {\n\n\tthis._fired = false;\n\tthis._id = 0;\n\tthis._pending = null;\n\n\tthis.init = function() { this._run = []; };\n\tthis.fired = function() { return this._fired; } ;\n\n\t// preserve pending callbacks, but clear fired status\n\tthis.reset = function() { this._args = []; this._fired = false; };\n\n\t// clear fired status and remove any pending callbacks\n\tthis.clear = function() { this.reset(); this._run = []; this._pending = null; this._stat = null; };\n\n\t// a convenience function to proxy arguments to `this.run`: arguments passed as the first argument\n\tthis.forward = function(args) { this.run.apply(this, args); };\n\n\t// when the lib.Callback object fires, run a ctx, method, and\n\t// (optional) curried arguments or a single callback function\n\tthis.run = function(ctx, method) {\n\t\tvar f = method ? bind.apply(this, arguments) : ctx;\n\t\tif (f) {\n\t\t\tif (this._fired) {\n\t\t\t\tf.apply(this, this._args);\n\t\t\t} else {\n\t\t\t\tthis._run.push(f);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t};\n\n\tthis.runOrTimeout = function(onFire, onTimeout, duration) {\n\t\tif (!onFire && !onTimeout) { return; }\n\n\t\tif (this._fired) {\n\t\t\tonFire.apply(this, this._args);\n\t\t} else {\n\t\t\tvar f = bind(this, function() {\n\t\t\t\tclearTimeout(timeout);\n\t\t\t\tonFire.apply(this, this._args);\n\t\t\t});\n\n\t\t\tthis.run(f);\n\n\t\t\tvar timeout = setTimeout(bind(this, function() {\n\t\t\t\tfor (var i = 0, n = this._run.length; i < n; ++i) {\n\t\t\t\t\tif (this._run[i] == f) {\n\t\t\t\t\t\tthis._run.splice(i, 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tonTimeout();\n\t\t\t}), duration);\n\t\t}\n\t};\n\n\tthis.fire = function() {\n\t\tif (this._fired) { return; }\n\t\tthis._fired = true;\n\n\t\tvar cbs = this._run;\n\t\tthis._args = arguments;\n\t\tfor(var i = 0, len = cbs.length; i < len; ++i) {\n\t\t\tif (cbs[i]) { cbs[i].apply(this, arguments); }\n\t\t}\n\t};\n\n\tthis.chain = function(id) {\n\t\tif (!this._pending) { this._pending = {}; }\n\t\tif (id === undefined) { id = this._id++; }\n\t\tthis._pending[id] = true;\n\n\t\tthis.reset();\n\t\treturn bind(this, '_deferred', id);\n\t};\n\n\tthis._deferred = function(id) {\n\t\tif (!this._stat) { this._stat = {}; }\n\t\tif (this._stat.hasOwnProperty(id)) { return; }\n\n\t\tthis._stat[id] = Array.prototype.slice.call(arguments, 1);\n\t\tvar pending = this._pending;\n\t\tdelete pending[id];\n\t\tfor (var id in pending) {\n\t\t\tif (pending.hasOwnProperty(id)) { return; }\n\t\t}\n\n\t\tthis.fire(this._stat);\n\t};\n});\n","pre":true},"../../../../sdk/timestep/ui/resource/loader.js":{"path":"../../../../sdk/timestep/ui/resource/loader.js","friendlyPath":"ui.resource.loader","directory":"../../../../sdk/timestep/ui/resource/","filename":"loader.js","src":"jsio(\"import lib.Callback\");\n\nvar _cache = {};\n\nvar MIME = {\n\t'.png': 'image',\n\t'.jpg': 'image',\n\t'.bmp': 'image',\n\t'.css': 'css',\n\t'.html': 'html',\n\t'.mp3': 'audio',\n\t'.ogg': 'audio',\n\t'.mp4': 'audio',\n\t'.3gp': 'audio',\n\t'.m4a': 'audio',\n\t'.aac': 'audio',\n\t'.flac': 'audio',\n\t'.mkv': 'audio',\n\t'.wav': 'audio'\n};\n\nLoader=__class__;var Loader=Loader(function Loader(){return this.init&&this.init.apply(this,arguments)},function() {\n\tthis._map = {};\n\n\tthis.getMap = function () { return this._map; }\n\tthis.setMap = function (map) { this._map = map || {}; }\n\t\n\t// TODO: rename this function...\n\tthis.get = function (file) {\n\t\treturn 'resources/images/' + file;\n\t}\n\t\n\t/**\n\t * Preload a given resource or array of resources.\n\t * You can specify a folder name, or even a partial filename,\n\t * to preload all resources that begin with that prefix.\n\t * For instance, in a tree like so:\n\t * \n\t * resources\n\t *  images\n     *      boss\n     *         enemy1.png\n\t *         enemy2.png\n     *      hero\n     *          shield.png\n\t *          sword.png\n\t * \n\t * You could preload both enemy images in either of the following\n\t * ways:\n\t * \n\t *     ui.resource.loader.preload(\"resources/images/boss/\");\n\t *     ui.resource.loader.preload(\"resources/images/boss/enemy\");\n\t * \n\t * Pass an array of paths to preload all at once. The callback\n\t * will be called when all resources have finished loading.\n\t * \n\t * This works for both images and sounds.\n\t */\n\tthis.preload = function (pathPrefix, opts, cb) {\n\t\tif (typeof opts == 'function') {\n\t\t\tcb = opts;\n\t\t\topts = undefined;\n\t\t}\n\n\t\t// process an array of items, where cb is run at completion of the final one\n\t\tif (isArray(pathPrefix)) {\n\t\t\tvar chainCb = new lib.Callback();\n\t\t\tpathPrefix.forEach(function(prefix) {\n\t\t\t\tif (prefix) {\n\t\t\t\t\tthis.preload(prefix, opts, chainCb.chain());\n\t\t\t\t}\n\t\t\t}, this);\n\t\t\tcb && chainCb.run(cb);\n\t\t\treturn chainCb;\n\t\t} else {\n\t\t\tpathPrefix = pathPrefix.replace(/^\\//, ''); // remove leading slash\n\t\t\t// if an item is found in the map, add that item's sheet to the group.\n\t\t\t// If there is no sheet in the map (i.e. for sounds), load that file directly.\n\t\t\tvar preloadSheets = {};\n\t\t\tvar map = this._map;\n\t\t\tfor (var uri in map) {\n\t\t\t\tif (uri.indexOf(pathPrefix) == 0) {\n\t\t\t\t\t// sprites have sheet; sounds are just by the filename key itself\n\t\t\t\t\tpreloadSheets[map[uri] && map[uri].sheet || uri] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvar files = Object.keys(preloadSheets);\n\t\t\tlogger.log(\"preloading sheets\", files);\n\n\t\t\tvar callback = this._loadGroup(merge({resources: files}, opts));\n\t\t\tcb && callback.run(cb);\n\t\t\treturn callback;\n\t\t}\n\t};\n\t\n\tvar soundLoader = null;\n\tthis.getSound = function(src) {\n\t\tif (!soundLoader) {\n\t\t\tjsio(\"import Sound\");\n\t\t\tsoundLoader = new Sound({path:\"\"});\n\t\t}\n\n\t\tif (GLOBAL.NATIVE && GLOBAL.NATIVE.sound && GLOBAL.NATIVE.sound.preloadSound) {\n\t\t\treturn NATIVE.sound.preloadSound(src);\n\t\t} else {\n\t\t\tsoundLoader.addSound(src);\n\t\t\t//HACK to make the preloader continue in the browser\n\t\t\treturn { complete: true };\n\t\t}\n\t}\n\n\tthis.getImage = function(src, noWarn) {\n\t\t// create the image\n\t\tvar img = new Image();\n\t\t\n\t\t// find the base64 image if it exists\n\t\tif (Image.get) {\n\t\t\tvar b64 = Image.get(src);\n\t\t\tif (b64 instanceof Image) { \n\t\t\t\treturn b64;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (b64) {\n\t\t\timg.src = b64;\n\t\t\tImage.set(src, img);\n\t\t} else {\n\t\t\tif (!noWarn) { logger.warn(src, 'may not be properly cached!'); }\n\t\t\timg.src = src;\n\t\t}\n\n\t\treturn img;\n\t}\n\n\t/** \n\t * used internally by timestep.Image to seamlessly convert\n\t * non-sprited image URLs to sprited images. This is here (rather\n\t * than in timestep.Image) to keep sprite formats in one consistent place. \n\t */\n\tthis._updateImageMap = function (map, url, x, y, w, h) {\n\n\t\tx = x || 0;\n\t\ty = y || 0;\n\t\tw = w == undefined ? -1 : w;\n\t\th = h == undefined ? -1 : h;\n\n\t\tvar info = this._map[url];\n\t\tif (!info || !info.sheet) {\n\t\t\tmap.x = x;\n\t\t\tmap.y = y;\n\t\t\tmap.width = w;\n\t\t\tmap.height = h;\n\t\t\tmap.scale = 1;\n\t\t\tmap.url = url;\n\t\t\treturn;\n\t\t}\n\n\t\tvar scale = info.scale || 1;\n\n\t\t// calculate the source rectangle, with margins added to the edges\n\t\t// (disregarding the fact that they may fall off the edge of the sheet)\n\t\tmap.x = info.x - info.marginLeft;\n\t\tmap.y = info.y - info.marginTop;\n\t\tmap.width = info.w + info.marginLeft + info.marginRight;\n\t\tmap.height = info.h + info.marginTop + info.marginBottom;\n\t\t\n\t\t// Add in any source map options passed in to get the actual offsets\n\t\tmap.x += x * scale;\n\t\tmap.y += y * scale;\n\t\tif (w > 0) {\n\t\t\tmap.width = w * scale;\n\t\t}\n\t\tif (h > 0) {\n\t\t\tmap.height = h * scale;\n\t\t}\n\t\t\n\t\t// now updatea the margins to account for the new source map\n\t\tmap.marginLeft = Math.max(0, info.x - map.x);\n\t\tmap.marginTop = Math.max(0, info.y - map.y);\n\t\tmap.marginRight = Math.max(0, (map.x + map.width) - (info.x + info.w));\n\t\tmap.marginBottom = Math.max(0, (map.y + map.height) - (info.y + info.h));\n\t\t\n\t\t// and re-offset the source map to exclude margins\n\t\tmap.x += map.marginLeft;\n\t\tmap.y += map.marginTop;\n\t\tmap.width -= (map.marginLeft + map.marginRight);\n\t\tmap.height -= (map.marginTop + map.marginBottom);\n\t\t\n\t\t// the scale of the source image, if scaled in a spritesheet\n\t\tmap.scale = scale;\n\t\tmap.url = info.sheet;\n\n\t\treturn map;\n\t}\n\n\tthis._getRaw = function(type, src, copy, noWarn) {\n\t\t// always return the cached copy unless specifically requested not to\n\t\tif (!copy && _cache[src]) { return _cache[src]; }\n\t\tvar res = null;\n\t\tswitch (type) {\n\t\t\tcase 'audio':\n\t\t\t\tres = this.getSound(src);\n\t\t\t\tbreak;\n\t\t\tcase 'image':\n\t\t\t\tres = this.getImage(src, noWarn);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tlogger.error('unknown type for preloader', type);\n\t\t}\n\t\treturn (_cache[src] = res);\n\t}\n\n\t// The callback is called for each image in the group with the image\n\t// source that loaded and whether there was an error.\n\t// \n\t// function callback(lastSrc, error, isComplete, numCompleted, numTotal)\n\t//    where error is true or false and isComplete is true when numCompleted == numTotal\n\t//\n\tthis._loadGroup = function (opts, cb) {\n\t\tvar timeout = opts.timeout;\n\t\tvar callback = new lib.Callback();\n\t\t\n\t\t// compute a list of images using file extensions\n\t\tvar resources = opts.resources || [];\n\t\tif (!resources || !resources.length) {\n\t\t\tcb && callback.run(cb);\n\t\t\tcallback.fire();\n\t\t\treturn callback;\n\t\t}\n\t\tvar n = resources.length;\n\t\tvar loadableResources = [];\n\t\tfor (var i = 0; i < n; ++i) {\n\t\t\tvar ext = resources[i].substring(resources[i].lastIndexOf('.')).split('|')[0];\n\t\t\tif (MIME[ext] == 'image') {\n\t\t\t\tloadableResources.push({type:'image', resource: resources[i]});\n\t\t\t\tGLOBAL.NATIVE && NATIVE.gl && NATIVE.gl.touchTexture(resources[i]);\n\t\t\t} else if (MIME[ext] == 'audio') {\n\t\t\t\tloadableResources.push({type:'audio', resource: resources[i]});\n\t\t\t}\n\t\t}\n\t\t\n\t\t// do the preload asynchronously (note that base64 is synchronous, only downloads are asynchronous)\n\t\tvar nextIndexToLoad = 0;\n\t\tvar numImages = loadableResources.length;\n\t\tvar parallel = opts.parallel || 5; // how many should we try to download at a time?\n\t\tvar isFinished = false; // may get set to true if the preload times out\n\t\t\n\t\tvar loadResource = bind(this, function() {\n\t\t    var currentIndex = nextIndexToLoad++;\n\t\t\tvar src = loadableResources[currentIndex];\n\t\t\tvar res;\n\t\t\tif (src) {\n\t\t\t\tres = this._getRaw(src.type, src.resource, false, true);\n\t\t\t} else {\n\t\t\t\tres = {complete: true, failed: true};\n\t\t\t}\n\n\t\t\tvar next = function(failed) {\n\t\t\t\tif (isFinished) { return; }\n\t\t\t\t\n\t\t\t\tres.onreload = res.onload = res.onerror = null;\n\t\t\t\tcb && cb(src, failed, currentIndex == numImages, currentIndex, numImages);\n\t\t\t\t\n\t\t\t\tisFinished = currentIndex >= numImages - 1;\n\t\t\t\tif (!isFinished) {\n\t\t\t\t\tsetTimeout(loadResource, 0);\n\t\t\t\t} else {\n\t\t\t\t\tif (_timeout) { clearTimeout(_timeout); }\n\t\t\t\t\tcallback.fire();\n\t\t\t\t}\n\t\t\t};\n\t\t\t\n\t\t\tif (res.reload && res.complete) {\n\t\t\t\tres.onreload = function () {\n\t\t\t\t\tnext(true);\n\t\t\t\t};\n\n\t\t\t\tres.onerror = function () {\n\t\t\t\t\tnext(false);\n\t\t\t\t}\n\n\t\t\t\tres.reload();\n\t\t\t} else if (res.complete) {\n\t\t\t\tnext(res.failed === false);\n\t\t\t} else {\n\t\t\t\tvar prevOnLoad = res.onload;\n\t\t\t\tvar prevOnError = res.onerror;\n\t\t\t\tres.onload = function() { \n\t\t\t\t\tprevOnLoad && prevOnLoad();\n\t\t\t\t\tres.failed = false; \n\t\t\t\t\tnext(false); \n\t\t\t\t};\n\t\t\t\tres.onerror = function() { \n\t\t\t\t\tprevOnError && prevOnError();\n\t\t\t\t\tres.failed = true; \n\t\t\t\t\tnext(true);\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\n\t\tvar _timeout = null;\n\t\tsetTimeout(function() {\n\t\t\t// spin up n simultaneous loaders!\n\t\t\tfor (var i = 0; i < parallel; ++i) { loadResource(); }\n\t\t\t\n\t\t\t// register timeout call\n\t\t\tif (timeout) {\n\t\t\t\t_timeout = setTimeout(function() {\n\t\t\t\t\tcallback.fire();\n\t\t\t\t\tisFinished = true;\n\t\t\t\t}, timeout)\n\t\t\t}\n\t\t}, 0);\n\t\t\n\t\treturn callback;\n\t}\n});\n\nexports = new Loader();\n","pre":true},"../../../../sdk/timestep/Sound.js":{"path":"../../../../sdk/timestep/Sound.js","friendlyPath":"Sound","directory":"../../../../sdk/timestep/","filename":"Sound.js","baseMod":"Sound","basePath":"../../../../sdk/timestep","src":"/**\n * @class Sound;\n * Implement the correct Audio support, depending on what platform we're running.\n *\n * @doc http://doc.gameclosure.com/api/sound.html\n * @docsrc https://github.com/gameclosure/doc/blob/master/api/sound.md\n */\n\njsio(\"import device\");\njsio(\"import event.Emitter as Emitter\");\n\n// Allow accessibility controls (like muting).\n// TODO This should definitely be in another file.\nGLOBAL.ACCESSIBILITY = new (Class(Emitter, function (supr) {\n\tthis.muted = false;\n\n\tthis.mute = function (flag) {\n\t\tthis.muted = flag;\n\t\tthis.publish('MuteChange');\n\t};\n}));\nif (GLOBAL.ONACCESSIBLE) {\n\tGLOBAL.ONACCESSIBLE();\n}\n\n// Determine which API to include.\nif (device.isMobileBrowser && !device.simulatingMobileBrowser){\n\tjsio(\"import runtimeBrowser.device.MobileBrowserAPI\");\n\texports = runtimeBrowser.device.MobileBrowserAPI;\n} else {\n\texports = jsio('import ui.backend.sound.HTML5API');\n}\n","pre":true},"../../../../sdk/timestep/ui/backend/sound/HTML5API.js":{"path":"../../../../sdk/timestep/ui/backend/sound/HTML5API.js","friendlyPath":"ui.backend.sound.HTML5API","directory":"../../../../sdk/timestep/ui/backend/sound/","filename":"HTML5API.js","src":"// An API for playing named sounds. Sounds can be given a single file source\n// or multiple sources which will be chosen at random at play time. Sounds may\n// also be given a default volume and loop boolean.\n//\n// Only one background sound can be played at a time. They are streamed, not\n// preloaded, on native.\n\njsio(\"import event.Emitter as Emitter\");\njsio(\"import util.path\");\njsio(\"import device\");\n\n// \"Extend\" the local instance of Audio objects.\nRawAudio=__class__;var RawAudio=RawAudio(function RawAudio(){return this.init&&this.init.apply(this,arguments)},function () {\n\tthis.init = function () {\n\t\tvar audio = new Audio();\n\n\t\t// we can't really extend an HTML5 audio object in a browser, so\n\t\t// do our best...\n\t\tvar proto = RawAudio.prototype;\n\t\tfor (var i in proto) {\n\t\t\tif (!audio[i] && proto.hasOwnProperty(i)) {\n\t\t\t\taudio[i] = RawAudio.prototype[i];\n\t\t\t}\n\t\t}\n\n\t\t// Hook into accessibility features.\n\t\tGLOBAL.ACCESSIBILITY.subscribe('MuteChange', this, function () {\n\t\t\taudio.muted = GLOBAL.ACCESSIBILITY.muted;\n\t\t});\n\t\taudio.muted = GLOBAL.ACCESSIBILITY.muted;\n\n\t\treturn audio;\n\t};\n\n\t// add a stop method that resets the current time\n\tthis.stop = function () {\n\t\ttry {\n\t\t\t// html5 Audio object\n\t\t\tif (!this.paused) { this.pause(); }\n\n\t\t\t// if we have the NETWORK_LOADING flag, only restart currentTime if the sound has loaded.\n\t\t\t// http://scottdowne.wordpress.com/2010/08/17/no-more-exceptions/\n\t\t\tif ((!('NETWORK_LOADING' in this)\n\t\t\t\t\t|| this.networkState != this.NETWORK_LOADING\n\t\t\t\t\t|| this.networkState != this.NETWORK_NO_SOURCE)\n\t\t\t\t\t&& !isNaN(this.duration)) {\n\t\t\t\tthis.currentTime = 0;\n\t\t\t}\n\t\t} catch (e) {}\n\t};\n});\n\n/**\n * A sound object that can play one of a collection of audio sources.\n */\nMultiSound=__class__;var MultiSound=MultiSound(function MultiSound(){return this.init&&this.init.apply(this,arguments)},function () {\n\tthis.init = function (soundManager, name, opts) {\n\t\tthis._soundManager = soundManager;\n\t\tthis._name = name;\n\n\t\t// if a list of file names is given in sources, load them as alternative\n\t\t// clips for this sound. Else, assume the only clip for this sound\n\t\t// is the file with its same name\n\t\topts = typeof opts == 'string' ? {sources: [opts]} : (opts || {});\n\t\tvar srcList = opts.sources || [name];\n\t\tvar sources = this._sources = [];\n\n\t\tvar basePath = soundManager.getPath();\n\t\tvar ext = soundManager.getExt();\n\t\tvar extTestExp = new RegExp(ext + '$', 'i');\n\n\t\tvar loop = opts.loop || opts.background;\n\t\tvar volume = opts.volume !== undefined ? opts.volume : 1.0;\n\n\t\tfor (var i = 0, src; src = srcList[i]; ++i) {\n\n\t\t\t// file paths are relative to the base path\n\t\t\tvar fullPath = util.path.join(basePath, opts.path, src);\n\n\t\t\t// append the extension if not already provided\n\t\t\tif (!extTestExp.test(fullPath)) {\n\t\t\t\tfullPath += ext;\n\t\t\t}\n\n\t\t\tvar audio = new RawAudio();\n\t\t\tif (device.isMobileNative) {\n\t\t\t\t//if this isn't none on native, native will preload things like music, which is Not Good.\n\t\t\t\t//however this also prevents music from being played in Chrome (as of 23.0.1271.91)\n\t\t\t\t//so if we're actually on native, preload should be none, otherwise auto.\n\t\t\t\taudio.preload = 'none';\n\t\t\t}\n\t\t\taudio.loop = loop;\n\t\t\taudio.volume = volume;\n\t\t\taudio.isBackgroundMusic = opts.background;\n\t\t\taudio.src = fullPath;\n\n\t\t\t// TODO: what's this option for??\n\t\t\tif (opts.isLoaded && typeof audio.load == 'function') {\n\t\t\t\taudio.load();\n\t\t\t}\n\n\t\t\tsources.push(audio);\n\t\t}\n\n\t\tthis.isBackgroundMusic = opts.background;\n\t};\n\n\tthis.setVolume = function (volume) {\n\t\tfor (var i = 0, src; src = this._sources[i]; ++i) {\n\t\t\tsrc.volume = volume;\n\t\t}\n\t};\n\n\tthis.stop = function () {\n\t\tfor (var i = 0, src; src = this._sources[i]; ++i) {\n\t\t\tsrc.stop();\n\t\t}\n\t};\n\n\tthis.pause = function () {\n\t\tthis._isPaused = true;\n\n\t\tfor (var i = 0, src; src = this._sources[i]; ++i) {\n\t\t\tsrc.pause();\n\t\t}\n\t};\n\n\tthis.play = function (opts) {\n\t\topts = opts || {};\n\t\tif (!this._isPaused) {\n\t\t\tthis.stop();\n\t\t} else {\n\t\t\tthis._isPaused = false;\n\t\t}\n\n\t\tthis._currentSource = this._getRandom();\n\t\tthis._currentSource.loop = opts.loop || this.isBackgroundMusic;\n\t\tthis._currentSource.play();\n\t};\n\n\tthis._getRandom = function () {\n\t\tvar index = Math.random() * this._sources.length | 0;\n\t\treturn this._sources[index];\n\t};\n});\n\n/**\n * @extends event.Emitter\n */\nvar sdk_timestep_ui_backend_sound_HTML5API=__class__;exports=sdk_timestep_ui_backend_sound_HTML5API(function sdk_timestep_ui_backend_sound_HTML5API(){return this.init&&this.init.apply(this,arguments)},Emitter, function(supr) {\n\tthis.init = function(opts) {\n\t\topts = opts || {};\n\n\t\tsupr(this, 'init', [opts]);\n\n\t\tthis.setPath(opts.path);\n\n\t\t//opts.map is deprecated in favor of opts.files\n\t\tthis._map = opts.files || opts.map;\n\t\tthis._sounds = {};\n\t\tthis._isMusicMuted = false;\n\t\tthis._areEffectsMuted = false;\n\t\tthis._currentMusic = null;\n\n\t\tif (opts.persist) {\n\t\t\tthis.persistState(opts.persist);\n\t\t}\n\n\t\t// determine whether browser supports mp3 or ogg. Default to mp3 if\n\t\t// both are supported. Native will return true for everything, but\n\t\t// on native, we store ogg files as .mp3 files, so return .mp3...\n\t\tvar sound = new Audio();\n\t\tthis._ext = sound.canPlayType(\"audio/mpeg\") ? '.mp3'\n\t\t\t: sound.canPlayType(\"audio/ogg\") ? '.ogg' : '';\n\n\t\tif (!this._ext) {\n\t\t\tthis._ext = '.mp3';\n\t\t\tlogger.log('warning: could not determine sound support type');\n\t\t}\n\n\t\t// add sounds to the audio API's list of sounds and\n\t\t// preload them if appropriate\n\t\tfor (var key in this._map) {\n\t\t\tvar item = this._map[key];\n\t\t\tthis.addSound(key, item);\n\t\t}\n\t};\n\n\tthis.getExt = function () { return this._ext; };\n\n\tthis.getPath = function (name) {\n\t\treturn (name) ? this._sounds[name].path : this._path;\n\t};\n\n\tthis.setPath = function (path) {\n\t\tif (path) {\n\t\t\tpath = path.replace(/\\/$/, '');\n\t\t}\n\n\t\tthis._path = path || '';\n\t};\n\n\tthis.addSound = function(name, opts) {\n\t\tthis._sounds[name] = new MultiSound(this, name, opts);\n\t};\n\n\t/* @internal for now\n\t */\n\tthis.persistState = function (key) {\n\t\tthis._key = key;\n\n\t\tvar value = localStorage.getItem(this._key);\n\t\tif (value) { try { value = JSON.parse(value); } catch (e) {} }\n\t\tif (value) {\n\t\t\tlogger.log('restoring audio api state');\n\t\t\tthis.setMusicMuted(value.isMusicMuted);\n\t\t\tthis.setEffectsMuted(value.areEffectsMuted);\n\t\t}\n\t};\n\n\t/* @internal for now\n\t */\n\tthis._persist = function () {\n\t\tif (this._key) {\n\t\t\tlocalStorage.setItem(this._key, JSON.stringify({\n\t\t\t\t\tisMusicMuted: this._isMusicMuted,\n\t\t\t\t\tareEffectsMuted: this._areEffectsMuted\n\t\t\t\t}));\n\t\t}\n\t};\n\n\tthis.getMuted = function () { return this._isMusicMuted && this._areEffectsMuted; };\n\tthis.getMusicMuted = function () { return this._isMusicMuted; };\n\tthis.getEffectsMuted = function () { return this._areEffectsMuted; };\n\n\t// global mute\n\tthis.setMuted = function (isMuted) {\n\t\tthis.setMusicMuted(isMuted);\n\t\tthis.setEffectsMuted(isMuted);\n\t};\n\n\tthis.setMusicMuted = function (isMusicMuted) {\n\t\tif (isMusicMuted == this._isMusicMuted) { return; }\n\t\tthis._isMusicMuted = isMusicMuted;\n\t\tthis._persist();\n\n\t\t// resume music on unmute\n\t\tif (this._currentMusic) {\n\t\t\tif (isMusicMuted) {\n\t\t\t\tthis._currentMusic.pause();\n\t\t\t} else {\n\t\t\t\tthis._currentMusic.play();\n\t\t\t}\n\t\t}\n\t};\n\n\tthis.setEffectsMuted = function (areEffectsMuted) {\n\t\tif (areEffectsMuted == this._areEffectsMuted) { return; }\n\t\tthis._areEffectsMuted = areEffectsMuted;\n\t\tthis._persist();\n\n\t\tif (areEffectsMuted) {\n\t\t\tfor (var key in this._sounds) {\n\t\t\t\tvar sound = this._sounds[key];\n\t\t\t\tif (!sound.isBackgroundMusic) {\n\t\t\t\t\tsound.stop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tthis.setVolume = function(name, volume) {\n\t\tvar sound = this._sounds[name];\n\t\tif (sound) {\n\t\t\tsound.setVolume(volume);\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t};\n\n\tthis.getVolume = function (name) {\n\t\tvar sound = this._sounds[name];\n\t\tif (sound) {\n\t\t\tvar elem = sound._sources[0]; //first audio element\n\t\t\treturn Math.round(10 * elem.volume) / 10; //round to nearest tenth\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t};\n\n\tthis.play = function (name, opts) {\n\t\tvar sound = this._sounds[name];\n\t\topts = opts || {};\n\t\tif (!sound) {\n\t\t\tlogger.log(\"warning: no sound of that name\");\n\t\t\treturn false;\n\t\t}\n\n\t\tvar isBackgroundMusic = sound.isBackgroundMusic;\n\t\tif (isBackgroundMusic) {\n\t\t\t// some platforms enforce only one simultaneous background music\n\t\t\t// (native) while others do not.  Enforce it always.\n\t\t\tif (this._currentMusic) {\n\t\t\t\tthis._currentMusic.stop();\n\t\t\t}\n\n\t\t\tthis._currentMusic = sound;\n\n\t\t\t// if we're muted, make sure to resume the music if we unmute\n\t\t\tif (!this._isMusicMuted) {\n\t\t\t\tsound.play(opts);\n\t\t\t}\n\t\t} else if (!this._areEffectsMuted) {\n\t\t\tsound.play(opts);\n\t\t}\n\n\t\treturn true;\n\t};\n\n\tthis.pause = function (name) {\n\t\tvar sound = this._sounds[name];\n\t\tif (!sound) { return false; }\n\n\t\t// if we're muted and we pause the current music,\n\t\t// don't resume the music on unmute.\n\t\tif (this._currentMusic == sound) {\n\t\t\tthis._currentMusic = null;\n\t\t}\n\n\t\tsound.pause();\n\n\t\treturn true;\n\t};\n\n\tthis.stop = function (name) {\n\t\tvar sound = this._sounds[name];\n\t\tif (!sound) { return false; }\n\n\t\t// if we're muted and we pause the current music,\n\t\t// don't resume the music on unmute.\n\t\tif (this._currentMusic == sound) {\n\t\t\tthis._currentMusic = null;\n\t\t}\n\n\t\tsound.stop();\n\n\t\treturn true;\n\t};\n\n\t// @deprecated\n\tthis.playBackgroundMusic = this.play;\n\n\t// @deprecated\n\tthis.pauseBackgroundMusic = function () {\n\t\tthis._currentMusic && this._currentMusic.pause();\n\t};\n});\n","pre":true},"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/util/path.js":{"path":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/util/path.js","friendlyPath":"util.path","directory":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/util/","filename":"path.js","baseMod":"util","basePath":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio","pre":true,"src":"var util = jsio.__jsio.__util;\n\nexports.join = util.buildPath;\nexports.resolveRelativePath = util.resolveRelativePath;\nexports.splitPath = util.splitPath;\nexports.makeRelativePath = util.makeRelativePath;\nexports.splitExt = function(path) {\n\tvar res = exports.splitPath(path);\n\tvar i = res.filename.lastIndexOf('.');\n\tif (i == -1) {\n\t\tres.basename = res.filename;\n\t\tres.ext = '';\n\t} else {\n\t\tres.basename = res.filename.substring(0, i);\n\t\tres.ext = res.filename.substring(i);\n\t}\n\treturn res;\n}"},"../../../../sdk/timestep/ui/backend/dom/StackView.js":{"path":"../../../../sdk/timestep/ui/backend/dom/StackView.js","friendlyPath":".backend.dom.StackView","directory":"../../../../sdk/timestep/ui/backend/dom/","filename":"StackView.js","src":"jsio(\"import ui.View\");\n\n/**\n * @extends timestep.dom.View\n */\nvar sdk_timestep_ui_backend_dom_StackView=__class__;exports=sdk_timestep_ui_backend_dom_StackView(function sdk_timestep_ui_backend_dom_StackView(){return this.init&&this.init.apply(this,arguments)},View, function(supr) {\n\n\tthis.init = function(opts) {\n\t\tsupr(this, 'init', arguments);\n\t\tthis.stack = [];\n\t}\n\t\n\tthis.getCurrentView = function() {\n\t\tif (!this.stack.length) { return null; }\n\t\treturn this.stack[this.stack.length - 1];\n\t}\n\t\n\tthis.push = function(view, dontAnimate) {\n\t\t// don't animate the first (base) view of a stackview unless explicitly asked to\n\t\tif (!this.stack[0] && dontAnimate !== false) {\n\t\t\tdontAnimate = true;\n\t\t}\n\t\t\n\t\tvar current = this.getCurrentView();\n\t\tif (current) { this._hide(current, dontAnimate); }\n\t\tview.style.width = this.style.width;\n\t\tview.style.height = this.style.height;\n\t\tthis.stack.push(view);\n\t\tthis._show(view, dontAnimate);\n\t\treturn view;\n\t}\n\t\n\tthis._hide = function(view, dontAnimate, backward) {\n\t\tview.publish('ViewWillDisappear');\n\t\tif (!dontAnimate) {\n\t\t\t// Prevent touches from triggering buttons/UI on the\n\t\t\t// disappearing view. Unfortunately, canHandleEvents()\n\t\t\t// doesn't affect subviews, so an overlay is added here\n\t\t\t// so that touches just don't go through while it animates out.\n\t\t\tvar overlay = new View({parent: view, zIndex: 100000});\n\t\t\tview.then({x: (backward ? 1 : -1) * view.style.width})\n\t\t\t\t.then(bind(this, 'removeSubview', view))\n\t\t\t\t.then(bind(view, 'publish', 'ViewDidDisappear'))\n\t\t\t\t.then(bind(overlay, 'removeFromSuperview'));\n\t\t} else {\n\t\t\tthis.removeSubview(view);\n\t\t\tview.publish('ViewDidDisappear');\n\t\t}\n\t}\n\n\tthis._show = function(view, dontAnimate, backward) {\n\t\tview.publish('ViewWillAppear');\n\t\tview.style.visible = true;\n\t\tif (!dontAnimate) {\n\t\t\tview.style.x = (backward ? -1 : 1) * this.style.width;\n\t\t\tthis.addSubview(view);\n\t\t\tview.then({x: 0})\n\t\t\t\t.then(bind(view, 'publish', 'ViewDidAppear'));\n\t\t} else {\n\t\t\tthis.addSubview(view);\n\t\t\tview.style.x = 0;\n\t\t\tview.publish('ViewDidAppear');\n\t\t}\n\t}\n\t\n\tthis.pop = function(dontAnimate) {\n\t\tif (!this.stack.length) { return false; }\n\t\tvar view = this.stack.pop();\n\t\tthis._hide(view, dontAnimate, true);\n\t\t\n\t\tif (this.stack.length) {\n\t\t\tthis._show(this.stack[this.stack.length - 1], dontAnimate, true);\n\t\t}\n\t\t\n\t\treturn view;\n\t}\n\t\n\tthis.popAll = function(dontAnimate) {\n\t\twhile (this.stack[1]) {\n\t\t\tthis.pop(dontAnimate);\n\t\t}\n\t}\n});\n","pre":true},"../../../../sdk/timestep/ui/backend/dom/TextView.js":{"path":"../../../../sdk/timestep/ui/backend/dom/TextView.js","friendlyPath":".backend.dom.TextView","directory":"../../../../sdk/timestep/ui/backend/dom/","filename":"TextView.js","src":"/**\n * @package ui.backend.dom.TextView;\n *\n * TextView implementation for DOM.\n */\n\njsio(\"import ui.layout.LinearView as LinearView\");\njsio(\"import device\");\n\n/**\n * @extends ui.layout.LinearView\n */\nvar sdk_timestep_ui_backend_dom_TextView=__class__;exports=sdk_timestep_ui_backend_dom_TextView(function sdk_timestep_ui_backend_dom_TextView(){return this.init&&this.init.apply(this,arguments)},LinearView, function (supr) {\n\n\tthis._displayStyle = \"table\";\n\n\tvar defaults = {\n\t\t// layout properties...\n\t\twrap: true,\n\t\tautoSize: true,\n\t\tautoFontSize: true,\n\t\tverticalPadding: 0,\n\t\thorizontalPadding: 0,\n\t\tlineHeight: 1.2,\n\n\t\t// font properties...\n\t\tcolor: \"#000000\",\n\t\tfontFamily: device.defaultFontFamily,\n\t\tfontWeight: \"\",\n\t\tsize: 12,\n\t\tlineWidth: 2,\n\t\toutlineColor: null,\n\t\tshadowColor: null,\n\n\t\t// alignment properties...\n\t\tverticalAlign: \"middle\",\n\t\thorizontalAlign: \"center\",\n\n\t\t// misc properties...\n\t\tbackgroundColor: null\n\t};\n\n\tthis.init = function (opts) {\n\t\tsupr(this, \"init\", [merge(opts, defaults)]);\n\t};\n\n\tthis.updateOpts = function(opts) {\n\t\topts = supr(this, \"updateOpts\", arguments);\n\n\t\tvar s = this.__view.getElement().style;\n\n\t\tif (opts.horizontalPadding) {\n\t\t\tif (isArray(opts.horizontalPadding)) {\n\t\t\t\ts.paddingLeft = opts.horizontalPadding[0] + \"px\";\n\t\t\t\ts.paddingRight = opts.horizontalPadding[0] + \"px\";\n\t\t\t} else {\n\t\t\t\ts.paddingLeft = opts.horizontalPadding + \"px\";\n\t\t\t\ts.paddingRight = opts.horizontalPadding + \"px\";\n\t\t\t}\n\t\t}\n\n\t\tif (opts.verticalPadding) {\n\t\t\tif (isArray(opts.verticalPadding)) {\n\t\t\t\ts.paddingTop = opts.verticalPadding[0] + \"px\";\n\t\t\t\ts.paddingBottom = opts.verticalPadding[0] + \"px\";\n\t\t\t} else {\n\t\t\t\ts.paddingTop = opts.verticalPadding + \"px\";\n\t\t\t\ts.paddingBottom = opts.verticalPadding + \"px\";\n\t\t\t}\n\t\t}\n\n\t\tif (opts.color)           { s.color = opts.color; }\n\t\tif (opts.size)            { s.fontSize = opts.fontSize + \"px\"; }\n\t\tif (opts.fontFamily)      { s.fontFamily = opts.fontFamily; }\n\t\tif (opts.horizontalAlign) { s.textAlign = opts.horizontalAlign; }\n\t\tif (opts.fontWeight)      { s.fontWeight = opts.fontWeight; }\n\t\tif (opts.shadowColor)     { s.textShadow = opts.shadowColor + \" 2px 2px 1px\"; }\n\t\tif (opts.outlineColor)    { s.webkitTextStroke = opts.lineWidth + \"px \" + opts.outlineColor; }\n\t\tif (!opts.wrap)           { s.whiteSpace = \"nowrap\"; }\n\n\t\ts.display = \"table\";\n\n\t\tif (\"text\" in opts) this.setText(opts.text);\n\t};\n\n\tthis.getText = function() {\n\t\treturn this.__view.getElement().getElementsByTagName(\"span\")[0].innerHTML;\n\t}\n\n\tthis.reflow = function() {\n\t\tif (this._textNode && this._opts.autoSize) {\n\t\t\tvar idealHeight = this._textNode.scrollHeight;\n\t\t\tif (!this.style.height || this.style.height < idealHeight) {\n\t\t\t\tthis.style.height = idealHeight;\n\t\t\t}\n\t\t}\n\t};\n\n\tthis.setText = function (text) {\n\t\tif (typeof text == \"function\") {\n\t\t\treturn text(this);\n\t\t}\n\n\t\tif (this._text != text) {\n\t\t\tthis._text = text;\n\t\t\tvar n = this._textNode || document.createElement(\"span\");\n\t\t\tif (!this._textNode) {\n\t\t\t\tthis._textNode = n;\n\t\t\t\tthis.__view.getElement().appendChild(n);\n\t\t\t\tn.className = \"text\";\n\t\t\t\tn.style.display = \"table-cell\";\n\t\t\t\tn.style.verticalAlign = this._opts.verticalAlign || \"middle\";\n\t\t\t}\n\t\t\tthis._textNode.innerText = text || \"\";\n\t\t\tthis.needsReflow();\n\t\t}\n\t};\n});\n","pre":true},"../../../../sdk/timestep/ui/backend/dom/ViewBacking.js":{"path":"../../../../sdk/timestep/ui/backend/dom/ViewBacking.js","friendlyPath":".backend.dom.ViewBacking","directory":"../../../../sdk/timestep/ui/backend/dom/","filename":"ViewBacking.js","src":"jsio(\"import device\");\njsio(\"import event.Callback as Callback\");\njsio(\"import animate\");\njsio(\"import animate.transitions as transitions\");\njsio(\"import event.input.InputEvent as InputEvent\");\njsio(\"import math.geom.Point as Point\");\njsio(\"from util.browser import $\");\n\njsio(\"import ..BaseBacking\");\n\nvar Canvas = device.get('Canvas');\n\nvar AVOID_CSS_ANIM = device.isAndroid;\n\n\nvar sdk_timestep_ui_backend_dom_ViewBacking=__class__;var ViewBacking = exports=sdk_timestep_ui_backend_dom_ViewBacking(function sdk_timestep_ui_backend_dom_ViewBacking(){return this.init&&this.init.apply(this,arguments)},BaseBacking, function() {\n\n\tvar arr = ['x', 'y', 'r', 'width', 'height', 'visible', 'anchorX', 'anchorY',\n\t\t\t   'opacity', 'scale', 'zIndex', 'scrollLeft', 'scrollTop', 'flipX', 'flipY'];\n\n\tvar CUSTOM_KEYS = {};\n\n\tarr.forEach(function (prop) {\n\t\tCUSTOM_KEYS[prop] = true;\n\n\t\tthis.__defineGetter__(prop, function() {\n\t\t\tif (prop in this._computed) {\n\t\t\t\treturn this._computed[prop];\n\t\t\t} else {\n\t\t\t\treturn parseInt(this._node.style[prop]);\n\t\t\t}\n\t\t});\n\t\tthis.__defineSetter__(prop, function(val) {\n\t\t\tvar props = {};\n\t\t\tprops[prop] = val;\n\t\t\tthis._setProps(props);\n\t\t\treturn val;\n\t\t});\n\t}, this);\n\n\tthis.init = function (view, opts) {\n\t\tthis._view = view;\n\t\tthis._subviews = [];\n\n\t\tvar n = this._node = document.createElement(opts.elementType || 'div');\n\n\t\t// used to identify dom nodes\n\t\tn._view = view;\n\t\tn.addEventListener(\"webkitTransitionEnd\", bind(this, \"_transitionEnd\"), false);\n\t\tn.className = \"view\" + \" \" + opts.className;\n\n\t\tvar s = n.style;\n\t\ts.fontSize = '1px';\n\t\ts.position = \"absolute\";\n\t\ts.top = \"0px\";\n\t\ts.left = \"0px\";\n\t\tif (!device.isAndroid) {\n\t\t\ts.webkitBackfaceVisibility = 'hidden';\n\t\t}\n\n\t\ts.webkitTransformOrigin = '0px 0px';\n\n\t\t// add any custom CSS style\n\t\tfor (var name in opts.styles) {\n\t\t\ts[name] = opts.styles[name];\n\t\t}\n\n\t\t// store for the computed styles\n\t\tthis._computed = {\n\t\t\tx: 0,\n\t\t\ty: 0,\n\t\t\tr: 0,\n\t\t\twidth: undefined,\n\t\t\theight: undefined,\n\t\t\tanchorX: 0,\n\t\t\tanchorY: 0,\n\t\t\topacity: 1,\n\t\t\tvisible: true,\n\t\t\tzIndex: 0,\n\t\t\tscale: 1\n\t\t};\n\n\t\t// animation\n\t\tthis._animating = false;\n\t\tthis._animationQueue = [];\n\t\tthis._animationCallback = null;\n\t}\n\n\tthis.getElement = function () { return this._node; }\n\n\tvar ADD_COUNTER = 900000;\n\tthis.addSubview = function (view) {\n\t\tvar backing = view.__view;\n\t\tvar node = backing._node;\n\t\tvar superview = node.parentNode && node.parentNode._view;\n\t\tif (superview == this._view) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\tif (superview) { superview.__view.removeSubview(view); }\n\t\t\tvar n = this._subviews.length;\n\t\t\tthis._subviews[n] = view;\n\t\t\tthis._node.appendChild(node);\n\n\t\t\tbacking._setAddedAt(++ADD_COUNTER);\n\t\t\tif (n && backing.__sortKey < this._subviews[n - 1].__view.__sortKey) {\n\t\t\t\tthis._needsSort = true;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tthis.removeSubview = function (targetView) {\n\t\tvar index = this._subviews.indexOf(targetView);\n\t\tif (index != -1) {\n\t\t\tthis._subviews.splice(index, 1);\n\t\t\tthis._node.removeChild(targetView.__view._node);\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tthis.getSuperview = function() {\n\t\tvar p = this._node.parentNode;\n\t\tif (p == document.body || !p) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn p._view;\n\t}\n\n\tthis.getSubviews = function () {\n\t\tif (this._needsSort) { this._needsSort = false; this._subviews.sort(); }\n\t\treturn this._subviews;\n\t}\n\n\tthis.wrapTick = function(dt, app) {\n\t\tthis._view.tick && this._view.tick(dt, app);\n\n\t\tfor (var i = 0, view; view = this._subviews[i]; ++i) {\n\t\t\tview.__view.wrapTick(dt, app);\n\t\t}\n\t}\n\n\tthis.wrapRender = function(ctx, opts) {\n\t\tif (!this.visible) { return; }\n\n\t\tif (!this.__firstRender) { this._view.needsReflow(true); }\n\t\tif (this._needsSort) { this._needsSort = false; this._subviews.sort(); }\n\n\n\t\tvar width = this._computed.width;\n\t\tvar height = this._computed.height;\n\t\tif (!width || !height || width < 0 || height < 0) { return; }\n\n\t\t// var filters = this._view.getFilters();\n\t\t// ctx.setFilters(filters);\n\n\t\ttry {\n\t\t\tvar render = this._view.render;\n\t\t\tif (render && !render.isFake) {\n\t\t\t\tif (!this._canvas) {\n\t\t\t\t\tvar canvas = new Canvas();\n\t\t\t\t\tthis._canvas = canvas;\n\t\t\t\t\tthis._node.insertBefore(this._canvas, this._node.firstChild);\n\t\t\t\t\tthis.ctx = this._canvas.getContext('2d');\n\t\t\t\t}\n\n\t\t\t\tvar needsRepaint = this._view._needsRepaint;\n\n\t\t\t\t// clear the canvas\n\t\t\t\tif ((width | 0) != this._canvas.width || (height | 0) != this._canvas.height) {\n\t\t\t\t\tneedsRepaint = true;\n\t\t\t\t\tthis._canvas.width = width;\n\t\t\t\t\tthis._canvas.height = height;\n\t\t\t\t}\n\n\t\t\t\tif (needsRepaint) {\n\t\t\t\t\tthis._view._needsRepaint = false;\n\t\t\t\t\tthis._canvas.style.display = 'none';\n\t\t\t\t\tthis.ctx.clear();\n\t\t\t\t\t// this.ctx.fillStyle = 'red';\n\t\t\t\t\t// this.ctx.fillRect(0, 0, 1000, 1000);\n\t\t\t\t\tthis.ctx.save();\n\t\t\t\t\trender.call(this._view, this.ctx, opts);\n\t\t\t\t\tthis.ctx.restore();\n\t\t\t\t\tthis._canvas.style.display = 'block';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._renderSubviews(ctx, opts);\n\t\t} catch(e) {\n\t\t \tlogger.error(this, e.message, e.stack);\n\t\t}\n\t}\n\n\tthis._renderSubviews = function(ctx, opts) {\n\t\tvar i = 0;\n\t\tvar view;\n\t\tvar subviews = this._subviews;\n\t\twhile (view = subviews[i++]) {\n\t\t\tview.__view.wrapRender(ctx, opts);\n\t\t}\n\t}\n\n\tthis.localizePoint = function(pt) {\n\t\tvar s = this._computed;\n\t\tpt.x -= s.x + s.anchorX;\n\t\tpt.y -= s.y + s.anchorY;\n\t\tif (s.r) { pt.rotate(-s.r); }\n\t\tpt.scale(1 / s.scale);\n\t\tpt.x += s.anchorX;\n\t\tpt.y += s.anchorY;\n\t\treturn pt;\n\t}\n\n\t// exports the current style object\n\tthis.copy = function() {\n\t\treturn merge({}, this._computed);\n\t}\n\n\tthis.update = function(style) { this._setProps(style); }\n\n\t//****************************************************************\n\t// ANIMATION\n\n\tfunction getEasing(fn) {\n\t\tif (typeof fn == 'string') { return fn; }\n\t\tif (fn == transitions.easeIn) { return 'ease-in'; }\n\t\tif (fn == transitions.easeOut) { return 'ease-out'; }\n\t\tif (fn == transitions.easeInOut) { return 'ease-in-out'; }\n\t\tif (fn == transitions.linear) { return 'linear'; }\n\t\treturn 'ease';\n\t};\n\n\tthis._updateOrigin = function () {\n\t\tvar s = this._node.style;\n\t\tif (this._circle) {\n\t\t\ts.webkitTransformOrigin = '50% 50%';\n\t\t} else {\n\t\t\ts.webkitTransformOrigin = (this._computed.anchorX || 0) + 'px ' + (this._computed.anchorY || 0) + 'px';\n\t\t}\n\n\t}\n\n\t// {\n\t// \t'x': {value: 0, cb: '_onPosition'},\n\t// \t'y': {value: 0, cb: '_onPosition'},\n\t// }\n\n\tthis._onPosition = function (key, value) {\n\t\tvalue = Math.floor(value);\n\t\tthis._setMatrix();\n\t}\n\n\tthis._onResize = function () {\n\t\t// order matters\n\t\tthis._setMatrix();\n\t\tthis._setCenter();\n\t\tthis._view.needsReflow();\n\t}\n\n\tthis._setProps = function (props, anim) {\n\t\tvar setMatrix = false;\n\t\tvar s = this._node.style;\n\t\tvar animCount = 0;\n\t\tvar resized = false;\n\t\tvar previous = {};\n\t\tfor (var key in props) {\n\t\t\tvar value = props[key];\n\t\t\tif (key == \"dx\" || key == \"dy\") {\n\t\t\t\tkey = key.substr(1);\n\t\t\t\tvalue = this._computed[key] + value;\n\t\t\t}\n\t\t\tswitch (key) {\n\t\t\t\tcase \"circle\":\n\t\t\t\t\tthis._circle = value;\n\t\t\t\t\tthis._setCenter();\n\t\t\t\t\tthis._updateOrigin();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"anchorX\":\n\t\t\t\tcase \"anchorY\":\n\t\t\t\t\tthis._computed[key] = value;\n\t\t\t\t\tthis._updateOrigin();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"clip\":\n\t\t\t\t\tthis._computed.clip = value;\n\t\t\t\t\ts.overflow = value ? 'hidden' : 'visible';\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"zIndex\":\n\t\t\t\t\tif (this._computed.zIndex != value) {\n\t\t\t\t\t\tthis._computed.zIndex = value;\n\t\t\t\t\t\ts.zIndex = value;\n\t\t\t\t\t\tthis._onZIndex(value);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"x\":\n\t\t\t\tcase \"y\":\n\t\t\t\t\tvalue = Math.floor(value);\n\t\t\t\tcase \"r\":\n\t\t\t\tcase \"scale\":\n\t\t\t\t\tif (this._computed[key] != value) {\n\t\t\t\t\t\tprevious[key] = this._computed[key];\n\t\t\t\t\t\tthis._computed[key] = value;\n\t\t\t\t\t\tsetMatrix = true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (this._computed[key] != value) {\n\t\t\t\t\t\t++animCount;\n\t\t\t\t\t    this._computed[key] = value;\n\t\t\t\t\t\tif (key == 'width' || key == 'height') {\n\t\t\t\t\t\t\ts[key] = value + 'px';\n\t\t\t\t\t\t\tresized = true;\n\t\t\t\t\t\t} else if (key == 'visible') {\n\t\t\t\t\t\t\ts.display = (value ? this._displayStyle || 'block' : 'none');\n\t\t\t\t\t\t\t//s.visibility = (value ? 'visible' : 'hidden');\n\t\t\t\t\t\t\t// chrome has an obscure rendering bug where visibility:hidden won't\n\t\t\t\t\t\t\t// hide the canvas element child nodes sometimes. If you set opacity to zero, it will.\n\t\t\t\t\t\t\t//s.opacity = (value ? this._computed['opacity'] : 0);\n\n\t\t\t\t\t\t} else if (key == 'opacity') {\n\t\t\t\t\t\t\ts[key] = value;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts[key] = value;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (!CUSTOM_KEYS[key]) {\n\t\t\t\t\t\t\t\tthis[key] = value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (setMatrix) {\n\t\t\t++animCount;\n\t\t\tif (AVOID_CSS_ANIM) {\n\t\t\t\tvar obj = {\n\t\t\t\t\tscale: previous.scale || this._computed.scale,\n\t\t\t\t\tr: previous.r || this._computed.r\n\t\t\t\t};\n\t\t\t\t// because of android bugs,\n\t\t\t\t// we must never animate -webkit-transform.\n\t\t\t\t// http://code.google.com/p/android/issues/detail?id=12451\n\t\t\t\tif (anim && ((obj.scale != this._computed.scale) ||\n\t\t\t\t\t\t\t (obj.r != this._computed.r))) {\n\t\t\t\t\t// logger.log('set transform animated', obj.scale, this._computed.scale, obj.r, this._computed.r);\n\t\t\t\t\tanimate(obj).now({\n\t\t\t\t\t\tscale: this._computed.scale,\n\t\t\t\t\t\tr: this._computed.r\n\t\t\t\t\t}, anim.duration, anim.easing, bind(this, function() {\n\t\t\t\t\t\ts.WebkitTransform = ('scale(' + (this._computed.flipX ? obj.scale * -1 : obj.scale) +\n\t\t\t\t\t\t\t\t\t\t\t ',' + (this._computed.flipY ? obj.scale * -1 : obj.scale) + ') ' +\n\t\t\t\t\t\t\t\t\t\t\t 'rotate(' + obj.r + 'rad)');\n\t\t\t\t\t})).then(bind(this, function() {\n\t\t\t\t\t\ts.WebkitTransform = ('scale(' + (this._computed.flipX ? obj.scale * -1 : obj.scale) +\n\t\t\t\t\t\t\t\t\t\t\t ',' + (this._computed.flipY ? obj.scale * -1 : obj.scale) + ') '  +\n\t\t\t\t\t\t\t\t\t\t\t 'rotate(' + this._computed.r + 'rad)');\n\t\t\t\t\t}));\n\n\t\t\t\t} else if ((obj.scale != this._computed.scale) ||\n\t\t\t\t\t\t   (obj.r != this._computed.r)) {\n\t\t\t\t\t// logger.log('set transform', this._computed.scale, this._computed.r);\n\t\t\t\t\ts.WebkitTransform = ('scale(' + (this._computed.flipX ? this._computed.scale * -1 : this._computed.scale) +\n\t\t\t\t\t\t\t\t\t\t\t',' + (this._computed.flipY ? this._computed.scale * -1 : this._computed.scale) + ') ' +\n\t\t\t\t\t\t\t\t\t\t 'rotate(' + this._computed.r + 'rad)');\n\t\t\t\t}\n\t\t\t\t// use CSS animations for left and top though, since\n\t\t\t\t// those can still be taken out of javascript.\n\t\t\t\ts.left = (this._center ? -this.width / 2 | 0 : 0) + this._computed.x + 'px';\n\t\t\t\ts.top = (this._center ? -this.height / 2 | 0 : 0) + this._computed.y + 'px';\n\t\t\t} else {\n\t\t\t\tvar matrix = new WebKitCSSMatrix();\n\t\t\t\tmatrix = matrix.translate(\n\t\t\t\t\tthis._computed.x,\n\t\t\t\t\tthis._computed.y\n\t\t\t\t);\n\n\t\t\t\tmatrix = matrix.rotate(this._computed.r * 180 / 3.14159);\n\t\t\t\tmatrix = matrix.scale(this._computed.scale);\n\n\t\t\t\tif(this._computed.flipX || this._computed.flipY) {\n\t\t\t\t\tmatrix = matrix.translate(\n\t\t\t\t\t\tthis._computed.flipX ? -this._computed.width : 0,\n\t\t\t\t\t\tthis._computed.flipY ? this._computed.height / 2 : 0\n\t\t\t\t\t);\n\t\t\t\t\tmatrix = matrix.scale(\n\t\t\t\t\t\tthis._computed.flipX ? -1 : 1,\n\t\t\t\t\t\tthis._computed.flipY ? -1 : 1\n\t\t\t\t\t);\n\t\t\t\t\tmatrix = matrix.translate(\n\t\t\t\t\t\tthis._computed.flipX ? this._computed.width : 0,\n\t\t\t\t\t\tthis._computed.flipY ? -this._computed.height / 2 : 0\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\t// on iOS, forcing a 3D matrix provides huge performance gains.\n\t\t\t\t// Rotate it about the y axis 360 degrees to achieve this.\n\t\t\t\tmatrix = matrix.rotate(0, 360, 0);\n\t\t\t\ts.WebkitTransform = matrix;\n\t\t\t}\n\n\t\t}\n\t\tif (resized) {\n\t\t\tthis._onSizeChanged && this._onSizeChanged();\n\t\t}\n\n\t\treturn animCount;\n\t};\n\n\tthis._setCenter = function() {\n\t\tvar s = this._node.style;\n\t\tvar origin = {\n\t\t\tx: (!this._circle ? 0 : -(this.width / 2 | 0)),\n\t\t\ty: (!this._circle ? 0 : -(this.height / 2 | 0))\n\t\t};\n\t\tif (AVOID_CSS_ANIM) {\n\t\t\torigin.x += this._computed.x;\n\t\t\torigin.y += this._computed.y;\n\t\t}\n\t\ts.left = origin.x + 'px';\n\t\ts.top = origin.y + 'px';\n\t}\n\n\tthis._onSizeChanged = function() {\n\t\tthis._setCenter();\n\t\tthis._view.needsReflow();\n\t}\n\n\t// ----- zIndex -----\n\n\tvar LEN_Z = 8;\n\tvar MAX_Z = 99999999;\n\tvar MIN_Z = -99999999;\n\tvar PAD = \"00000000\";\n\n\tthis._sortIndex = \"00000000\";\n\n\tthis._onZIndex = function(zIndex) {\n\t\tzIndex = ~~zIndex;\n\n\t\tif (zIndex < MIN_Z) { zIndex = this._zIndex = MIN_Z; }\n\t\tif (zIndex > MAX_Z) { zIndex = this._zIndex = MAX_Z; }\n\t\tif (zIndex < 0) {\n\t\t\tzIndex *= -1;\n\t\t\tthis._sortIndex = '-' + PAD.substring(0, LEN_Z - ('' + zIndex).length) + zIndex;\n\t\t} else {\n\t\t\tthis._sortIndex = PAD.substring(0, LEN_Z - ('' + zIndex).length) + zIndex;\n\t\t}\n\n\t\tthis._setSortKey();\n\t}\n\n\tthis._setAddedAt = function(addedAt) {\n\t\tthis._addedAt = addedAt;\n\t\tthis._setSortKey();\n\t}\n\n\tthis._setSortKey = function() {\n\t\tthis.__sortKey = this._sortIndex + this._addedAt;\n\t}\n\n\t// ----- ANIMATION -----\n\n\tthis._transitionEnd = function (evt) {\n\t\t$.stopEvent(evt);\n\t\tif (this.transitionCallback.fired()) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.transitionCallback.fire();\n\t\tthis.transitionCallback.reset();\n\n\t\tif (evt) {\n\t\t\tevt.cancelBubble = true;\n\t\t} else if (this._transitionEndTimeout) {\n\t\t\tthis._transitionEndTimeout = null;\n\t\t}\n\n\t\tthis._node.style.webkitTransition = \"none\";\n\n\t\tthis._animating = false;\n\t\tif (this._animationCallback) {\n\t\t\tvar callback = this._animationCallback;\n\t\t\tthis._animationCallback = null;\n\t\t\tcallback();\n\t\t}\n\n\t\tthis._processAnimation();\n\t};\n\n\n\tthis._processAnimation = function (doNow) {\n\t\tif (this._animationQueue.length == 0 || this._isPaused) {\n\t\t\treturn;\n\t\t}\n\t\tif (doNow) {\n\t\t\t\tclearTimeout(this._queuedTimeout);\n\t\t\t\tthis._queuedTimeout = null;\n\t\t}\n\t\tif (this._queuedTimeout) {\n\t\t\treturn;\n\t\t}\n\t\tif (!doNow) {\n\t\t\tif (!this._queuedTimeout) {\n\t\t\t\tthis._queuedTimeout = setTimeout(bind(this, function() {\n\t\t\t\t\tthis._queuedTimeout = false;\n\t\t\t\t\tthis._processAnimation(true);\n\t\t\t\t}), 0);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tvar anim = this._animationQueue.shift();\n\t\tswitch (anim.type) {\n\t\tcase \"animate\":\n\t\t\tvar s = this._node.style;\n\t\t\tif (AVOID_CSS_ANIM) {\n\t\t\t\ts.webkitTransitionProperty = \"left, top, opacity, width, height\";\n\t\t\t} else {\n\t\t\t\ts.webkitTransitionProperty = \"-webkit-transform, opacity, width, height\";\n\t\t\t}\n\t\t\ts.webkitTransitionDuration = (anim.duration|0) + \"ms\";\n\t\t\ts.webkitTransitionTimingFunction = getEasing(anim.easing);\n\t\t\tthis._setProps(anim.props, anim);\n\n\t\t\t// fall through\n\t\tcase \"wait\":\n\t\t\tthis._animating = true;\n\t\t\tthis._animationCallback = anim.callback || null;\n\n\t\t\tthis.transitionCallback = new Callback();\n\n\t\t\tthis.transitionCallback.runOrTimeout(function() {\n\t\t\t\t// if webkitTransitionEnd fires, do nothing\n\t\t\t}, bind(this, function(evt) {\n\t\t\t\t// webkitTransitionEnd is too late, baby, it's too late\n\t\t\t\tthis._transitionEnd(evt);\n\t\t\t}), anim.duration);\n\t\t\tbreak;\n\t\tcase \"callback\":\n\t\t\t//logger.log('doing callback', anim.callback, doNow);\n\t\t\tanim.callback();\n\t\t\tif (!this._animating) {\n\t\t\t\tthis._processAnimation();\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t};\n\n\tthis.getQueue = function() {\n\t\treturn [];\n\t}\n\tthis.getAnimation = function() {\n\t\treturn this;\n\t}\n\n\tthis.animate = function() {\n\t\tif (!arguments[0]) {\n\t\t\treturn this;\n\t\t}\n\t\treturn this.next.apply(this, arguments);\n\t}\n\n\tthis.clear = function() {\n\t\tthis.transitionCallback && this.transitionCallback.fire();\n\t\tif (this._transitionEndTimeout) {\n\t\t\tclearTimeout(this._transitionEndTimeout);\n\t\t}\n\t\tthis._animationQueue = [];\n\t\tthis._animationCallback = null;\n\t\tthis._animating = false;\n\t\treturn this;\n\t};\n\n\tthis.finishNow = function() {\n\t\tthis._node.style.webkitTransition = 'none';\n\t\t// TODO: this isn't really right; you need to actually finish the queue\n\n\t\treturn this;\n\t}\n\n\tvar DURATION = 600;\n\n\tthis.pause = function() {\n\t\tthis._isPaused = true;\n\t}\n\n\tthis.resume = function() {\n\t\tthis._isPaused = false;\n\t\tthis._processAnimation();\n\t}\n\n\tthis.animate = function (props, duration, easing, callback) {\n\t\t//this.clear();\n\t\treturn this.then(props, duration, easing, callback);\n\t};\n\n\tthis.now = function (props, duration, easing, callback) {\n\t\tthis.clear();\n\t\treturn this.then(props, duration, easing, callback);\n\t}\n\n\tthis.then = function (props, duration, easing, callback) {\n\t\tif (arguments.length == 1 && typeof props === 'function') {\n\t\t\treturn this.callback(props);\n\t\t}\n\t\tthis._animationQueue.push({\n\t\t\ttype: \"animate\",\n\t\t\tprops: props,\n\t\t\tduration: duration || DURATION,\n\t\t\tcallback: callback && bind(this, callback),\n\t\t\teasing: easing\n\t\t});\n\t\tif (this._animationQueue.length == 1 && !this._animating) {\n\t\t\tthis._processAnimation();\n\t\t}\n\t\treturn this;\n\t};\n\n\tthis.callback = function(fn) {\n\t\tthis._animationQueue.push({\n\t\t\ttype: \"callback\",\n\t\t\tduration: 0,\n\t\t\tcallback: fn && bind(this, fn)\n\t\t});\n\t\tif (this._animationQueue.length == 1 && !this._animating) {\n\t\t\tthis._processAnimation();\n\t\t}\n\t\treturn this;\n\t}\n\n\tthis.wait = function (duration, callback) {\n\t\tthis._animationQueue.push({\n\t\t\ttype: \"wait\",\n\t\t\tduration: duration,\n\t\t\tcallback: callback\n\t\t});\n\t\tif (this._animationQueue.length == 1 && !this._animating) {\n\t\t\tthis._processAnimation();\n\t\t}\n\t\treturn this;\n\t};\n\n\tthis.fadeIn = function (duration, callback) {\n\t\tthis.show();\n\n\t\tif (this._node.style.opacity == 1) {\n\t\t\tif (callback) {\n\t\t\t\tcallback();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tthis.then({\n\t\t\topacity: 1\n\t\t}, duration, null, callback);\n\t\treturn this;\n\t};\n\n\tthis.fadeOut = function (duration, callback) {\n\t\tif (this._node.style.opacity == 0) {\n\t\t\tthis.hide();\n\t\t\tif (callback) {\n\t\t\t\tcallback();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tthis.then({\n\t\t\topacity: 0\n\t\t}, duration, null, bind(this, function () {\n\t\t\tthis.hide();\n\t\t\tif (callback) {\n\t\t\t\tcallback();\n\t\t\t}\n\t\t}));\n\n\t\treturn this;\n\t};\n\n});\n\n","pre":true},"../../../../sdk/timestep/ui/backend/canvas/ImageView.js":{"path":"../../../../sdk/timestep/ui/backend/canvas/ImageView.js","friendlyPath":".backend.canvas.ImageView","directory":"../../../../sdk/timestep/ui/backend/canvas/","filename":"ImageView.js","src":"/**\n * package ui.backend.canvas.ImageView;\n *\n * canvas.ImageView implementation.\n */\n\njsio(\"import util.path\");\njsio(\"import std.uri as URI\");\n\njsio(\"import ui.View as View\")\njsio(\"import ui.resource.Image as Image\");\n\n/**\n * @extends ui.View\n */\nvar sdk_timestep_ui_backend_canvas_ImageView=__class__;var ImageView = exports=sdk_timestep_ui_backend_canvas_ImageView(function sdk_timestep_ui_backend_canvas_ImageView(){return this.init&&this.init.apply(this,arguments)},View, function(supr) {\n\n\t/** \n\t * Options:\n\t *   autoSize - See .setImage()\n\t */\n\n\tthis.init = function(opts) {\n\t\tsupr(this, 'init', arguments);\n\t\topts = merge(opts, {\n\t\t\timage: null,\n\t\t\tautoSize: false\n\t\t});\n\t\t\n\t\tif (opts.image) {\n\t\t\tthis.setImage(opts.image, opts);\n\t\t}\n\t};\n\n\t/**\n\t * Return this view's Image object.\n\t */\n\n\tthis.getImage = function() {\n\t\treturn this._img;\n\t};\n\n\t/**\n\t * Set the image of the view from an Image object or string.\n\t * Options:\n\t *   autoSize - Automatically set view size from image dimensions.\n\t */\n\n\tthis.setImage = function(img, opts) {\n\t\tif (typeof img == 'string') {\n\t\t\tthis._img = new Image({url: img});\n\t\t} else {\n\t\t\tthis._img = img;\n\t\t}\n\n\t\tif (this._img) {\n\t\t\tif (opts && opts.autoSize) {\n\t\t\t\tthis._img.doOnLoad(this, 'autoSize');\n\t\t\t}\n\t\t\tthis._img.doOnLoad(this, 'needsRepaint');\n\t\t}\n\t};\n\n\t/**\n\t * Pass a function to load once the Image object is loaded, or a list of\n\t * arguments that call lib.Callback::run() implicitly.\n\t */\n\t\n\tthis.doOnLoad = function() {\n\t\tif (arguments.length == 1) {\n\t\t\tthis._img.doOnLoad(this, arguments[0]);\n\t\t} else {\n\t\t\tthis._img.doOnLoad.apply(this._img, arguments);\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t * Automatically resize the view to the size of the image.\n\t */\n\t\n\tthis.autoSize = function() {\n\t\tif (this._img) {\n\t\t\tthis.style.width = this._img.getWidth();\n\t\t\tthis.style.height = this._img.getHeight();\n\n\t\t\tif (this.style.fixedAspectRatio) {\n\t\t\t\tthis.style.updateAspectRatio();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get original width of the Image object.\n\t */\n\t\n\tthis.getOrigWidth = this.getOrigW = function () {\n\t\treturn this._img.getOrigW();\n\t};\n\n\t/**\n\t * Get original height of the Image object.\n\t */\n\n\tthis.getOrigHeight = this.getOrigH = function () {\n\t\treturn this._img.getOrigH();\n\t};\n\n\t/**\n\t * Render this image onto a canvas.\n\t */\n\n\tthis.render = function(ctx) {\n\t\tif (!this._img) { return; }\n\n\t\tvar s = this.style;\n\t\tvar w = s.width;\n\t\tvar h = s.height;\n\t\tthis._img.render(ctx, 0, 0, w, h);\n\t}\n\n\t/**\n\t * Return a human-readable tag for this view.\n\t */\n\n\tvar _loc = window.location.toString();\n\tvar _host = window.location.hostname;\n\t\n\tthis.getTag = function() {\n\t\tvar tag;\n\t\tif (this._img) {\n\t\t\tvar url = this._img.getOriginalURL();\n\t\t\tif (this._cachedTag && url == this._cachedTag.url) {\n\t\t\t\ttag = this._cachedTag.tag;\n\t\t\t} else {\n\t\t\t\tvar uri = URI.relativeTo(url, _loc);\n\t\t\t\tvar host = uri.getHost();\n\t\t\t\ttag = util.path.splitExt(uri.getFile()).basename + (host && host != _host ? ':' + host : '');\n\n\t\t\t\tthis._cachedTag = {\n\t\t\t\t\turl: url,\n\t\t\t\t\ttag: tag\n\t\t\t\t};\n\t\t\t}\n\t\t};\n\n\t\treturn (tag || '') + ':ImageView' + this.uid;\n\t}\n});\n\n","pre":true},"../../../../sdk/timestep/ui/backend/canvas/TextView.js":{"path":"../../../../sdk/timestep/ui/backend/canvas/TextView.js","friendlyPath":".backend.canvas.TextView","directory":"../../../../sdk/timestep/ui/backend/canvas/","filename":"TextView.js","src":"/**\n * package ui.backend.canvas.TextView;\n *\n * canvas.TextView implementation.\n */\n\njsio(\"import ui.layout.LinearView as LinearView\");\njsio(\"import device\");\njsio(\"import .util.FragmentBuffer as FragmentBuffer\");\njsio(\"import .TextFlow\");\n\nvar sdk_timestep_ui_backend_canvas_TextView=__class__;var TextView = exports=sdk_timestep_ui_backend_canvas_TextView(function sdk_timestep_ui_backend_canvas_TextView(){return this.init&&this.init.apply(this,arguments)},LinearView, function (supr) {\n\n\tvar defaults = {\n\t\t// layout properties...\n\t\twrap: false,\n\t\tautoSize: false,\n\t\tautoFontSize: true,\n\t\tverticalPadding: 0,\n\t\thorizontalPadding: 0,\n\t\tlineHeight: 1.2,\n\n\t\t// font properties...\n\t\tcolor: \"#000000\",\n\t\tfontFamily: device.defaultFontFamily,\n\t\tfontWeight: \"\",\n\t\tsize: 12,\n\t\tlineWidth: 2,\n\t\toutlineColor: null,\n\t\tshadowColor: null,\n\n\t\t// alignment properties...\n\t\tverticalAlign: \"middle\",\n\t\thorizontalAlign: \"center\",\n\n\t\t// misc properties...\n\t\tbackgroundColor: null\n\t};\n\n\tvar clearCache = {\n\t\t// basic widget properties...\n\t\twidth: true,\n\t\theight: true,\n\n\t\t// layout properties...\n\t\twrap: true,\n\t\tautoSize: true,\n\t\tautoFontSize: true,\n\t\tverticalPadding: true,\n\t\thorizontalPadding: true,\n\t\tlineHeight: true,\n\n\t\t// font properties...\n\t\tcolor: false,\n\t\tfontFamily: true,\n\t\tfontWeight: true,\n\t\tsize: true,\n\t\tlineWidth: false,\n\t\toutlineColor: false,\n\t\tshadowColor: false,\n\n\t\t// alignment properties...\n\t\tverticalAlign: true,\n\t\thorizontalAlign: true,\n\n\t\t// misc properties...\n\t\tbackgroundColor: false,\n\t\ttext: true\n\t};\n\tvar clearCacheKeys = Object.keys(clearCache);\n\n\tvar savedOpts = [\n\t\t\"width\",\n\t\t\"height\",\n\t\t\"size\"\n\t];\n\n\tvar fontBuffer = new FragmentBuffer();\n\n\tfontBuffer.onGetHash = function (desc) {\n\t\tif (!desc.hash) {\n\t\t\tvar i = clearCacheKeys.length;\n\t\t\tdesc.hash = \"\";\n\t\t\twhile (i) {\n\t\t\t\tdesc.hash += desc[clearCacheKeys[--i]] || \"\";\n\t\t\t}\n\t\t}\n\t\treturn desc.hash;\n\t};\n\n\tthis.init = function (opts) {\n\t\tthis._opts = {};\n\t\tthis._optsLast = {};\n\t\tthis._cacheUpdate = true;\n\n\t\tthis._textFlow = new TextFlow({target: this});\n\t\tthis._textFlow.subscribe(\"ChangeWidth\", this, \"onChangeWidth\");\n\t\tthis._textFlow.subscribe(\"ChangeHeight\", this, \"onChangeHeight\");\n\t\tthis._textFlow.subscribe(\"ChangeSize\", this, \"onChangeSize\");\n\n\t\tsupr(this, 'init', [merge(opts, defaults)]);\n\t};\n\n\tthis.onChangeWidth = function (width) {\n\t\tthis.updateOpts({width: width}, true);\n\t};\n\n\tthis.onChangeHeight = function (height) {\n\t\tthis.updateOpts({height: height}, true);\n\t};\n\n\tthis.onChangeSize = function (size, ctx) {\n\t\tthis.updateOpts({size: size}, true);\n\t\tif (ctx) {\n\t\t\tctx.font = this._opts.fontWeight + \" \" + this._opts.size + \"px \" + this._opts.fontFamily;\n\t\t}\n\t};\n\n\t// These options might have been changed to make the text fit, restore them...\n\tthis._restoreOpts = function () {\n\t\tvar optsLast = this._optsLast;\n\t\tvar optsKey;\n\t\tvar i = savedOpts.length;\n\t\twhile (i) {\n\t\t\toptsKey = savedOpts[--i];\n\t\t\tif (optsKey in optsLast) {\n\t\t\t\tthis._opts[optsKey] = optsLast[optsKey];\n\t\t\t}\n\t\t}\n\t};\n\n\t// Check if the cache should be updated...\n\tthis._checkOpts = function (opts) {\n\t\tvar optsLast = this._optsLast;\n\t\tvar optsKey;\n\t\tvar i = clearCacheKeys.length;\n\n\t\tthis._cacheUpdate = !Object.keys(this._opts).length;\n\t\twhile (i) {\n\t\t\toptsKey = clearCacheKeys[--i];\n\t\t\tif ((optsKey in opts) && clearCache[optsKey] && (optsLast[optsKey] !== opts[optsKey])) {\n\t\t\t\tthis._cacheUpdate = true;\n\t\t\t}\n\t\t\tif (optsKey in opts) {\n\t\t\t\toptsLast[optsKey] = opts[optsKey];\n\t\t\t} else if (optsKey in this._opts) {\n\t\t\t\toptsLast[optsKey] = this._opts[optsKey];\n\t\t\t} else {\n\t\t\t\toptsLast[optsKey] = defaults[optsKey];\n\t\t\t}\n\t\t}\n\t};\n\n\tthis._checkDeprecatedOpts = function (opts) {\n\t\tif (\"multiline\" in opts) {\n\t\t\tconsole.warn(\"TextView opts.multiline is deprecated, please use wrap...\");\n\t\t\topts.wrap = opts.multiline;\n\t\t}\n\t\tvar font = opts.font;\n\t\tif (font) {\n\t\t\tconsole.warn(\"TextView opts.font is deprecated, please use fontFamily and size...\");\n\t\t\twhile (font.length && (font[0] === ' ')) {\n\t\t\t\tfont = font.substr(1 - font.length);\n\t\t\t}\n\t\t\tvar i = font.indexOf(' ');\n\t\t\tif (i !== -1) {\n\t\t\t\topts.size = parseInt(font.substr(0, i).replace(/[pxtem\\s]/gi, ''), 10);\n\t\t\t\topts.fontFamily = font.substr(i + 1 - font.length);\n\t\t\t}\n\t\t}\n\t};\n\n\tthis.updateOpts = function (opts, dontCheck) {\n\t\tthis._checkDeprecatedOpts(opts);\n\n\t\tif (!dontCheck) {\n\t\t\tthis._restoreOpts();\n\t\t\tthis._checkOpts(opts);\n\t\t\tif (this._cacheUpdate) {\n\t\t\t\topts.hash = false;\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\topts = supr(this, 'updateOpts', arguments);\n\t\t(\"text\" in opts) && this.setText(opts.text);\n\t\t!dontCheck && this._textFlow.setOpts(this._opts);\n\n\t\treturn opts;\n\t};\n\n\tthis._updateCtx = function (ctx) {\n\t\tvar opts = this._opts;\n\n\t\tctx.textBaseline = \"top\";\n\t\tctx.fillStyle = opts.color;\n\t\tctx.font = opts.fontWeight + \" \" + opts.size + \"px \" + opts.fontFamily;\n\t\tctx.lineWidth = opts.lineWidth;\n\t};\n\n\tthis._renderToCtx = function (ctx, offsetX, offsetY) {\n\t\tvar opts = this._opts;\n\t\tvar cache = this._textFlow.getCache();\n\t\tvar maxWidth = opts.autoFontSize ? this._textFlow.getActualWidth() : 1000000;\n\t\tvar item;\n\t\tvar word;\n\t\tvar color = opts.color;\n\t\tvar strokeColor = opts.strokeStyle;\n\t\tvar outlineColor = opts.outlineColor;\n\t\tvar shadowColor = opts.shadowColor;\n\t\tvar lineOffset = opts.lineWidth / 2;\n\t\tvar x, y;\n\t\tvar i = cache.length;\n\n\t\tthis._updateCtx(ctx);\n\n\t\tif (strokeColor) {\n\t\t\tctx.strokeStyle = strokeColor;\n\t\t}\n\n\t\twhile (i) {\n\t\t\titem = cache[--i];\n\t\t\tword = item.word;\n\t\t\tx = offsetX + item.x;\n\t\t\ty = offsetY + item.y;\n\n\t\t\tif (strokeColor) {\n\t\t\t\tctx.strokeText(word, x, y, maxWidth);\n\t\t\t}\n\t\t\tif (outlineColor) {\n\t\t\t\tctx.fillStyle = outlineColor;\n\t\t\t\tctx.fillText(word, x - lineOffset, y, maxWidth);\n\t\t\t\tctx.fillText(word, x + lineOffset, y, maxWidth);\n\t\t\t\tctx.fillText(word, x, y - lineOffset, maxWidth);\n\t\t\t\tctx.fillText(word, x, y + lineOffset, maxWidth);\n\t\t\t}\n\t\t\tif (shadowColor) {\n\t\t\t\tctx.fillStyle = shadowColor;\n\t\t\t\tctx.fillText(word, x + lineOffset, y + lineOffset, maxWidth);\n\t\t\t}\n\t\t\tctx.fillStyle = color;\n\t\t\tctx.fillText(word, x, y, maxWidth);\n\t\t}\n\t};\n\n\tthis._renderBuffer = function (ctx) {\n\t\tvar opts = this._opts;\n\t\tvar fonctBufferCtx = fontBuffer.getContext();\n\t\tvar offsetRect = this._textFlow.getOffsetRect();\n\t\tvar width = offsetRect.width;\n\t\tvar height = offsetRect.height;\n\t\tvar cache = this._textFlow.getCache();\n\t\tvar desc;\n\n\t\topts.lineCount = cache[cache.length - 1].line;\n\t\tdesc = fontBuffer.getPositionForText(opts);\n\t\tif (desc != null) {\n\t\t\tthis._cacheUpdate && this._renderToCtx(fonctBufferCtx, desc.x - offsetRect.x, desc.y - offsetRect.y);\n\t\t\tctx.drawImage(fontBuffer.getCanvas(), desc.x, desc.y, width, height, offsetRect.x, offsetRect.y, width, height);\n\t\t} else {\n\t\t\tthis._opts.buffered = false;\n\t\t}\n\t};\n\n\tthis.render = function (ctx) {\n\t\tvar opts = this._opts;\n\n\t\tif (this._cacheUpdate) {\n\t\t\tthis._updateCtx(ctx);\n\t\t\tthis._textFlow.reflow(ctx, 1 + (opts.autoFontSize ? 4 : 0) + (opts.autoSize ? 2 : 0) + (opts.wrap ? 1 : 0));\n\t\t}\n\t\tif (!this._textFlow.getCache().length) {\n\t\t\tthis._cacheUpdate = false;\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._opts.buffer && (fontBuffer !== null)) {\n\t\t\tthis._renderBuffer(ctx);\n\t\t} else {\n\t\t\tthis._renderToCtx(ctx, 0, 0);\n\t\t}\n\n\t\tthis._cacheUpdate = false;\n\t};\n\n\tthis.clearBuffers = function() {\n\t\tvar ctx;\n\n\t\tif (fontBuffer !== null) {\n\t\t\tctx = fontBuffer.getContext();\n\t\t\tctx.clear();\n\t\t\tctx.globalCompositeOperation = \"source-over\";\n\n\t\t\tfontBuffer.clearBuffer();\n\t\t}\n\t};\n\n\tthis.getFontBuffer = function() {\n\t\treturn fontBuffer;\n\t};\n\n\tthis.setText = function (text) {\n\t\tthis._opts.text = text ? text.toString() : '';\n\t\tthis._cacheUpdate = true;\n\t\tthis.needsRepaint();\n\t};\n\n\tthis.getText = function () {\n\t\treturn this._opts.text;\n\t};\n\n\tthis.getTag = function() {\n\t\treturn \"TextView\" + this.uid + \":\" + (this._lines && this._lines.join(\" \").substring(0, 20));\n\t};\n\n\tthis.reflow = function () {\n\t\tthis._restoreOpts();\n\t\tthis._cacheUpdate = true;\n\t};\n});\n\nexports.clearBuffers = TextView.prototype.clearBuffers;\nexports.getFontBuffer = TextView.prototype.getFontBuffer;","pre":true},"../../../../sdk/timestep/ui/backend/canvas/util/FragmentBuffer.js":{"path":"../../../../sdk/timestep/ui/backend/canvas/util/FragmentBuffer.js","friendlyPath":".util.FragmentBuffer","directory":"../../../../sdk/timestep/ui/backend/canvas/util/","filename":"FragmentBuffer.js","src":"jsio(\"import device\");\njsio(\"import .FragmentBin\");\njsio(\"import .SortedLinkedList as SortedList\");\n\nvar sdk_timestep_ui_backend_canvas_util_FragmentBuffer=__class__;var FragmentBuffer = exports=sdk_timestep_ui_backend_canvas_util_FragmentBuffer(function sdk_timestep_ui_backend_canvas_util_FragmentBuffer(){return this.init&&this.init.apply(this,arguments)},function () {\n\tvar debug = false;\n\tthis.init = function (opts) {\n\t\tthis.opts = merge(opts, {});\n\t};\n\n\tvar sort = function (a, b) {\n\t\treturn a.size() > b.size();\n\t};\n\n\tthis._build = function () {\n\t    var Canvas = device.get('Canvas');\n        this._canvas = new Canvas({width: 1024, height: 1024});\n        this._ctx = this.getCanvas().getContext('2d');\n\t\tthis._ctx.clearRect(0, 0, 1024, 1024);\n\t\tthis._ctx.textAlign = 'left';\n\t\tthis._ctx.textBaseline = 'middle';\n\t\tthis._ctx.globalCompositeOperation = 'source-over';\n\t\tthis._cache = {};\n\t\tthis._binList = new SortedList(sort);\n\t\tvar head = new FragmentBin({\n\t\t\tx: 0,\n\t\t\ty: 0,\n\t\t\twidth: 1024,\n\t\t\theight: 1024\n\t\t});\n\t\tthis._binList.insert(head);\n\t};\n\n\tthis.getCanvas = function () {\n\t\tif (!this._canvas) {\n\t\t\tthis._build();\n\t\t}\n\t\treturn this._canvas;\n\t};\n\n\tthis.getContext = function () {\n\t\tif (!this._ctx) {\n\t\t\tthis._build();\n\t\t}\n\t\treturn this._ctx;\n\t};\n\n\tthis.onGetHash = function (desc) {\n\t\tthrow Error(\"onGetHash should be implemented.\");\n\t};\n\n\tvar randomColor = function () {\n\t\tvar color = 'rgba(' +\n\t\t\t\t\t(Math.random()*255).toFixed() + ',' +\n\t\t\t\t\t(Math.random()*255).toFixed() + ',' +\n\t\t\t\t\t(Math.random()*255).toFixed() + ',' +\n\t\t\t\t\t'0.3)';\n\t\treturn color;\n\t};\n\n\tthis._insertText = function (desc) {\n\t\tvar width = desc.width;\n\t\tvar height = desc.height;\n\t\tvar iter = this._binList.iterator();\n\t\tvar bin = null;\n\t\tvar found = false;\n\t\twhile (iter.hasNext() && !found) {\n\t\t\tbin = iter.next();\n\t\t\tif (!bin.filled && bin.width >= width && bin.height >= height) {\n\t\t\t\tfound = true;\n\t\t\t} else {\n\t\t\t\t//we don't want to insert in filled bins\n\t\t\t\tbin = null;\n\t\t\t}\n\t\t}\n\t\tif (bin) {\n\t\t\tnewBins = bin.split(width, height);\n\t\t\tfor (var i = 0; i < newBins.length; i++) {\n\t\t\t\tthis._binList.insert(newBins[i]);\n\t\t\t}\n\t\t\tif (debug) {\n\t\t\t\t/*\n\t\t\t\t* If we're debugging, fill each bin with a different color\n\t\t\t\t* so we can see where they are.\n\t\t\t\t*/\n\t\t\t\tthis._ctx.fillStyle = randomColor();\n\t\t\t\tthis._ctx.fillRect(bin.x, bin.y, bin.width, bin.height);\n\t\t\t}\n\t\t} else {\n\t\t\tlogger.log('buffer full, further TextViews will not be cached');\n\t\t}\n\t\treturn bin;\n\t};\n\n\t/**\n\t* debugging code to verify overlapping bins aren't created.\n\t*/\n\tvar rectIntersectsRect = function (r1, r2) {\n\t\tvar ax1 = r1.x;\n\t\tvar ax2 = r1.x + r1.width;\n\t\tvar ay1 = r1.y;\n\t\tvar ay2 = r1.y + r1.height;\n\t\tvar bx1 = r2.x;\n\t\tvar bx2 = r2.x + r2.width;\n\t\tvar by1 = r2.y;\n\t\tvar by2 = r2.y + r2.height;\n\t\treturn ax1 < bx2 && ax2 > bx1 && ay1 < by2 && ay2 > by1;\n\t};\n\n\tvar debugCheck = function (bin, list) {\n\t\tif (!bin) { return;}\n\t\tvar iter = list.iterator();\n\t\tvar ok = true;\n\t\twhile (iter.hasNext() && ok) {\n\t\t\tvar next = iter.next();\n\t\t\tok = next == bin || !rectIntersectsRect(next, bin);\n\t\t\tif (!ok) {\n\t\t\t\tlogger.error('rect overlaps');\n\t\t\t\tlogger.error(iter.current(), bin);\n\t\t\t}\n\t\t}\n\t};\n\n\tthis.getPositionForText = function (desc) {\n\t\tvar hash = this.onGetHash(desc);\n\n\t\tif (!this._cache[hash] && desc.width > 0) {\n\t\t\tthis._cache[hash] = this._insertText(desc);\n\t\t}\n\t\tif (debug && false) {\n\t\t\tdebugCheck(desc, this._binHead);\n\t\t}\n\t\treturn this._cache[hash];\n\t};\n\n\tthis.clearBuffer = function () {\n\t\tthis._cache = {};\n\t\tthis._binList = new SortedList(sort);\n\t\tthis._binList.insert(new FragmentBin({\n\t\t\tx: 0,\n\t\t\ty: 0,\n\t\t\twidth: 1024,\n\t\t\theight: 1024\n\t\t}));\n\t};\n});","pre":true},"../../../../sdk/timestep/ui/backend/canvas/util/FragmentBin.js":{"path":"../../../../sdk/timestep/ui/backend/canvas/util/FragmentBin.js","friendlyPath":".FragmentBin","directory":"../../../../sdk/timestep/ui/backend/canvas/util/","filename":"FragmentBin.js","src":"/**\n * TextBins are used in the FragmentBuffer caching of TextViews.\n **/\nvar sdk_timestep_ui_backend_canvas_util_FragmentBin=__class__;var FragmentBin = exports=sdk_timestep_ui_backend_canvas_util_FragmentBin(function sdk_timestep_ui_backend_canvas_util_FragmentBin(){return this.init&&this.init.apply(this,arguments)},'TextBin', function(logger, supr) {\n\tthis.init = function(opts) {\n\t\tthis.width = opts.width;\n\t\tthis.height = opts.height;\n\t\tthis.x = opts.x;\n\t\tthis.y = opts.y;\n\t};\n\n\tthis.size = function() {\n\t\treturn this.width * this.height;\n\t};\n\n\tthis.split = function(x, y) {\n\t\tvar newBins = [this];\n\t\tif (this.width > 10 && this.height > 10) {\n\t\t\tif (this.height - y > 10) {\n\t\t\t\tvar bin1 = new FragmentBin({\n\t\t\t\t\tx: this.x,\n\t\t\t\t\ty: this.y + y,\n\t\t\t\t\twidth: this.width,\n\t\t\t\t\theight: this.height - y\n\t\t\t\t});\n\t\t\t\tnewBins.push(bin1);\n\t\t\t}\n\t\t\tif (this.width -x > 10) {\n\t\t\t\tvar bin2 = new FragmentBin({\n\t\t\t\t\tx: this.x + x,\n\t\t\t\t\ty: this.y,\n\t\t\t\t\twidth: this.width - x,\n\t\t\t\t\theight: y\n\t\t\t\t});\n\t\t\t\tnewBins.push(bin2);\n\t\t\t}\n\t\t}\n\t\tthis.width = x;\n\t\tthis.height = y;\n\t\tthis.filled = true;\n\n\t\treturn newBins;\n\t};\n});","pre":true},"../../../../sdk/timestep/ui/backend/canvas/util/SortedLinkedList.js":{"path":"../../../../sdk/timestep/ui/backend/canvas/util/SortedLinkedList.js","friendlyPath":".SortedLinkedList","directory":"../../../../sdk/timestep/ui/backend/canvas/util/","filename":"SortedLinkedList.js","src":"Iterator=__class__;var Iterator=Iterator(function Iterator(){return this.init&&this.init.apply(this,arguments)},'Iterator', function(logger, supr) {\n\tthis.init = this.update = function(list) {\n\t\tthis._list = list || this._list;\n\t\tthis._current = list.head;\n\t\tthis._count = 0;\n\t};\n\n\tthis.next = function() {\n\t\tvar data = this._current.data;\n\t\tthis._current = this._current.next;\n\t\tthis._count++;\n\t\treturn data;\n\t};\n\n\tthis.current = function() {\n\t\treturn this._current.data;\n\t};\n\n\tthis.insertBefore = function(data) {\n\t\tthis._current.insertBefore(data);\t\n\t\tthis._list.count++;\n\t};\n\n\tthis.insertAfter = function(data) {\n\t\tthis._current.insertAfter(data);\t\n\t\tthis._list.count++;\n\t};\n\n\tthis.remove = function() {\n\t\tthis._current.prev.remove();\n\t\tif (this._current.prev == this._current) {\n\t\t\tthis._list.head = null;\n\t\t}\n\t\tthis._list.count--;\n\t};\n\n\tthis.hasNext = function() {\n\t\treturn this._count < this._list.count;\n\t};\n\n\tthis.atHead = function() {\n\t\treturn this._current == this._list.head;\n\t};\n});\n\nItem=__class__;var Item=Item(function Item(){return this.init&&this.init.apply(this,arguments)},'Item', function(logger, supr) {\n\tthis.init = function(data, prev, next) {\n\t\tthis.data = data;\n\t\tthis.prev = prev || this; \n\t\tthis.next = next || this;\n\t};\n\n\tthis.insertBefore = function(data) {\n\t\tvar item = new Item(data, this.prev, this);\n\t\tthis.prev.next = item;\n\t\tthis.prev = item;\n\t};\n\t\n\tthis.insertAfter = function(data) {\n\t\tvar item = new Item(data, this, this.next);\n\t\tthis.next.prev = item;\n\t\tthis.next = item;\n\t};\n\n\tthis.remove = function() {\n\t\tthis.prev.next = this.next;\n\t\tthis.next.prev = this.prev;\n\t};\n});\n\nvar sdk_timestep_ui_backend_canvas_util_SortedLinkedList=__class__;exports=sdk_timestep_ui_backend_canvas_util_SortedLinkedList(function sdk_timestep_ui_backend_canvas_util_SortedLinkedList(){return this.init&&this.init.apply(this,arguments)},'SortedLinkedList', function(logger, supr) {\n\tthis.init = function(comparator) {\n\t\tthis.head = null;\n\t\tthis._comparator = comparator;\n\t\tthis.count = 0;\n\t};\n\n\tthis.append = function(data) {\n\t\tthis._head.insertAfter(data);\n\t\tthis.count++;\n\t};\n\n\tthis.insert = function(data) {\n\t\tif (!this.head) {\n\t\t\tthis.head = new Item(data);\n\t\t\tthis.count++;\n\t\t} else {\n\t\t\tvar i = this.iterator();\n\t\t\tvar d = i.current();\t\n\t\t\tvar found = false;\n\t\t\twhile (i.hasNext() && !found) {\n\t\t\t\tfound = !this._comparator(data, d);\n\t\t\t\tif (!found) {\n\t\t\t\t\ti.next();\t\n\t\t\t\t\td = i.current();\n\t\t\t\t}\n\t\t\t}\n\t\t\ti.insertBefore(data);\n\t\t\tif (found && i.atHead()) {\n\t\t\t\tthis.head = this.head.prev;\t\n\t\t\t}\n\t\t}\n\t};\n\n\tthis.iterator = function() {\n\t\treturn new Iterator(this);\n\t};\n});\n","pre":true},"../../../../sdk/timestep/ui/backend/canvas/TextFlow.js":{"path":"../../../../sdk/timestep/ui/backend/canvas/TextFlow.js","friendlyPath":".TextFlow","directory":"../../../../sdk/timestep/ui/backend/canvas/","filename":"TextFlow.js","src":"jsio(\"import lib.Enum as Enum\");\njsio(\"import lib.PubSub as PubSub\");\n\nvar textFlowMode = Enum(\n\t\"NONE\",\n\t\"WRAP\",\n\t\"AUTOSIZE\",\n\t\"AUTOSIZE_WRAP\",\n\t\"AUTOFONTSIZE\",\n\t\"AUTOFONTSIZE_WRAP\",\n\t\"AUTOFONTSIZE_AUTOSIZE\",\n\t\"AUTOFONTSIZE_WRAP_AUTOSIZE\"\n);\n\nvar sdk_timestep_ui_backend_canvas_TextFlow=__class__;var TextFlow = exports=sdk_timestep_ui_backend_canvas_TextFlow(function sdk_timestep_ui_backend_canvas_TextFlow(){return this.init&&this.init.apply(this,arguments)},PubSub, function (supr) {\n\tthis.init = function (opts) {\n\t\tsupr(this, \"init\", arguments);\n\n\t\tthis._target = opts.target;\n\t\tthis._lineWidth = 0;\n\t\tthis._line = [];\n\t\tthis._lines = [];\n\n\t\tthis._cache = [];\n\t\tthis._cacheSize = 0;\n\n\t\tthis._maxWordWidth = 0;\n\t\tthis._maxWidth = 0;\n\t\tthis._maxHeight = 0;\n\n\t\tthis._heightFound = -1;\n\n\t\tthis._offsetRect = {x: 0, y: 0, width: 0, height: 0};\n\t};\n\n\t// Split the text into a list containing the word and the width of the word...\n\tthis._lineSplit = function (ctx) {\n\t\tvar text = this._opts.text || \"\";\n\t\tvar words = text.replace(/\\t/g, \" \").match(/\\S+|[\\n]| +(?= )/g) || [];\n\t\tvar word;\n\t\tvar currentWord = 0;\n\t\tvar wordCount = words.length;\n\n\t\tthis._line = [];\n\t\tthis._lineWidth = 0;\n\t\tthis._maxWordWidth = 0;\n\n\t\twhile (currentWord < wordCount) {\n\t\t\tword = {word: words[currentWord], width: ctx.measureText(words[currentWord]).width, line: 1};\n\t\t\tthis._line.push(word);\n\t\t\tthis._lineWidth += word.width + this._spaceWidth;\n\t\t\tthis._maxWordWidth = Math.max(this._maxWordWidth, word.width);\n\t\t\tcurrentWord++;\n\t\t}\n\t\tthis._lineWidth -= this._spaceWidth;\n\t};\n\n\tthis._measureWords = function (ctx) {\n\t\tvar currentWord = 0;\n\t\tvar wordCount = this._line.length;\n\n\t\tthis._lineWidth = 0;\n\t\tthis._maxWordWidth = 0;\n\n\t\twhile (currentWord < wordCount) {\n\t\t\tword = this._line[currentWord];\n\t\t\tword.line = 1;\n\t\t\tword.width = ctx.measureText(word.word).width;\n\t\t\tthis._lineWidth += word.width + this._spaceWidth;\n\t\t\tthis._maxWordWidth = Math.max(this._maxWordWidth, word.width);\n\t\t\tcurrentWord++;\n\t\t}\n\t\tthis._lineWidth -= this._spaceWidth;\n\t};\n\n\t// Split the single line into multiple lines which fit into the available width...\n\tthis._wrap = function (ctx, width) {\n\t\tvar spaceWidth = this._spaceWidth;\n\t\tvar word;\n\t\tvar currentWidth = 0;\n\t\tvar line = [];\n\t\tvar s = \"\";\n\n\t\tthis._lines = [];\n\t\tthis._maxWidth = 0;\n\n\t\tvar currentWord = 0;\n\t\tvar wordCount = this._line.length;\n\t\twhile (currentWord < wordCount) {\n\t\t\tword = this._line[currentWord];\n\t\t\tcurrentWidth += word.width + spaceWidth;\n\t\t\tif (word.word === \"\\n\") {\n\t\t\t\tthis._lines.push(line);\n\t\t\t\tline = [];\n\t\t\t\tcurrentWidth = 0;\n\t\t\t\ts = \"\";\n\t\t\t} else if (currentWidth > width) {\n\t\t\t\tline.length && this._lines.push(line);\n\t\t\t\tline = [word];\n\t\t\t\tcurrentWidth = word.width + spaceWidth;\n\t\t\t\ts = word.word;\n\t\t\t} else {\n\t\t\t\ts += word.word;\n\t\t\t\tline.push(word);\n\t\t\t}\n\t\t\tcurrentWord++;\n\t\t}\n\n\t\tif (s !== \"\") {\n\t\t\tthis._lines.push(line);\n\t\t}\n\t};\n\n\t// Calculate the position of each word on the line...\n\tthis._wordFlow = function (ctx) {\n\t\tvar spaceWidth = this._spaceWidth;\n\t\tvar lines = this._lines;\n\t\tvar lineSize = this._opts.size * this._opts.lineHeight;\n\n\t\tthis._cache = [];\n\t\tthis._cacheSize = 0;\n\n\t\tthis._maxWidth = 0;\n\t\tthis._maxHeight = 0;\n\n\t\tvar currentLine = 0;\n\t\tvar lineCount = lines.length;\n\t\tvar y = 0;\n\n\t\twhile (currentLine < lineCount) {\n\t\t\tvar line = lines[currentLine++];\n\t\t\tvar currentWord = 0;\n\t\t\tvar wordCount = line.length;\n\t\t\tvar x = 0;\n\n\t\t\twhile (currentWord < wordCount) {\n\t\t\t\tvar word = line[currentWord++];\n\n\t\t\t\tword.x = x;\n\t\t\t\tword.y = y;\n\t\t\t\tword.line = currentLine;\n\t\t\t\tthis._cache[this._cacheSize++] = word;\n\n\t\t\t\tx += word.width + spaceWidth;\n\t\t\t}\n\n\t\t\ty += lineSize;\n\t\t\tx -= spaceWidth;\n\n\t\t\tthis._maxWidth = Math.max(this._maxWidth, x);\n\t\t\tthis._maxHeight = Math.max(this._maxHeight, y);\n\t\t}\n\t};\n\n\t// Check if the given width fits into the available size, if not the resize the font...\n\tthis._checkWidth = function (ctx, width) {\n\t\tvar opts = this._opts;\n\n\t\tif (width > this.getActualWidth()) {\n\t\t\tvar size = (opts.size * this._target.style.width / width) | 0;\n\t\t\t(opts.size !== size) && this.publish(\"ChangeSize\", size, ctx);\n\t\t\tthis._spaceWidth = ctx.measureText(\" \").width;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\n\tthis._checkHeight = function (ctx, loSize, hiSize, cb) {\n\t\tif (Math.abs(hiSize - loSize) < 2) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar pivot = Math.max((loSize + hiSize) >> 1, 1);\n\t\tthis.publish(\"ChangeSize\", pivot, ctx);\n\t\tcb();\n\t\tif (pivot === 1) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar opts = this._opts;\n\t\tif ((this._lines.length * opts.size * opts.lineHeight > this.getActualHeight())) {\n\t\t\tthis._checkHeight(ctx, loSize, pivot, cb);\n\t\t} else {\n\t\t\tthis._heightFound = opts.size;\n\t\t\tthis._checkHeight(ctx, pivot, hiSize, cb);\n\t\t}\n\t};\n\n\tthis._horizontalAlign = function () {\n\t\tvar paddingLeft = this.getPaddingLeft();\n\t\tvar spaceWidth = this._spaceWidth;\n\t\tvar div = {left: -1, center: 2, right: 1, justify: 3}[this._opts.horizontalAlign];\n\t\tvar cache = this._cache;\n\t\tvar actualWidth = this.getActualWidth();\n\t\tvar width;\n\t\tvar offset;\n\t\tvar line;\n\t\tvar x;\n\n\t\tif (!cache.length) {\n\t\t\treturn;\n\t\t}\n\t\tif (div === 3) {\n\t\t\tspaceWidth = 0;\n\t\t}\n\n\t\tvar firstWordOnLine;\n\t\tvar currentWord = 0;\n\t\tvar wordCount = cache.length;\n\t\twhile (currentWord < wordCount) {\n\t\t\tfirstWordOnLine = currentWord;\n\t\t\tline = cache[currentWord].line;\n\t\t\twidth = 0;\n\t\t\twhile ((currentWord < wordCount) && (line === cache[currentWord].line)) {\n\t\t\t\twidth += cache[currentWord].width + spaceWidth;\n\t\t\t\tcurrentWord++;\n\t\t\t}\n\t\t\tif (div === -1) { // left...\n\t\t\t\twhile (firstWordOnLine < currentWord) {\n\t\t\t\t\tcache[firstWordOnLine++].x += paddingLeft;\n\t\t\t\t}\n\t\t\t} else if (div === 3) { // justify...\n\t\t\t\toffset = (line < cache[cache.length - 1].line) ? (actualWidth - width) / (currentWord - firstWordOnLine - 1) : this._spaceWidth;\n\t\t\t\tx = paddingLeft;\n\t\t\t\twhile (firstWordOnLine < currentWord) {\n\t\t\t\t\tcache[firstWordOnLine].x = x;\n\t\t\t\t\tx += cache[firstWordOnLine].width + offset;\n\t\t\t\t\tfirstWordOnLine++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toffset = (actualWidth - width + spaceWidth) / div + paddingLeft;\n\t\t\t\twhile (firstWordOnLine < currentWord) {\n\t\t\t\t\tcache[firstWordOnLine++].x += offset;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tthis._verticalAlign = function () {\n\t\tvar lineCount = this._lines.length;\n\t\tvar div = {top: -1, middle: 2, bottom: 1}[this._opts.verticalAlign];\n\t\tvar cache = this._cache;\n\t\tvar actualHeight = this.getActualHeight();\n\t\tvar offset;\n\t\tvar i = cache.length;\n\n\t\tif (!cache.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (div === -1) {\n\t\t\toffset = this.getPaddingTop();\n\t\t} else {\n\t\t\toffset = (actualHeight - lineCount * this._opts.size * this._opts.lineHeight) / div + this.getPaddingTop();\n\t\t}\n\t\twhile (i) {\n\t\t\tcache[--i].y += offset;\n\t\t}\n\n\t\tthis._offsetRect.y += offset;\n\t};\n\n\tthis.reflow = function (ctx, mode) {\n\t\tvar opts = this._opts;\n\t\tvar actualWidth = this.getActualWidth();\n\t\tvar actualHeight = this.getActualHeight();\n\n\t\tthis._spaceWidth = ctx.measureText(\" \").width;\n\t\tthis._lineSplit(ctx);\n\n\t\tswitch (mode) {\n\t\t\tcase textFlowMode.NONE:\n\t\t\t\tthis._lines = [this._line];\n\t\t\t\tthis._wordFlow(ctx);\n\t\t\t\tbreak;\n\n\t\t\tcase textFlowMode.WRAP:\n\t\t\t\tthis._wrap(ctx, actualWidth);\n\t\t\t\tthis._wordFlow(ctx);\n\t\t\t\tbreak;\n\n\t\t\tcase textFlowMode.AUTOSIZE:\n\t\t\tcase textFlowMode.AUTOFONTSIZE_AUTOSIZE:\n\t\t\t\tthis._lines = [this._line];\n\t\t\t\tthis._wordFlow(ctx);\n\n\t\t\t\t(actualWidth < this._maxWidth) && this.publish(\"ChangeWidth\", this._maxWidth + this.getHorizontalPadding());\n\t\t\t\t(actualHeight < this._maxHeight) && this.publish(\"ChangeHeight\", this._maxHeight + this.getVerticalPadding());\n\t\t\t\tbreak;\n\n\t\t\tcase textFlowMode.AUTOSIZE_WRAP:\n\t\t\t\tthis._wrap(ctx, actualWidth);\n\t\t\t\tthis._wordFlow(ctx);\n\n\t\t\t\t(actualWidth < this._maxWidth) && this.publish(\"ChangeWidth\", this._maxWidth + this.getHorizontalPadding());\n\t\t\t\t(actualHeight < this._maxHeight) && this.publish(\"ChangeHeight\", this._maxHeight + this.getVerticalPadding());\n\t\t\t\tbreak;\n\n\t\t\tcase textFlowMode.AUTOFONTSIZE:\n\t\t\t\tthis._checkWidth(ctx, this._lineWidth) && this._lineSplit(ctx);\n\t\t\t\tthis._lines = [this._line];\n\t\t\t\tif (opts.size * opts.lineHeight > this.getActualHeight()) {\n\t\t\t\t\tvar cb = bind(\n\t\t\t\t\t\tthis,\n\t\t\t\t\t\tfunction () {\n\t\t\t\t\t\t\tthis._spaceWidth = ctx.measureText(\" \").width;\n\t\t\t\t\t\t\tthis._measureWords(ctx);\n\t\t\t\t\t\t\tthis._wordFlow(ctx);\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\n\t\t\t\t\tthis._checkHeight(ctx, 1, opts.size, cb);\n\t\t\t\t\tthis.publish(\"ChangeSize\", this._heightFound, ctx);\n\t\t\t\t\tcb();\n\t\t\t\t} else {\n\t\t\t\t\tthis._wordFlow(ctx);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase textFlowMode.AUTOFONTSIZE_WRAP:\n\t\t\t\tthis._wrap(ctx, actualWidth);\n\t\t\t\tif (this._checkWidth(ctx, this._maxWordWidth)) {\n\t\t\t\t\tthis._lineSplit(ctx);\n\t\t\t\t\tthis._wrap(ctx, actualWidth);\n\t\t\t\t}\n\t\t\t\tthis._wordFlow(ctx);\n\n\t\t\t\tif (this._lines.length * opts.size * opts.lineHeight > this.getActualHeight()) {\n\t\t\t\t\tvar cb = bind(\n\t\t\t\t\t\tthis,\n\t\t\t\t\t\tfunction () {\n\t\t\t\t\t\t\tthis._spaceWidth = ctx.measureText(\" \").width;\n\t\t\t\t\t\t\tthis._measureWords(ctx);\n\t\t\t\t\t\t\tthis._wrap(ctx, actualWidth);\n\t\t\t\t\t\t\tthis._wordFlow(ctx);\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\n\t\t\t\t\tthis._checkHeight(ctx, 1, opts.size, cb);\n\t\t\t\t\tthis.publish(\"ChangeSize\", this._heightFound, ctx);\n\t\t\t\t\tcb();\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase textFlowMode.AUTOFONTSIZE_WRAP_AUTOSIZE:\n\t\t\t\tthis._wrap(ctx, actualWidth);\n\t\t\t\tif (this._checkWidth(ctx, this._maxWordWidth)) {\n\t\t\t\t\tthis._lineSplit(ctx);\n\t\t\t\t\tthis._wrap(ctx, actualWidth);\n\t\t\t\t}\n\t\t\t\tthis._wordFlow(ctx);\n\n\t\t\t\t(actualHeight < this._maxHeight) && this.publish(\"ChangeHeight\", this._maxHeight + this.getVerticalPadding());\n\t\t\t\tbreak;\n\t\t}\n\n\t\tvar cache = this._cache;\n\t\tvar lastCacheItem = cache[cache.length - 1];\n\n\t\tif (!cache.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._offsetRect.x = 0;\n\t\tthis._offsetRect.y = 0;\n\t\tthis._offsetRect.width = this.getActualWidth();\n\t\tthis._offsetRect.height = lastCacheItem.line * opts.lineHeight * opts.size;\n\n\t\tthis._horizontalAlign();\n\t\tthis._verticalAlign();\n\n\t\tif (lastCacheItem.line === 1) {\n\t\t\tthis._offsetRect.x = cache[0].x;\n\t\t\tthis._offsetRect.width = lastCacheItem.x + lastCacheItem.width - cache[0].x;\n\t\t}\n\t};\n\n\tthis.setOpts = function (opts) {\n\t\tthis._opts = opts;\n\t};\n\n\tthis.getCache = function () {\n\t\treturn this._cache;\n\t};\n\n\tthis.getHorizontalPadding = function () {\n\t\tif (!(\"horizontalPadding\" in this._opts)) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (isArray(this._opts.horizontalPadding)) {\n\t\t\treturn (this._opts.horizontalPadding[0] | 0) + (this._opts.horizontalPadding[1] | 0);\n\t\t}\n\t\treturn (this._opts.horizontalPadding | 0) * 2;\n\t};\n\n\tthis.getPaddingLeft = function () {\n\t\tif (isArray(this._opts.horizontalPadding)) {\n\t\t\treturn this._opts.horizontalPadding[0] | 0\n\t\t}\n\t\treturn this._opts.horizontalPadding | 0;\n\t};\n\n\tthis.getActualWidth = function () {\n\t\treturn this._target.style.width - this.getHorizontalPadding();\n\t};\n\n\tthis.getVerticalPadding = function () {\n\t\tif (!(\"verticalPadding\" in this._opts)) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (isArray(this._opts.verticalPadding)) {\n\t\t\treturn (this._opts.verticalPadding[0] | 0) + (this._opts.verticalPadding[1] | 0);\n\t\t}\n\t\treturn (this._opts.verticalPadding | 0) * 2;\n\t};\n\n\tthis.getPaddingTop = function () {\n\t\tif (isArray(this._opts.verticalPadding)) {\n\t\t\treturn this._opts.verticalPadding[0] | 0;\n\t\t}\n\t\treturn this._opts.verticalPadding | 0;\n\t};\n\n\tthis.getActualHeight = function () {\n\t\treturn this._target.style.height - this.getVerticalPadding();\n\t};\n\n\tthis.getOffsetRect = function () {\n\t\treturn this._offsetRect;\n\t};\n});\n","pre":true},"../../../../sdk/timestep/ui/backend/canvas/ViewDebugger.js":{"path":"../../../../sdk/timestep/ui/backend/canvas/ViewDebugger.js","friendlyPath":".backend.canvas.ViewDebugger","directory":"../../../../sdk/timestep/ui/backend/canvas/","filename":"ViewDebugger.js","src":"jsio(\"import std.js as JS\");\n\nvar sdk_timestep_ui_backend_canvas_ViewDebugger=__class__;exports=sdk_timestep_ui_backend_canvas_ViewDebugger(function sdk_timestep_ui_backend_canvas_ViewDebugger(){return this.init&&this.init.apply(this,arguments)},function() {\n\t\n\tthis.init = function(target, opts) {\n\t\tthis._target = target;\n\t\tthis._opts = opts = JS.merge(opts, {\n\t\t\ttrackClicks: false,\n\t\t\toutline: false,\n\t\t\tflash: false\n\t\t});\n\t\t\n\t\tthis.outline = opts.outline;\n\t\tthis.trackClicks = opts.trackClicks;\n\t\tthis.flash = opts.flash;\n\t\t\n\t\tthis._flashState = 0;\n\t\tthis._nextFlash = 0;\n\t}\n\t\n\tthis.preRender = function(ctx) {\n\t\tif (!this._time) { this._time = +new Date(); }\n\t\tvar prevTime = this._time;\n\t\tthis._time = +new Date();\n\t\tthis._dt = this._time - prevTime;\n\t\t\n\t\tvar s = this._target.style;\n\t\tif (this.outline) {\n\t\t\tctx.save();\n\t\t\tctx.globalAlpha = 0.2;\n\t\t\tctx.strokeStyle = 'black';\n\t\t\tif (this._target._circle) {\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.arc(0, 0, s.radius, 0, 360, false);\n\t\t\t\tctx.stroke();\n\t\t\t\tctx.closePath();\n\t\t\t} else {\n\t\t\t\tctx.lineWidth = 1.0;\n\t\t\t\tctx.strokeRect(0, 0, s.width, s.height);\n\t\t\t}\n\t\t\tctx.restore();\n\t\t}\n\t}\n\t\n\tthis.postRender = function(ctx) {\n\t\t\tvar s = this._target.style;\n\n\t\tvar t = this._target;\n\t\tif (this.trackClicks) {\n\t\t\tfor (var i = t._clicks.length - 1; i >= 0; --i) {\n\t\t\t\tvar c = t._clicks[i];\n\t\t\t\tctx.setFillStyle('rgba(0, 0, 0, ' + c.o + ')');\n\t\t\t\tc.o -= 0.4 * this._dt / 1000;\n\t\t\t\tif (c.o > 0) {\n\t\t\t\t\tctx.circle(c.x, c.y, 15);\n\t\t\t\t\tctx.fill();\n\t\t\t\t} else {\n\t\t\t\t\tt._clicks.splice(i, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (this.flash) {\n\t\t\tswitch(this._flashState) {\n\t\t\t\tcase 0:\n\t\t\t\t\tctx.setFillStyle('rgba(0, 0, 0, 0.5)');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tctx.setFillStyle('rgba(0, 0, 0, 0)');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tctx.setFillStyle('rgba(255, 255, 255, 0.5)');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tctx.setFillStyle('rgba(0, 0, 0, 0)');\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tvar now = +new Date();\n\t\t\tif (now > this._nextFlash) {\n\t\t\t\tthis._flashState = (this._flashState + 1) % 4;\n\t\t\t\tthis._nextFlash = now + 300;\n\t\t\t}\n\t\t\t\n\t\t\tif (t._circle) {\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\tctx.fillRect(0, 0, t.style.width, t.style.height);\n\t\t\t}\n\t\t}\n\t}\n});\n","pre":true},"../../../../sdk/timestep/ui/init.js":{"path":"../../../../sdk/timestep/ui/init.js","friendlyPath":"ui.init","directory":"../../../../sdk/timestep/ui/","filename":"init.js","src":"jsio(\"import .View\");\njsio(\"import .layout.BackingExtension\");\njsio(\"import .Engine\");","pre":true},"../../../../sdk/timestep/ui/layout/BackingExtension.js":{"path":"../../../../sdk/timestep/ui/layout/BackingExtension.js","friendlyPath":".layout.BackingExtension","directory":"../../../../sdk/timestep/ui/layout/","filename":"BackingExtension.js","src":"jsio(\"import ..View\");\njsio(\"import ..backend.strPad as strPad\");\njsio(\"import ..backend.BaseBacking\");\njsio(\"import .BoxLayout\");\njsio(\"import .LinearLayout\");\njsio(\"import .Padding\");\n\njsio(\"import util.setProperty\");\n\nvar layoutProps = {\n\t\t'layout': {value: false, cb: '_onSetLayout'},\n\t\t'inLayout': {value: true, cb: '_onInLayout'},\n\t\t'order': {value: 0, cb: '_onOrder'},\n\t\t'direction': {value: 'down', cb: '_onLayoutChange'},\n\t\t'flex': {value: 0, cb: '_onLayoutChange'},\n\t\t'halign': {value: 'start'}, 'halignSelf': {value: undefined},\n\t\t'valign': {value: 'start'}, 'valignSelf': {value: undefined},\n\n\t\t'centerX': {value: false},\n\t\t'centerY': {value: false},\n\n\t\t'top': {value: undefined, cb: '_onLayoutChange'},\n\t\t'right': {value: undefined, cb: '_onLayoutChange'},\n\t\t'bottom': {value: undefined, cb: '_onLayoutChange'},\n\t\t'left': {value: undefined, cb: '_onLayoutChange'},\n\n\t\t'justifyContent': {value: 'start', cb: '_onLayoutChange'},\n\t\t'sizeContainerToFit': {value: false, cb: '_onLayoutChange'},\n\n\t\t'minWidth': {value: undefined, cb: '_onLayoutChange'},\n\t\t'minHeight': {value: undefined, cb: '_onLayoutChange'},\n\t\t'maxWidth': {value: undefined, cb: '_onLayoutChange'},\n\t\t'maxHeight': {value: undefined, cb: '_onLayoutChange'},\n\n\t\t'layoutWidth': {value: undefined, cb: '_onLayoutChange'},\n\t\t'layoutHeight': {value: undefined, cb: '_onLayoutChange'},\n\n\t\t'fixedAspectRatio': {value: false, cb: '_onFixedAspectRatio'},\n\t\t'aspectRatio': {value: null, cb: '_onLayoutChange'},\n\n\t\t'margin': {value: null, cb: '_onMarginChange'}\n\t};\n\nfor (var key in layoutProps) {\n\tbackend.BaseBacking.addProperty(key, layoutProps[key]);\n}\n\nutil.setProperty(backend.BaseBacking.prototype, 'padding', {\n\tget: function () {\n\t\treturn this._padding || (this._padding = new Padding());\n\t},\n\tset: function (value) {\n\t\tif (this._padding) {\n\t\t\tthis._padding.update(value);\n\t\t} else {\n\t\t\tthis._padding = new Padding(value);\n\t\t}\n\n\t\tthis._onLayoutChange();\n\t}\n});\n\nView.addExtension({\n\textend: function (ViewBacking) {\n\n\t\tvar proto = ViewBacking.prototype;\n\n\t\tproto._sortOrder = strPad.initialValue;\n\t\tproto._onOrder = function(_, order) {\n\t\t\tthis._sortOrder = strPad.pad(order);\n\t\t\tthis._onLayoutChange();\n\t\t};\n\t\t\n\t\tproto._onMarginChange = function (key, value) {\n\t\t\tif (this._cachedMargin) {\n\t\t\t\tthis._cachedMargin.update(value);\n\t\t\t} else {\n\t\t\t\tthis._cachedMargin = new Padding(value);\n\t\t\t}\n\n\t\t\tthis.top = this._cachedMargin.top;\n\t\t\tthis.bottom = this._cachedMargin.bottom;\n\t\t\tthis.left = this._cachedMargin.left;\n\t\t\tthis.right = this._cachedMargin.right;\n\n\t\t\tthis._onLayoutChange();\n\t\t}\n\n\t\tproto._onFixedAspectRatio = function (key, value) {\n\t\t\tif (value) {\n\t\t\t\tthis.updateAspectRatio();\n\t\t\t}\n\t\t}\n\n\t\tproto.updateAspectRatio = function () {\n\t\t\tthis.aspectRatio = this.width / this.height;\n\t\t}\n\n\t\tproto._onSetLayout = function (key, which) {\n\t\t\tswitch (which) {\n\t\t\t\tcase 'linear':\n\t\t\t\t\tthis._view.__layout = new LinearLayout({view: this._view});\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'box':\n\t\t\t\t\tthis._view.__layout = new BoxLayout({view: this._view});\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t};\n\n\t\tproto._onInLayout = function (key, value) {\n\t\t\tvar layout = this._superview && this._superview.__layout;\n\t\t\tif (layout) {\n\t\t\t\tif (value) {\n\t\t\t\t\tlayout.add(this._view);\n\t\t\t\t} else {\n\t\t\t\t\tlayout.remove(this._view);\n\t\t\t\t\tthis._view.needsReflow();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// var isPercent = /%$/;\n\t\t// proto._onLayoutSizeChange = function (key, value, oldValue) {\n\t\t// \t// Subscribes a view to parent resize events when the view is in the hierarchy and\n\t\t// \t// contains a percentage height or width.\n\t\t// \t//\n\t\t// \t// NOTE: a view only sets up resize listeners once -- if layoutWidth is set to a percent and then reset\n\t\t// \t// to not have a percent, it will still get reflow events when its superview resizes.  We could\n\t\t// \t// remove the listeners once the view no longer has percentages.\n\t\t// \tif (!this._hasResizeListeners && (isPercent.test(this._layoutWidth) || isPercent.test(this._layoutHeight))) {\n\t\t// \t\tthis._hasResizeListeners = true;\n\t\t// \t\tthis._view.on('ViewAdded', bind(this, function () {\n\t\t// \t\t\tif (this.__superviewResize) {\n\t\t// \t\t\t\tthis.__superviewResize();\n\t\t// \t\t\t}\n\t\t\t\t\t\n\t\t// \t\t\tvar superview = this._view.getSuperview();\n\t\t// \t\t\tvar onResize = bind(this._view, 'needsReflow');\n\t\t// \t\t\tsuperview.on('Resize', onResize);\n\t\t\t\t\t\n\t\t// \t\t\tthis.__superviewResize = bind(this, function () {\n\t\t// \t\t\t\tthis.__superviewResize = null;\n\t\t// \t\t\t\tsuperview.removeListener('Resize', onResize);\n\t\t// \t\t\t});\n\t\t// \t\t}));\n\t\t\t\t\n\t\t// \t\tthis._view.on('ViewRemoved', bind(this, function (superview) {\n\t\t// \t\t\tif (this.__superviewResize) { this.__superviewResize(); }\n\t\t// \t\t}));\n\t\t// \t}\n\t\t\t\n\t\t// \tthis._onLayoutChange();\n\t\t// }\n\n\t\tproto._onLayoutChange = function () {\n\t\t\tvar superview = this.getSuperview();\n\t\t\tif (superview && superview.__layout) {\n\t\t\t\tsuperview.needsReflow();\n\t\t\t}\n\n\t\t\tthis._view.needsReflow();\n\t\t}\n\t}\n});\n","pre":true},"../../../../sdk/_api/client/nativeShim.js":{"path":"../../../../sdk/_api/client/nativeShim.js","friendlyPath":"_api.client.nativeShim","directory":"../../../../sdk/_api/client/","filename":"nativeShim.js","baseMod":"_api","basePath":"../../../../sdk","src":"jsio(\"import api.generator\");\njsio(\"import lib.PubSub\");\njsio(\"import lib.Callback\");\n\nvar testContactList = [\n\t{id: 0, name: \"Martin Hunt\", phones: [{number: '6504509564'}]},\n\t{id: 1, name: \"Michael Carter\", phones: [{number: '6505166564'}]},\n\t{id: 2, name: \"Marcus Cavanaugh\", phones: [{number: '05159757683'}]}, // Remove first zero to actually reach Marcus...\n\t{id: 3, name: \"GC Android Phone (Lily)\", phones: [{number: '6506913167'}]}\n];\n\nfor (var i = testContactList.length; i < 1000; ++i) {\n\ttestContactList.push({id: i, name: api.generator.username(), phones: [{number:'6504509564'}]});\n}\n\nexports.onBackButton = function () {};\n\nexports.dialogs = {\n\t\n\tshowDialog: function() {\n\t\tlogger.log(\"Showing a dialog!\");\n\t},\n\n\tshowAppRater: function() {\n\t\tlogger.log(\"Showing rate dialog!\");\n\t}\n\n};\n\n\nvar _withContacts = new lib.Callback();\n_withContacts.fire();\n\nexports.contacts = merge(new lib.PubSub(), {\n\t\n\tgetContactList: function() {\n\t\treturn testContactList;\n\t},\n\n\twithContacts: function() { _withContacts.forward(arguments); },\n\n\tsendAutomatedSMS: function(phone, msg, cb) {\n\t\tlogger.log('Send Automated SMS:', phone, msg);\n\t\tcb && cb();\n\t},\n\n\tsendSMS: function(phone, msg, cb) {\n\t\tlogger.log('Send SMS:', phone, msg);\n\t\tcb && cb();\n\t},\n\n\tgetPicture: function(id) {\n\t\treturn null;\n\t},\n\t\n\tgetPictures: function(ids) {\n\t\treturn null;\n\t},\n\n\tgetPictureBase64: function(id) {\n\t\treturn null;\n\t}\n\n});\n\nvar _withPhoneNumber = new lib.Callback();\n_withPhoneNumber.fire(null);\n\nvar _withPhoneNumber = new lib.Callback();\n_withPhoneNumber.fire(null);\n\nexports.profile = {\n\tfullName: \"\",\n\n\tgetPicture: function(id) {\n\t\treturn null;\n\t},\n\n\tgetPictureBase64: function(id) {\n\t\treturn null;\n\t},\n\n\twithPhoneNumber: function () { _withPhoneNumber.forward(arguments); }\n};\n\n\nexports.sound = {\n\tplaySound: function(url, volume) {\n\t\tlogger.log('this would play a sound on native');\n\t},\n\tloadSound: function(url) {\n\t\tlogger.log('this would load a sound on native');\n\t},\n\tpauseSound: function(url) {\n\t\tlogger.log('this would pause a sound on native');\n\t},\n\tstopSound: function(url) {\n\t\tlogger.log('this would stop a sound on native');\n\t},\n\tsetVolume: function(url, volume) {\n\t\tlogger.log('this would set the volume of a sound on native');\n\t},\n\tloadBackgroundMusic: function(url) {\n\t\tlogger.log('this would load background music on native');\n\t},\n\tplayBackgroundMusic: function(url) {\n\t\tlogger.log('this would play background music on native');\n\t}\n};\n\nexports.alerts = new lib.PubSub();\nmerge(exports.alerts, {\n\tonNotificationLoad: function () {},\n\tshowNotification: function () {\n\t\treturn -1;\n\t},\n\tshowRecurringNotification: function () {\n\t\tlogger.log(\"Setting up a recurring notification!\");\n\t\treturn -1;\n\t}\n});\n\nexports.social = new lib.PubSub();\n\n//import .auth.conn;\n//auth.conn.webAutoLogin();\n\nif (!GLOBAL.NATIVE) { GLOBAL.NATIVE = exports; }\n","pre":true},"../../../../sdk/api/generator.js":{"path":"../../../../sdk/api/generator.js","friendlyPath":"api.generator","directory":"../../../../sdk/api/","filename":"generator.js","baseMod":"api","basePath":"../../../../sdk","src":"var creatures = [\"urchin\", \"cucumber\", \"dolphin\", \"shark\", \"whale\", \"otter\", \"starfish\", \"coral\", \"eel\", \"goldfish\", \"manatee\", \"salmon\", \"trout\", \"bass\", \"halibut\", \"clam\", \"oyster\", \"shrimp\", \"tuna\", \"plankton\", \"seaweed\", \"algae\", \"ocotopus\", \"squid\", \"mantaray\", \"stingray\", \"walrus\"];\n\nvar adjectives = [\"fuming\", \"melancholy\", \"scheming\", \"hyper\", \"happy\", \"sad\", \"confused\", \"wired\", \"engergized\", \"smug\", \"cool\", \"sleepy\", \"party\", \"sick\", \"down-to-earth\", \"droopy-eyed\", \"dopey\", \"mopey\", \"desperate\", \"envious\", \"somber\", \"panicked\", \"alarmed\", \"impatient\", \"tense\", \"jealous\", \"irate\", \"jealous\", \"warped\", \"zealous\", \"livid\", 'undersized', 'prismatic', 'uppity', 'polygot', 'renascent', 'nonliving', 'contrapuntal', 'demonstrable', 'sanguine', 'raspiest', 'cracklier', 'presumptive', 'standoffish', 'wartier', 'nethermost', 'upstream', 'placating', 'localized', 'specked', 'aluminum', 'singled', 'ingested', 'ostensible', 'seventeen', 'bonded', 'quantitative', 'lettered', 'pickled', 'stolid', 'dignifying', 'marred'];\n\nvar colors = [\"red\", \"green\", \"orange\", \"blue\", \"rainbow\", \"yellow\", \"white\", \"zebra\", \"chartreuse\", \"magenta\", \"turqouise\", \"cyan\", \"steel\", \"forest\"];\n\nvar nouns = ['option', 'numeracy', 'freeloading', 'minivan', 'wastepaper', 'junketeer', 'harmlessness', 'actuator', 'carnelian', 'perfectionism', 'sleepwalker', 'brewer', 'cadmium', 'reformist', 'condemner', 'metalworking', 'growler', 'honorer', 'campanologist', 'overcoat', 'knob', 'abrasive', 'pebbling', 'perennial', 'logger', 'landslide', 'housework', 'nightfall', 'tricycle', 'tameness'];\n\nexports.pick = function() {\n\tvar list = Array.prototype.concat.apply(arguments[0], Array.prototype.slice.call(arguments, 1));\n\treturn list[Math.random() * list.length | 0];\n}\n\nexports.gameName = function() {\n\treturn exports.pick(adjectives) + ' ' + exports.pick(nouns);\n}\n\nexports.username = function() {\n\treturn exports.pick(adjectives) + ' ' + exports.pick(creatures);\n}\n\nexports.name = function() {\n\treturn exports.pick(nouns, creatures);\n}\n\nfunction merge() { return Array.prototype.concat.apply(arguments[0], Array.prototype.slice.call(arguments, 1)); }\n\nexports.tautogram = function() {\n\twhile (true) {\n\t\tvar name = exports.name(),\n\t\t\tletter = name.charAt(0),\n\t\t\ta = merge(adjectives, colors).filter(function(a) { return a.charAt(0) == letter; });\n\t\tif (a.length) {\n\t\t\treturn exports.pick(a) + ' ' + name;\n\t\t}\n\t}\n}\n","pre":true},"../../../../sdk/_api/client/debugLogger.js":{"path":"../../../../sdk/_api/client/debugLogger.js","friendlyPath":"_api.client.debugLogger","directory":"../../../../sdk/_api/client/","filename":"debugLogger.js","src":"// this whole file should not get included in release\nif (DEBUG) {\n\tjsio(\"import device\");\n\tjsio(\"import math.geom.Point as Point\");\n\tjsio(\"import net\");\n\tjsio(\"import net.protocols.Cuppa\");\n\tjsio(\"import ui.resource.Image as Image\");\n\tjsio(\"import ui.ImageView as ImageView\");\n\n\tGLOBAL._DEBUG = new (Class(function () {\n\n\t\tthis.traverse = function (f) { return GC.app && this.traverseView(f, GC.app.view); }\n\t\tthis.traverseView = function(f, view) {\n\t\t\treturn {\n\t\t\t\tuid: view.uid,\n\t\t\t\tdata: f(view),\n\t\t\t\tsubviews: view.getSubviews().map(bind(this, 'traverseView', f))\n\t\t\t};\n\t\t}\n\n\t\tthis.find = function (f) { return GC.app && this.findView(f, GC.app.view); }\n\t\tthis.findView = function (f, view) {\n\t\t\tif (f(view)) { return view; }\n\t\t\tvar subviews = view.getSubviews();\n\t\t\tfor (var i = 0, sub; sub = subviews[i]; ++i) {\n\t\t\t\tvar res = this.findView(f, sub);\n\t\t\t\tif (res) { return res; }\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.getViewByID = function (uid) { return this.find(function (view) { return view.uid == uid; }); }\n\n\t\tthis.pack = function () { return GC.app && this.packView(GC.app.view); }\n\t\tthis.packView = function (view) {\n\t\t\tjsio(\"import ui.ImageView\");\n\t\t\tjsio(\"import ui.widget.UIImageView\");\n\t\t\tjsio(\"import ui.TextView\");\n\n\t\t\treturn this.traverseView(function (view) {\n\n\t\t\t\tif (view instanceof ui.ImageView) {\n\t\t\t\t\tvar img = view.getImage();\n\t\t\t\t\tif (img) {\n\t\t\t\t\t\tvar imageData = img.getMap();\n\t\t\t\t\t\timageData.type = 'ImageView';\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (view instanceof ui.widget.UIImageView) {\n\t\t\t\t\tvar img = view.getImage();\n\t\t\t\t\tif (img) {\n\t\t\t\t\t\tvar imageData = img.getMap();\n\t\t\t\t\t\timageData.type = 'UIImageView';\n\t\t\t\t\t\timageData.scaleMethod = view._scaleMethod;\n\t\t\t\t\t\timageData.slices = view._opts.slices;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (view instanceof ui.TextView) {\n\t\t\t\t\tvar text = view.getText();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar s = view.style;\n\t\t\t\treturn {\n\t\t\t\t\tx: s.x,\n\t\t\t\t\ty: s.y,\n\t\t\t\t\twidth: s.width,\n\t\t\t\t\theight: s.height,\n\t\t\t\t\tscale: s.scale,\n\t\t\t\t\timage: imageData,\n\t\t\t\t\ttext: text,\n\t\t\t\t\tvisible: s.visible,\n\t\t\t\t\topacity: s.opacity,\n\t\t\t\t\ttag: view.getTag()\n\t\t\t\t};\n\t\t\t}, view);\n\t\t}\n\n\t\tthis.unpack = function (data) {\n\t\t\tjsio(\"import ui.View\");\n\t\t\tjsio(\"import ui.widget.UIImageView\");\n\t\t\tjsio(\"import ui.ImageView\");\n\t\t\tjsio(\"import ui.resource.Image\");\n\t\t\tjsio(\"import ui.TextView\");\n\n\t\t\tfunction buildView (superview, data) {\n\t\t\t\tvar view;\n\n\t\t\t\tvar opts = data.data;\n\t\t\t\tif (opts.image) {\n\t\t\t\t\tvar img = opts.image;\n\t\t\t\t\tview = new (img.type == 'UIImageView' ? ui.widget.UIImageView : ui.ImageView)({\n\t\t\t\t\t\tx: opts.x,\n\t\t\t\t\t\ty: opts.y,\n\t\t\t\t\t\twidth: opts.width,\n\t\t\t\t\t\theight: opts.height,\n\t\t\t\t\t\tscale: opts.scale,\n\t\t\t\t\t\t\n\t\t\t\t\t\tscaleMethod: img.scaleMethod,\n\t\t\t\t\t\tslices: img.slices,\n\n\t\t\t\t\t\tsuperview: superview,\n\t\t\t\t\t\timage: new ui.resource.Image({\n\t\t\t\t\t\t\turl: img.url,\n\t\t\t\t\t\t\tsourceX: img.x,\n\t\t\t\t\t\t\tsourceY: img.y,\n\t\t\t\t\t\t\tsourceW: img.width,\n\t\t\t\t\t\t\tsourceH: img.height,\n\t\t\t\t\t\t\tmarginTop: img.marginTop,\n\t\t\t\t\t\t\tmarginRight: img.marginRight,\n\t\t\t\t\t\t\tmarginBottom: img.marginBottom,\n\t\t\t\t\t\t\tmarginLeft: img.marginLeft\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tvisible: opts.visible,\n\t\t\t\t\t\topacity: opts.opacity,\n\t\t\t\t\t\ttag: opts.tag\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tview = new (opts.text ? ui.TextView : ui.View)({\n\t\t\t\t\t\tx: opts.x,\n\t\t\t\t\t\ty: opts.y,\n\t\t\t\t\t\twidth: opts.width,\n\t\t\t\t\t\theight: opts.height,\n\t\t\t\t\t\ttext: opts.text,\n\t\t\t\t\t\tsuperview: superview,\n\t\t\t\t\t\tscale: opts.scale,\n\t\t\t\t\t\tvisible: opts.visible,\n\t\t\t\t\t\topacity: opts.opacity,\n\t\t\t\t\t\ttag: opts.tag\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tview.uid = data.uid;\n\n\t\t\t\tfor (var i = 0, sub; sub = data.subviews[i]; ++i) {\n\t\t\t\t\tbuildView(view, sub);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tGC.app.view.updateOpts(data.data);\n\t\t\tfor (var i = 0, sub; sub = data.subviews[i]; ++i) {\n\t\t\t\tbuildView(GC.app.view, sub);\n\t\t\t}\n\t\t}\n\n\t\tthis.eachView = function (list, f) {\n\t\t\tfor (var i = 0, n = list.length; i < n; ++i) {\n\t\t\t\tvar view = this.getViewByID(list[i]);\n\t\t\t\tif (view) {\n\t\t\t\t\tf(view, list[i]);\n\t\t\t\t} else {\n\t\t\t\t\tlogger.warn('view', list[i], 'not found');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.hideViews = function (/* id1, id2, id3, ... */) {\n\t\t\tthis.eachView(arguments, function (view) { view.style.visible = false; });\n\t\t}\n\n\t\tthis.showViews = function (/* id1, id2, id3, ... */) {\n\t\t\tthis.eachView(arguments, function (view) { view.style.visible = true; });\n\t\t}\n\n\t\tthis.hideAllViews = function () {\n\t\t\tthis.traverse(function (view) { view.style.visible = false; });\n\t\t}\n\n\t\tthis.showAllViews = function () {\n\t\t\tthis.traverse(function (view) { view.style.visible = true; });\n\t\t}\n\n\t\tthis.hideViewRange = function (a, b) {\n\t\t\tvar range = [];\n\t\t\tfor (var i = a; i < b; ++i) {\n\t\t\t\trange.push(i);\n\t\t\t}\n\n\t\t\tthis.hideViews.apply(this, range);\n\t\t}\n\n\t\tthis.showViewRange = function (a, b) {\n\t\t\tvar range = [];\n\t\t\tfor (var i = a; i < b; ++i) {\n\t\t\t\trange.push(i);\n\t\t\t}\n\n\t\t\tthis.showViews.apply(this, range);\n\t\t}\n\t}));\n\n\tfunction stringify(value) {\n\t\tif (value === null) {\n\t\t\treturn 'null';\n\t\t} else if (typeof value == 'object') {\n\t\t\tif (isArray(value)) {\n\t\t\t\tvalue = value.slice(0);\n\t\t\t\tfor (var i = 0, n = value.length; i < n; ++i) {\n\t\t\t\t\tvalue[i] = stringify(value[i]);\n\t\t\t\t}\n\t\t\t\treturn '[' + value.join(', ') + ']';\n\t\t\t} else if (value.__class__) {\n\t\t\t\treturn '[object ' + value.__class__ + ']';\n\t\t\t} else {\n\t\t\t\treturn Object.prototype.toString.call(value);\n\t\t\t}\n\t\t} else {\n\t\t\treturn String(value);\n\t\t}\n\t}\n\n\tvar installed = false;\n\tvar conn = null;\n\tvar buffer = [];\n\tvar LOG_LOCK = false;\n\tvar timeout = null;\n\tvar timedout = false;\n\n\tfunction install() {\n\t\tjsio(\"import base\");\n\n\t\tvar oldLog = base.log;\n\n\t\t// kill connection\n\t\ttimeout = setTimeout(function() { timedout = true; }, 10000);\n\n\t\tbase.log = function() {\n\t\t\tif (!timedout && !LOG_LOCK) {\n\t\t\t\tLOG_LOCK = true; // prevent recursive loops if sendEvent decides to log stuff\n\n\t\t\t\t// convert arguments to strings\n\t\t\t\tvar n = arguments.length;\n\t\t\t\tvar args = new Array(n);\n\t\t\t\tfor (var i = 0; i < n; ++i) {\n\t\t\t\t\targs[i] = stringify(arguments[i]);\n\t\t\t\t}\n\n\t\t\t\t// buffer log lines\n\t\t\t\tif (!conn || !conn.isConnected()) {\n\t\t\t\t\tbuffer.push(args);\n\t\t\t\t} else {\n\t\t\t\t\t// flush logs\n\t\t\t\t\tif (buffer[0]) {\n\t\t\t\t\t\tfor (var i = 0, log; log = buffer[i]; ++i) {\n\t\t\t\t\t\t\tconn.sendEvent('LOG', log);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbuffer = [];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// send log\n\t\t\t\t\tconn.sendEvent('LOG', args);\n\t\t\t\t}\n\n\t\t\t\tLOG_LOCK = false;\n\t\t\t}\n\n\t\t\treturn oldLog.apply(this, arguments);\n\t\t};\n\n\t\tinstalled = true;\n\t}\n\n\tfunction flushBuffer() {\n\t\t// we timed out, so bail\n\t\tif (!buffer) { return conn.close(); }\n\n\t\t// if we buffered log messages, send them\n\t\tvar n = buffer.length;\n\t\tfor (var i = 0; i < n; ++i) {\n\t\t\tconn.sendEvent('LOG', buffer[i]);\n\t\t}\n\n\t\tbuffer = [];\n\t}\n\n\texports.getConn = function () { return conn; }\n\n\texports.connect = function (transport, opts) {\n\t\tlogger.log(\"debugLogger.connect\" + JSON.stringify(transport) + JSON.stringify(opts));\n\t\tif (!installed) { install(); }\n\n\t\tconn = new net.protocols.Cuppa();\n\n\t\tconn.onError = function(err) {\n\t\t\tlogger.log('log protocol error:', err);\n\t\t}\n\n\t\tconn.onConnect(function() {\n\t\t\tclearTimeout(timeout);\n\n\t\t\tconn.sendEvent(\"HANDSHAKE\", {\n\t\t\t\t\"type\": jsio.__env.name,\n\t\t\t\t\"appID\": CONFIG.appID,\n\t\t\t\t\"version\": CONFIG.version,\n\t\t\t\t\"title\": CONFIG.title,\n\t\t\t\t\"shortName\": CONFIG.shortName,\n\t\t\t\t\"userAgent\": navigator.userAgent,\n\t\t\t\t\"device\": NATIVE.device\n\t\t\t});\n\n\t\t\tflushBuffer();\n\n\t\t\tlogger.log('DEBUGGING CONNECTION MADE');\n\t\t});\n\n\t\tconn.onDisconnect(function() {\n\t\t\tlogger.log('DEBUGGING CONNECTION LOST');\n\t\t});\n\n\t\tconn.onRequest.subscribe('EVAL', this, function(req) {\n\t\t\ttry {\n\t\t\t\tvar value;\n\t\t\t\tif (GLOBAL.NATIVE && NATIVE.eval) {\n\t\t\t\t\tvalue = NATIVE.eval(req.args, \"[console]\");\n\t\t\t\t} else {\n\t\t\t\t\tvalue = window.eval(req.args, \"[console]\");\n\t\t\t\t}\n\n\t\t\t\treq.respond(stringify(value));\n\t\t\t} catch (e) {\n\t\t\t\treq.error(e.name + \": \" + e.message);\n\t\t\t}\n\t\t});\n\n\t\texports.handleInspectorRequests(conn);\n\t\tnet.connect(conn, transport, opts);\n\t}\n\n\texports.initLocalInspector = function () {\n\t\tvar conn = new net.protocols.Cuppa();\n\t\texports.handleInspectorRequests(conn);\n\t\t//we need to get the port this is serving on\n\t\tvar port = '__debug_timestep_inspector_' + window.location.port + '__';\n\t\tnet.connect(conn, 'postmessage', {win: window.parent, port: port});\n\t}\n\nOverlayRenderer=__class__;\tvar OverlayRenderer=OverlayRenderer(function OverlayRenderer(){return this.init&&this.init.apply(this,arguments)},function () {\n\t\t// store the views we need to render\n\t\tthis._highlightViewUID = null;\n\t\tthis.setHighlight = function (uid) { this._highlightViewUID = uid; }\n\n\t\tthis._selectedViewUID = null;\n\t\tthis.setSelected = function (uid) { this._selectedViewUID = uid; }\n\n\t\tvar tick = 0;\n\t\tvar maxColor = 255;\n\t\tvar minColor = 100;\n\t\t\n\t\t//render the highlighted view\n\t\tvar _now = +new Date();\n\t\tvar _t = 0;\n\t\tfunction renderHighlight (pos, ctx) {\n\t\t\tctx.save();\n\t\t\tctx.translate(pos.x, pos.y);\n\t\t\tctx.rotate(pos.r);\n\t\t\t\n\t\t\t// pulsate the blue\n\t\t\ttick += -(_now - (_now = new Date()));\n\n\t\t\tvar weight = (Math.sin(2 * Math.PI * tick / 1000) + 1) / 2;\n\t\t\tvar val = (weight * (maxColor - minColor)) + minColor | 0;\n\n\t\t\t\n\t\t\tvar color = '0,' + (val * .7 | 0) + ',' + (val | 0);\n\n\t\t\tctx.strokeStyle = 'rgba(' + color + ', 0.7)';\n\t\t\tctx.strokeRect(0, 0, pos.width, pos.height);\n\t\t\tctx.fillStyle = 'rgba(' + color + ', 0.6)';\n\t\t\tctx.fillRect(0, 0, pos.width, pos.height);\n\n\t\t\t//draw the cross hair\n\t\t\t//ctx.fillStyle = 'rgb(' + val + ',' + val + ',' + val +')';\n\t\t\tvar opacity = weight * (1 - 0.4) + 0.4;\n\t\t\tctx.fillStyle = 'rgba(255,255,255,' + (opacity.toFixed(2)) +')';\n\t\t\tctx.translate(pos.anchorX, pos.anchorY);\n\t\t\tctx.rotate(tick / 500);\n\n\t\t\tctx.fillRect(-0.5, -7, 1, 14);\n\t\t\tctx.fillRect(-7, -0.5, 14, 1);\n\n\t\t\tctx.restore();\n\t\t}\n\n\t\tfunction renderSelected(pos, ctx) {\n\t\t\tctx.save();\n\t\t\tctx.translate(pos.x, pos.y);\n\t\t\tctx.rotate(pos.r);\n\t\t\tctx.strokeStyle = \"red\";\n\t\t\tctx.lineWidth = 1;\n\t\t\tctx.strokeRect(-0.5, -0.5, pos.width + 1, pos.height + 1);\n\t\t\tctx.restore();\n\t\t}\n\t\t\n\t\tthis.render = function (ctx) {\n\t\t\t//render highlighted views\n\t\t\tif (this._highlightViewUID !== null) {\n\t\t\t\tvar view = _DEBUG.getViewByID(this._highlightViewUID);\n\t\t\t\tvar pos = view && view.getPosition();\n\t\t\t\tif (pos) renderHighlight(pos, ctx);\n\t\t\t}\n\n\t\t\t//render selected views\n\t\t\tif (this._selectedViewUID !== null) {\n\t\t\t\tvar view = _DEBUG.getViewByID(this._selectedViewUID);\n\t\t\t\tvar pos = view && view.getPosition();\n\t\t\t\tif (pos) renderSelected(pos, ctx);\n\t\t\t}\n\t\t}\n\t});\n\n\texports._overlay = new OverlayRenderer();\n\n\texports.handleInspectorRequests = function (conn) {\n\n\t\t// mapping for reading/writing style properties on a view\n\t\t// map: inspector id -> style property\n\t\tvar _propMap = {\n\t\t\trelX: 'x',\n\t\t\trelY: 'y',\n\t\t\trelR: 'r',\n\t\t\trelWidthPercent: 'widthPercent',\n\t\t\trelHeightPercent: 'heightPercent',\n\t\t\trelWidth: 'width',\n\t\t\trelHeight: 'height',\n\t\t\trelScale: 'scale',\n\t\t\topacity: 'opacity',\n\t\t\tzIndex: 'zIndex',\n\t\t\tvisible: 'visible',\n\t\t\tanchorX: 'anchorX',\n\t\t\tanchorY: 'anchorY',\n\t\t\toffsetX: 'offsetX',\n\t\t\toffsetY: 'offsetY',\n\t\t\tclip: 'clip',\n\t\t\tlayout: 'layout',\n\t\t\tinLayout: 'inLayout',\n\t\t\ttop: 'top',\n\t\t\tleft: 'left',\n\t\t\tbottom: 'bottom',\n\t\t\tright: 'right',\n\t\t\tflex: 'flex',\n\t\t\tdirection: 'direction',\n\t\t\tjustifyContent: 'justifyContent',\n\t\t\torder: 'order',\n\n\t\t\tlayoutWidth: 'layoutWidth',\n\t\t\tlayoutHeight: 'layoutHeight',\n\t\t\tminWidth: 'minWidth',\n\t\t\tminHeight: 'minHeight',\n\t\t\tmaxWidth: 'maxWidth',\n\t\t\tmaxHeight: 'maxHeight',\n\t\t};\n\nDebugInputHandler=__class__;\t\tvar DebugInputHandler=DebugInputHandler(function DebugInputHandler(){return this.init&&this.init.apply(this,arguments)},function () {\n\n\t\t\tjsio(\"import device\");\n\t\t\tvar _simulateMouseMove = device.simulating && document.body.addEventListener;\n\n\t\t\tthis.init = function (conn) {\n\t\t\t\tthis.conn = conn;\n\t\t\t\tthis.onMouseMoveCapture = bind(this, this.onMouseMoveCapture);\n\t\t\t\tthis.setShiftDown = bind(this, this.setShiftDown);\n\t\t\t\tthis.onContextMenu = bind(this, this.onContextMenu);\n\n\t\t\t\tif (_simulateMouseMove) {\n\t\t\t\t\twindow.addEventListener('mousemove', this.onMouseMoveCapture, true);\n\n\t\t\t\t}\n\n\t\t\t\t//exports._overlay.setSize(GC.app.view.style.width, GC.app.view.style.height);\n\n\t\t\t\t//hacky hack to determine if the shift was set or not\n\t\t\t\twindow.addEventListener('mousedown', this.setShiftDown, true);\n\t\t\t\twindow.addEventListener('contextmenu', this.onContextMenu, true);\n\n\t\t\t\tGC.app.view.subscribe('InputMoveCapture', this, 'onInputMoveCapture');\n\t\t\t\t//GC.app.view.subscribe('InputStartCapture', this, 'onInputSelectCapture');\n\t\t\t}\n\n\t\t\tthis.setShiftDown = function (e) {\n\t\t\t\tif (e.which === 3 || e.button === 2) {\n\t\t\t\t\te.stopPropagation();\n\t\t\t\t\te.preventDefault();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tthis._shiftDown = !!e.shiftKey;\n\n\t\t\t\tif (this._shiftDown) {\n\t\t\t\t\tthis.onInputSelectCapture(e);\n\t\t\t\t\te.stopPropagation();\n\t\t\t\t\te.preventDefault();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tjsio(\"import event.input.dispatch as dispatch\");\n\n\t\t\tthis.onContextMenu = function (e) {\n\t\t\t\tvar data = {\n\t\t\t\t\tpt: {x: e.pageX, y: e.pageY}\n\t\t\t\t};\n\n\t\t\t\t//get the views under the pointer\n\t\t\t\tvar clickEvt = {pt: [], trace: [], depth: 0};\n\t\t\t\tvar clickPt = new Point(e.pageX, e.pageY);\n\t\t\t\tdispatch.traceEvt(GC.app.view, clickEvt, clickPt);\n\n\t\t\t\tif (!clickEvt.trace.length) return;\n\t\t\t\tdata.active = clickEvt.trace[0].uid;\n\n\t\t\t\t//get the views under the pointer\n\t\t\t\tvar mockEvt = {pt: [], trace: [], depth: 0};\n\t\t\t\tvar mockPt = new Point(e.pageX, e.pageY);\n\n\t\t\t\tthis.traceEvt(GC.app.view, mockEvt, mockPt);\n\n\t\t\t\tdata.trace = [];\n\t\t\t\t//convert to small objects\n\t\t\t\tfor (var i = mockEvt.trace.length - 1, item; item = mockEvt.trace[i]; --i) {\n\t\t\t\t\tdata.trace.push({\n\t\t\t\t\t\tuid: item.view.uid,\n\t\t\t\t\t\ttag: item.view.getTag(),\n\t\t\t\t\t\tdepth: item.depth\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tthis.conn.sendEvent('INPUT_TRACE', data);\n\n\t\t\t\te.stopPropagation();\n\t\t\t\te.preventDefault();\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tthis.destroy = function () {\n\t\t\t\tif (_simulateMouseMove) {\n\t\t\t\t\twindow.removeEventListener('mousedown', this.onMouseDownCapture, true);\n\t\t\t\t}\n\n\t\t\t\twindow.removeEventListener('mousedown', this.setShiftDown, true);\n\t\t\t\tGC.app.view.unsubscribe('InputMoveCapture', this, 'onInputMoveCapture');\n\t\t\t\t//GC.app.view.unsubscribe('InputStartCapture', this, 'onInputSelectCapture');\n\t\t\t}\n\n\t\t\tthis.onInputMoveCapture = function (evt, pt, allEvt, allPt) {\n\t\t\t\tvar trace = [];\n\t\t\t\t\n\t\t\t\t//loop backwards through the trace\n\t\t\t\tfor (var i = evt.trace.length - 1, view; view = evt.trace[i]; --i) {\n\t\t\t\t\ttrace.push(view.uid);\n\t\t\t\t\t\n\t\t\t\t\tvar superview = view.getSuperview();\n\t\t\t\t\twhile (superview && superview != evt.trace[i + 1]) {\n\t\t\t\t\t\ttrace.push(superview.uid);\n\t\t\t\t\t\tsuperview = superview.getSuperview();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar data = {\n\t\t\t\t\tx: pt.x,\n\t\t\t\t\ty: pt.y,\n\t\t\t\t\ttrace: trace\n\t\t\t\t};\n\n\t\t\t\tthis.conn.sendEvent('INPUT_MOVE', data);\n\t\t\t}\n\n\t\t\tthis.onInputSelectCapture = function (e) {\n\t\t\t\t//only send event if shift click\n\t\t\t\t\n\n\t\t\t\tvar evt = {pt: [], trace: [], depth: 0};\n\t\t\t\tvar pt = new Point(e.pageX, e.pageY);\n\t\t\t\tdispatch.traceEvt(GC.app.view, evt, pt);\n\n\t\t\t\tvar trace = [];\n\t\t\t\tfor (var i = evt.trace.length - 1, view; view = evt.trace[i]; --i) {\n\t\t\t\t\ttrace.push(view.uid);\n\n\t\t\t\t\tvar superview = view.getSuperview();\n\t\t\t\t\twhile (superview && superview != evt.trace[i + 1]) {\n\t\t\t\t\t\ttrace.push(superview.uid);\n\t\t\t\t\t\tsuperview = superview.getSuperview();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar data = {\n\t\t\t\t\tx: pt.x,\n\t\t\t\t\ty: pt.y,\n\t\t\t\t\ttrace: trace\n\t\t\t\t};\n\t\t\t\t\n\t\t\t\tthis.conn.sendEvent('INPUT_SELECT', data);\n\t\t\t}\n\n\t\t\t\n\n\t\t\tthis.traceEvt = function(view, evt, pt, depth) {\n\t\t\t\tdepth = depth || 0;\n\n\t\t\t\tvar localPt = view.style.localizePoint(new Point(pt));\n\t\t\t\t\n\t\t\t\t//if the point is contained add it to the trace\n\t\t\t\tif (view.containsLocalPoint(localPt)) { \n\t\t\t\t\tevt.trace.unshift({view: view, depth: depth});\n\t\t\t\t\tevt.pt[view.uid] = localPt; \n\t\t\t\t}\n\n\t\t\t\tvar subviews = view.getSubviews();\n\t\t\t\tfor (var i = subviews.length - 1; i >= 0; --i) {\n\t\t\t\t\tif (subviews[i].style.visible) {\n  \t\t\t\t\t\tthis.traceEvt(subviews[i], evt, localPt, depth + 1);\n  \t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (subviews.length === 0) {\n\t\t\t\t\tevt.target = view;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.onMouseMoveCapture = function (e) {\n\t\t\t\t//$.stopEvent(e);\n\t\t\t\t\n\t\t\t\t//get the event to the active target\n\t\t\t\tvar mockEvt = {pt: [], trace: [], depth: 0};\n\t\t\t\tvar mockPt = new Point(e.pageX, e.pageY);\n\t\t\t\tdispatch.traceEvt(GC.app.view, mockEvt, mockPt);\n\n\t\t\t\tthis.onInputMoveCapture(mockEvt, mockPt);\n\t\t\t}\n\t\t});\n\n\t\tconn.onConnect(this, function () {\n\t\t\t// connected is not enough, if there was an error,\n\t\t\t// the app might not exist and we shouldn't try\n\t\t\t// to initialize the remote inspector\n\t\t\tif (GC.app) {\n\t\t\t\tconn.sendEvent('APP_READY', {uid: GC.app.view.uid});\n\n\t\t\t\tGC.app.engine.unsubscribe('Render', this);\n\t\t\t\tGC.app.engine.subscribe('Render', this._overlay, 'render');\n\t\t\t}\n\t\t});\n\n\t\tconn.onEvent.subscribe('BATCH', this, function (evt) {\n\t\t\tvar i;\n\t\t\tfor (i in evt.args) {\n\t\t\t\tconsole.log(evt.args[i].name, evt.args[i].args)\n\t\t\t\tconn.onEvent.publish(evt.args[i].name, evt.args[i].args);\n\t\t\t}\n\t\t});\n\n\t\tconn.onEvent.subscribe('SET_NAME', this, function (evt) {\n\t\t\tGLOBAL._name = evt.args.name;\n\t\t\tlogging.setPrefix(evt.args.name + ': ');\n\t\t});\n\n\t\tvar _homeScreen = false;\n\t\tconn.onEvent.subscribe('HOME_BUTTON', this, function () {\n\t\t\tif (!GC) return;\n\n\t\t\tvar app = GC.app;\n\n\t\t\tif (this._homeScreen) {\n\t\t\t\tGC._onShow && GC._onShow();\n\t\t\t\tapp.engine.resume();\n\t\t\t} else {\n\t\t\t\tGC._onHide && GC._onHide();\n\t\t\t\tapp.engine.pause();\n\n\t\t\t\tvar canvas = document.getElementsByTagName('canvas');\n\t\t\t\tif (canvas.length) {\n\t\t\t\t\tcanvas = canvas[0];\n\t\t\t\t\tif (canvas.getContext) {\n\t\t\t\t\t\tvar ctx = canvas.getContext('2d');\n\t\t\t\t\t\tctx.fillStyle = '#000000';\n\t\t\t\t\t\tctx.fillRect(0, 0, canvas.width, canvas.height);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._homeScreen ^= true;\n\t\t});\n\n\t\tconn.onEvent.subscribe('BACK_BUTTON', this, function (evt) {\n\t\t\tGLOBAL.NATIVE.onBackButton();\n\t\t});\n\n\t\tconn.onRequest.subscribe('SCREENSHOT', this, function (req) {\n\t\t\tvar canv = document.getElementsByTagName('canvas')[0]\n\t\t\treq.respond({\n\t\t\t\twidth: canv.width,\n\t\t\t\theight: canv.height,\n\t\t\t\tcanvasImg: canv.toDataURL('image/png')\n\t\t\t});\n\t\t});\n\n\t\tconn.onEvent.subscribe('MUTE', this, function (evt) {\n\t\t\tGLOBAL.ACCESSIBILITY.mute(evt.args.shouldMute);\n\t\t});\n\n\t\tvar _paused = false;\n\t\tconn.onEvent.subscribe('PAUSE', this, function () {\n\t\t\tif (!GC) return;\n\t\t\tvar app = GC.app;\n\n\t\t\tif (_paused) {\n\t\t\t\tapp.engine.resume();\n\t\t\t} else {\n\t\t\t\tapp.engine.pause();\n\t\t\t}\n\t\t\t_paused ^= true;\n\t\t});\n\n\t\tconn.onEvent.subscribe('STEP', this, function () {\n\t\t\tif (!GC) return;\n\t\t\tvar app = GC.app;\n\n\t\t\tapp.engine.stepFrame();\n\t\t\t_paused = true;\n\t\t});\n\n\t\tvar _input = null;\n\t\tconn.onRequest.subscribe('ADD_MOUSE_EVT', this, function (req) {\n\t\t\tif (!_input) { _input = new DebugInputHandler(conn); }\n\t\t\treq.respond();\n\t\t});\n\n\t\tconn.onRequest.subscribe('REMOVE_MOUSE_EVT', this, function (req) {\n\t\t\tif (_input) { _input.destroy(); }\n\t\t\treq.respond();\n\t\t});\n\n\t\tconn.onEvent.subscribe('SET_HIGHLIGHT', this, function (req) {\n\t\t\tthis._overlay.setHighlight(req.args.uid);\n\t\t\t//this._overlay.render();\n\t\t});\n\n\t\tconn.onEvent.subscribe('SET_SELECTED', this, function (req) {\n\t\t\tthis._overlay.setSelected(req.args.uid);\n\t\t\t//this._overlay.render();\n\t\t});\n\n\t\tfunction findBetterTag (view) {\n\t\t\tvar parent = view.getSuperview();\n\t\t\tfor (var key in parent) {\n\t\t\t\tif (parent[key] === view) {\n\t\t\t\t\treturn key;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\tconn.onRequest.subscribe('GET_ROOT_UID', this, function (req) {\n\t\t\treq.respond({uid: GC.app.view.uid});\n\t\t});\n\n\t\tconn.onRequest.subscribe('GET_VIEW', this, function (req) {\n\t\t\tvar view = _DEBUG.getViewByID(req.args.uid);\n\t\t\tif (!view) {\n\t\t\t\treq.error('no view with id' + req.args.uid, {VIEW_NOT_FOUND: true});\n\t\t\t} else {\n\t\t\t\tvar sup = view.getSuperview();\n\n\t\t\t\t//create the optimal tag\n\t\t\t\tvar tag = view.getTag && view.getTag() || view.toString();\n\t\t\t\tvar betterTag = findBetterTag(view);\n\t\t\t\tif (betterTag) tag = betterTag + \":\" + tag;\n\n\t\t\t\treq.respond({\n\t\t\t\t\tuid: view.uid,\n\t\t\t\t\tsuperviewID: sup && sup.uid,\n\t\t\t\t\ttag: tag,\n\t\t\t\t\tsubviewIDs: view.getSubviews().map(function (view) { return view.uid; })\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\tconn.onRequest.subscribe('REPLACE_IMAGE', this, function (req) {\n\t\t\tvar args = req.args;\n\t\t\tvar imgData = args.imgData;\n\t\t\tvar uid = args.uid;\n\n\t\t\tvar view = _DEBUG.getViewByID(uid);\n\t\t\tvar newImg = new Image();\n\n\t\t\tnewImg._srcImg.addEventListener(\"load\", function() {\n\t\t\t\tvar map = newImg._map;\t\n\t\t\t\tmap.width = newImg._srcImg.width,\n\t\t\t\tmap.height = newImg._srcImg.height,\n\t\t\t\tmap.x = 0;\n\t\t\t\tmap.y = 0;\n\t\t\t\tview.setImage(newImg);\n\t\t\t\tview.needsRepaint();\n\t\t\t}, false);\n\t\t\n\t\t\tnewImg._srcImg.src = imgData;\n\t\t});\n\n\t\tconn.onRequest.subscribe('GET_VIEW_PROPS', this, function (req) {\n\t\t\tvar args = req.args;\n\t\t\tvar view = _DEBUG.getViewByID(args.uid);\n\t\t\tif (!view) {\n\t\t\t\treturn req.error(\"VIEW_NOT_FOUND\");\n\t\t\t}\n\n\t\t\tvar s = view.style;\n\t\t\tvar p = view.getPosition();\n\t\t\tvar layout = view.__layout;\n\t\t\tvar ret = {};\n\t\t\tfor (var key in _propMap) {\n\t\t\t\tret[key] = s[_propMap[key]];\n\t\t\t}\n\n\t\t\tmerge(ret, {\n\t\t\t\tabsX: p.x,\n\t\t\t\tabsY: p.y,\n\t\t\t\tabsR: p.r,\n\t\t\t\tabsWidth: p.width,\n\t\t\t\tabsHeight: p.height,\n\t\t\t\tabsScale: p.scale,\n\n\t\t\t\tsubviews: layout && (typeof layout.getSubviews == 'function') && layout.getSubviews().length,\n\t\t\t\tdirection: layout && (typeof layout.getDirection == 'function') && layout.getDirection(),\n\t\t\t\tpadding: s.padding && s.padding.toString()\n\t\t\t});\n\n\t\t\tfor (var key in ret) {\n\t\t\t\tif (ret[key] == undefined) {\n\t\t\t\t\tret[key] = '-';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tret.isImageView = view instanceof ImageView;\n\n\t\t\tif (ret.isImageView) {\n\t\t\t\tret.imagePath = view._opts.image || (view._img && view._img._map && view._img._map.url);\n\t\t\t\tif (ret.imagePath && ret.imagePath._map) {\n\t\t\t\t\tret.imagePath = ret.imagePath._map.url;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tret.uuid = args.uid;\n\n\t\t\tret.description = (view.constructor.name || 'View') + ' ' + args.uid + '\\n' + view.getTag();\n\n\t\t\treq.respond(ret);\n\t\t});\n\n\t\tconn.onRequest.subscribe('SET_VIEW_PROP', this, function (req) {\n\t\t\tvar args = req.args;\n\t\t\tvar view = _DEBUG.getViewByID(args.uid);\n\t\t\tif (!view) {\n\t\t\t\treturn req.error(\"VIEW_NOT_FOUND\");\n\t\t\t}\n\n\t\t\tvar key = args.key;\n\t\t\tvar value = args.value;\n\t\t\tif (key in _propMap) {\n\t\t\t\tview.style[_propMap[key]] = value;\n\t\t\t} else {\n\t\t\t\tswitch (key) {\n\t\t\t\t\tcase 'absX': break;\n\t\t\t\t\tcase 'absY': view.style.y = value; break;\n\t\t\t\t\tcase 'absWidth': view.style.width = value; break;\n\t\t\t\t\tcase 'absHeight': view.style.height = value; break;\n\t\t\t\t\tcase 'absScale': view.style.scale = value; break;\n\t\t\t\t\tcase 'padding': view.style.padding = value; break;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tvar _pollTimer = null;\n\t\tvar _pollView = null;\n\n\t\tconn.onEvent.subscribe('POLL_VIEW_POSITION', this, function (evt) {\n\n\t\t\tfunction poll() {\n\t\t\t\tif (_pollView) {\n\t\t\t\t\tvar eventData = _pollView.getPosition();\n\t\t\t\t\teventData.uid = _pollView.uid;\n\t\t\t\t\t\n\t\t\t\t\tconn.sendEvent('POLL_VIEW_POSITION', eventData);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_pollView = _DEBUG.getViewByID(evt.args.uid);\n\t\t\tif (!_pollTimer && _pollView) {\n\t\t\t\t_pollTimer = setInterval(poll, 100);\n\t\t\t}\n\n\t\t\tif (!_pollView) {\n\t\t\t\tclearInterval(poll);\n\t\t\t\t_pollTimer = null;\n\t\t\t}\n\t\t});\n\t}\n}\n","pre":true},"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/net.js":{"path":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/net.js","friendlyPath":"net","directory":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/","filename":"net.js","baseMod":"net","basePath":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio","src":"jsio('import net.env');\njsio('import std.JSON as JSON');\n\nJSON.createGlobal(); // create the global JSON object if it doesn't already exist\n\n/**\n * @namespace\n */\n\nexports.listen = function(server, transportName, opts) {\n\tif (!transportName) {\n\t\tthrow logger.error('No transport provided for net.listen');\n\t}\n\t\n\tvar ctor = typeof transportName == 'string' ? net.env.getListener(transportName) : transportName,\n\t\tlistener = new ctor(server, opts);\n\n\tlistener.listen();\n\treturn listener;\n}\n\nexports.connect = function(protocolInstance, transportName, opts) {\n\tvar ctor = typeof transportName == 'string' ? net.env.getConnector(transportName) : transportName,\n\t\tconnector = new ctor(protocolInstance, opts);\n\tconnector.connect();\n\treturn connector;\n}\n\nexports.quickServer = function(protocolClass) {\n\tjsio('import net.interfaces');\n\treturn new net.interfaces.Server(protocolClass);\n}\n","pre":true},"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/net/env/browser/csp.js":{"path":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/net/env/browser/csp.js","friendlyPath":"net.env.browser.csp","directory":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/net/env/browser/","filename":"csp.js","src":"jsio('import net.interfaces');\njsio('from net.csp.client import CometSession');\njsio('import std.utf8 as utf8');\n\n/**\n * @extends net.interfaces.Connector\n */\nexports.Connector=__class__;exports.Connector=exports.Connector(function exports_Connector(){return this.init&&this.init.apply(this,arguments)},net.interfaces.Connector, function() {\n\tthis.connect = function() {\n\t\tthis._state = net.interfaces.STATE.CONNECTING;\n\t\t\n\t\tvar conn = new CometSession();\n\t\tconn.onconnect = bind(this, 'cometSessionOnConnect', conn);\n\t\tconn.ondisconnect = bind(this, 'onDisconnect');\n\t\t\n\t\tlogger.debug('opening the connection');\n\t\tif (!this._opts.encoding) { this._opts.encoding = 'plain'; }\n\t\tconn.connect(this._opts.url, this._opts);//{encoding: 'plain'});\n\t}\n\t\n\tthis.cometSessionOnConnect = function(conn) {\n\t\tlogger.debug('conn has opened');\n\t\tthis.onConnect(new Transport(conn));\n\t}\n});\n\nTransport=__class__;var Transport=Transport(function Transport(){return this.init&&this.init.apply(this,arguments)},net.interfaces.Transport, function() {\n\tthis.init = function(conn) {\n\t\tthis._conn = conn;\n\t}\n\t\n\tthis.makeConnection = function(protocol) {\n\t\tthis._conn.onread = bind(protocol, 'dataReceived');\n\t}\n\t\n\tthis.write = function(data) {\n\t\tthis._conn.write(data);\n\t}\n\t\n\tthis.loseConnection = function(protocol) {\n\t\tthis._conn.close();\n\t}\n});\n","pre":true},"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/net/interfaces.js":{"path":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/net/interfaces.js","friendlyPath":"net.interfaces","directory":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/net/","filename":"interfaces.js","src":"// Sort of like a twisted protocol\njsio('import net');\njsio('import lib.Enum as Enum');\n\nvar ctx = jsio.__env.global;\n\nexports.Protocol=__class__;exports.Protocol=exports.Protocol(function exports_Protocol(){return this.init&&this.init.apply(this,arguments)},function() {\n\tthis.connectionMade = function(isReconnect) {}\n\tthis.dataReceived = function(data) {}\n\tthis.connectionLost = function(reason) {}\n\t\n\tthis._connectionMade = function() {\n\t\tthis._isConnected = true;\n\t\tthis.connectionMade.apply(this, arguments);\n\t}\n\n\tthis._connectionLost = function() {\n\t\tthis._isConnected = true;\n\t\tthis.connectionLost.apply(this, arguments);\n\t}\n\n\tthis._isConnected = false;\n\tthis.isConnected = function() {\n\t\treturn !!this._isConnected;\n\t}\n\t\n\t\n});\n\nexports.Client=__class__;exports.Client=exports.Client(function exports_Client(){return this.init&&this.init.apply(this,arguments)},function() {\n\tthis.init = function(protocol) {\n\t\tthis._protocol = protocol;\n\t}\n\t\n\tthis.connect = function(transportName, opts) {\n\t\tthis._remote = new this._protocol();\n\t\tthis._remote._client = this;\n\t\tnet.connect(this._remote, transportName, opts);\n\t}\n});\n\n// Sort of like a twisted factory\nexports.Server=__class__;exports.Server=exports.Server(function exports_Server(){return this.init&&this.init.apply(this,arguments)},function() {\n\tthis.init = function(protocolClass) {\n\t\tthis._protocolClass = protocolClass;\n\t}\n\n\tthis.buildProtocol = function() {\n\t\treturn new this._protocolClass();\n\t}\n\t\n\tthis.listen = function(how, port) {\n\t\treturn net.listen(this, how, port);\n\t}\n});\n\nexports.Transport=__class__;exports.Transport=exports.Transport(function exports_Transport(){return this.init&&this.init.apply(this,arguments)},function() {\n\tthis._encoding = 'plain'\n\tthis.write = function(data, encoding) {\n\t\tthrow new Error(\"Not implemented\");\n\t}\n\tthis.getPeer = function() {\n\t\tthrow new Error(\"Not implemented\");\n\t}\n\tthis.setEncoding = function(encoding) {\n\t\tthis._encoding = encoding;\n\t}\n\tthis.getEncoding = function() {\n\t\treturn this._encoding;\n\t}\n});\n\nexports.Listener=__class__;exports.Listener=exports.Listener(function exports_Listener(){return this.init&&this.init.apply(this,arguments)},function() {\n\tthis.init = function(server, opts) {\n\t\tthis._server = server;\n\t\tthis._opts = opts || {};\n\t}\n\t\n\tthis.onConnect = function(transport) {\n\t\t//try {\n\t\t\tvar p = this._server.buildProtocol();\n\t\t\tp.transport = transport;\n\t\t\tp.server = this._server;\n\t\t\ttransport.protocol = p;\n\t\t\ttransport.makeConnection(p);\n\t\t\tp._connectionMade();\n\t\t//} catch(e) {\n\t\t//\tlogger.error(e);\n\t\t//}\n\t}\n\t\n\tthis.listen = function() { throw new Error('Abstract class'); }\n\tthis.stop = function() {}\n});\n\nexports.STATE = Enum('INITIAL', 'DISCONNECTED', 'CONNECTING', 'CONNECTED');\nexports.Connector=__class__;exports.Connector=exports.Connector(function exports_Connector(){return this.init&&this.init.apply(this,arguments)},function() {\n\tthis.init = function(protocol, opts) {\n\t\tthis._protocol = protocol;\n\t\tthis._opts = opts;\n\t\tthis._state = exports.STATE.INITIAL;\n\t}\n\t\n\tthis.getState = function() { return this._state; }\n\t\n\tthis.onConnect = function(transport) {\n\t\tthis._state = exports.STATE.CONNECTED;\n\n\t\ttransport.makeConnection(this._protocol);\n\t\tthis._protocol.transport = transport;\n\t\ttry {\n\t\t\tthis._protocol._connectionMade();\n\t\t} catch(e) {\n\t\t\tthrow logger.error(e);\n\t\t}\n\t}\n\t\n\tthis.onDisconnect = function(err) {\n\t\tvar wasConnected = this._state == exports.STATE.CONNECTED;\n\t\tthis._state = exports.STATE.DISCONNECTED;\n\t\t\n\t\ttry {\n\t\t\tthis._protocol._connectionLost(err, wasConnected);\n\t\t} catch(e) {\n\t\t\tthrow logger.error(e);\n\t\t}\n\t}\n\t\n\tthis.getProtocol = function() { return this._protocol; }\n});\n","pre":true},"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/net/csp/client.js":{"path":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/net/csp/client.js","friendlyPath":"net.csp.client","directory":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/net/csp/","filename":"client.js","src":"jsio('import std.base64 as base64');\njsio('import std.utf8 as utf8');\njsio('import std.uri as uri'); \njsio('import net.errors as errors');\njsio('import .transports');\njsio('import lib.Enum as Enum');\n\nvar READYSTATE = exports.READYSTATE = Enum({\n\tINITIAL: 0,\n\tCONNECTING: 1,\n\tCONNECTED: 2,\n\tDISCONNECTING: 3,\n\tDISCONNECTED:  4\n});\n\n\nexports.CometSession=__class__;exports.CometSession=exports.CometSession(function exports_CometSession(){return this.init&&this.init.apply(this,arguments)},function(supr) {\n\tvar id = 0;\n\tvar kDefaultBackoff = 50;\n\tvar kDefaultTimeoutInterval = 45000;\n\tvar kDefaultHandshakeTimeout = 10000;\n\tthis.init = function() {\n\t\tthis._id = ++id;\n\t\tthis._url = null;\n\t\tthis.readyState = READYSTATE.INITIAL;\n\t\tthis._sessionKey = null;\n\t\tthis._transport = null;\n\t\tthis._options = null;\n\t\t\n\t\tthis._utf8ReadBuffer = \"\";\n\t\tthis._writeBuffer = \"\";\n\t\t\n\t\tthis._packetsInFlight = null;\n\t\tthis._lastEventId = null;\n\t\tthis._lastSentId = null;\n\t\t\n\t\tthis._handshakeLater = null;\n\t\tthis._handshakeBackoff = kDefaultBackoff;\n\t\tthis._handshakeRetryTimer = null;\n\t\tthis._handshakeTimeoutTimer = null;\n\n\t\tthis._timeoutTimer = null;\n\n\t\t\n\t\tthis._writeBackoff = kDefaultBackoff;\n\t\tthis._cometBackoff = kDefaultBackoff;\n\t\t\n\t\tthis._nullInBuffer = false;\n\t\tthis._nullInFlight= false;\n\t\tthis._nullSent = false;\n\t\tthis._nullReceived = false;\n\t}\n\t\n\t\n\tthis.setEncoding = function(encoding) {\n\t\tif (encoding == this._options.encoding) { \n\t\t\treturn; \n\t\t}\n\t\tif (encoding != 'utf8' && encoding != 'plain') {\n\t\t\tthrow new errors.InvalidEncodingError();\n\t\t}\n\t\tif (encoding == 'plain' && this._buffer) {\n\t\t\tvar buffer = this._utf8ReadBuffer;\n\t\t\tthis._utf8ReadBuffer = \"\";\n\t\t\tthis._doOnRead(buffer);\n\t\t}\n\t\tthis._options.encoding = encoding;\n\t}\n\n\n\tthis.connect = function(url, options) {\n\t\tthis._url = url.replace(/\\/$/,'');\n\t\tthis._options = options || {};\n\t\t\n\t\tthis._options.encoding = this._options.encoding || 'utf8';\n\t\tthis.setEncoding(this._options.encoding); // enforce encoding constraints\n\t\t\n\t\tthis._options.connectTimeout = this._options.connectTimeout || kDefaultHandshakeTimeout;\n\t\t\n\t\tvar transportClass = transports.chooseTransport(url, this._options);\n\t\tthis._transport = new transportClass();\n\t\t\n\t\tthis._transport.handshakeFailure = bind(this, this._handshakeFailure);\n\t\tthis._transport.handshakeSuccess = bind(this, this._handshakeSuccess);\n\t\t\n\t\tthis._transport.cometFailure = bind(this, this._cometFailure);\n\t\tthis._transport.cometSuccess = bind(this, this._cometSuccess);\n\t\t\n\t\tthis._transport.sendFailure = bind(this, this._writeFailure);\n\t\tthis._transport.sendSuccess = bind(this, this._writeSuccess);\n\t\tthis.readyState = READYSTATE.CONNECTING;\n\t\tthis._transport.handshake(this._url, this._options);\n\t\t\n\t\tthis._handshakeTimeoutTimer = setTimeout(bind(this, this._handshakeTimeout), \n\t\t\tthis._options.connectTimeout);\n\t}\n\n\tthis.write = function(data, encoding) {\n\t\tif (this.readyState != READYSTATE.CONNECTED) {\n\t\t\tthrow new errors.ReadyStateError();\n\t\t}\n\t\tencoding = encoding || this._options.encoding || 'utf8';\n\t\tif (encoding == 'utf8') {\n\t\t\tdata = utf8.encode(data);\n\t\t}\n\t\tthis._writeBuffer += data;\n\t\tthis._doWrite();\n\t}\n\t\n\t// Close due to protocol error\n\tthis._protocolError = function(msg) {\n\t\tlogger.debug('_protocolError', msg);\n\t\t// Immediately fire the onclose\n\t\t// send a null packet to the server\n\t\t// don't wait for a null packet back.\n\t\tthis.readyState = READYSTATE.DISCONNECTED;\n\t\tthis._doWrite(true);\n\t\tthis._doOnDisconnect(new errors.ServerProtocolError(msg));\n\t}\n\t\n\tthis._receivedNullPacket = function() {\n\t\tlogger.debug('_receivedNullPacket');\n\t\t// send a null packet back to the server\n\t\tthis._receivedNull = true;\n\t\t\n\t\t// send our own null packet back. (maybe)\n\t\tif (!(this._nullInFlight || this._nullInBuffer || this._nullSent)) {\n\t\t\tthis.readyState = READYSTATE.DISCONNECTING;\n\t\t\tthis._doWrite(true);\n\t\t}\n\t\telse {\n\t\t\tthis.readyState = READYSTATE.DISCONNECTED;\n\t\t}\n\t\t\n\t\t// fire an onclose\n\t\tthis._doOnDisconnect(new errors.ConnectionClosedCleanly());\n\n\t}\n\t\n\tthis._sentNullPacket = function() {\n\t\tlogger.debug('_sentNullPacket');\n\t\tthis._nullSent = true;\n\t\tif (this._nullSent && this._nullReceived) {\n\t\t\tthis.readyState = READYSTATE.DISCONNECTED;\n\t\t}\n\t}\n\t\n\t\n\t// User Calls close\n\tthis.close = function(err) {\n\t\tlogger.debug('close called', err, 'readyState', this.readyState);\n\n\t\t// \n\t\tswitch(this.readyState) {\n\t\t\tcase READYSTATE.CONNECTING:\n\t\t\t\tclearTimeout(this._handshakeRetryTimer);\n\t\t\t\tclearTimeout(this._handshakeTimeoutTimer);\n\t\t\t\tthis.readyState = READYSTATE.DISCONNECTED;\n\t\t\t\tthis._doOnDisconnect(err);\n\t\t\t\tbreak;\n\t\t\tcase READYSTATE.CONNECTED:\n\t\t\t\tthis.readyState = READYSTATE.DISCONNECTING;\n\t\t\t\tthis._doWrite(true);\n\t\t\t\tclearTimeout(this._timeoutTimer);\n\t\t\t\tbreak;\n\t\t\tcase READYSTATE.DISCONNECTED:\n\t\t\t\tthrow new errors.ReadyStateError(\"Session is already disconnected\");\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\t\n\t\tthis._opened = false; // what is this used for???\n\t\tthis.readyState = READYSTATE.DISCONNECTED;\n\t\t\n\t\tthis._doOnDisconnect(err);\n\t\tthis._sessionKey = null;\n\t}\n\t\n\tthis._handshakeTimeout = function() {\n\t\tlogger.debug('handshake timeout');\n\t\tthis._handshakeTimeoutTimer = null;\n\t\tclearTimeout(this._handshakeRetryTimer);\n\t\tif (this.readyState == READYSTATE.CONNECTING) {\n\t\t\tthis.readyState = READYSTATE.DISCONNECTED;\n\t\t}\n\t\t\n\t\tthis._doOnDisconnect(new errors.ServerUnreachable());\n\t}\n\t\n\tthis._handshakeSuccess = function(data) {\n\t\tlogger.debug('handshake success', data);\n\t\tif (this.readyState != READYSTATE.CONNECTING) { \n\t\t\tlogger.debug('received handshake success in invalid readyState:', this.readyState);\n\t\t\treturn; \n\t\t}\n\t\tclearTimeout(this._handshakeTimeoutTimer);\n\t\tthis._handshakeTimeoutTimer = null;\n\t\tthis._sessionKey = data.response.session;\n\t\tthis._opened = true;\n\t\tthis.readyState = READYSTATE.CONNECTED;\n\t\tthis._doOnConnect();\n\t\tthis._doConnectComet();\n\t}\n\t\n\tthis._handshakeFailure = function(data) {\n\t\tlogger.debug('handshake failure', data);\n\t\tif (this.readyState != READYSTATE.CONNECTING) { return; }\n\t\tif (data.status == 404) {\n\t\t\tclearTimeout(this._handshakeTimeoutTimer);\n\t\t\treturn this._doOnDisconnect(new errors.ServerUnreachable());\n\t\t}\n\t\t\n\t\tlogger.debug('trying again in ', this._handshakeBackoff);\n\t\tthis._handshakeRetryTimer = setTimeout(bind(this, function() {\n\t\t\tthis._handshakeRetryTimer = null;\n\t\t\tthis._transport.handshake(this._url, this._options);\n\t\t}), this._handshakeBackoff);\n\t\t\n\t\tthis._handshakeBackoff *= 2;\n\t}\n\t\n\tthis._writeSuccess = function() {\n\t\tif (this.readyState != READYSTATE.CONNECTED && this.readyState != READYSTATE.DISCONNECTING) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._nullInFlight) {\n\t\t\treturn this._sentNullPacket();\n\t\t}\n\t\tthis._resetTimeoutTimer();\n\t\tthis.writeBackoff = kDefaultBackoff;\n\t\tthis._packetsInFlight = null;\n\t\tif (this._writeBuffer || this._nullInBuffer) {\n\t\t\tthis._doWrite(this._nullInBuffer);\n\t\t}\n\t}\n\t\n\tthis._writeFailure = function() {\n\t\tif (this.readyState != READYSTATE.CONNECTED && this.READYSTATE != READYSTATE.DISCONNECTING) { return; }\n\t\tthis._writeTimer = setTimeout(bind(this, function() {\n\t\t\tthis._writeTimer = null;\n\t\t\tthis.__doWrite(this._nullInBuffer);\n\t\t}), this._writeBackoff);\n\t\tthis._writeBackoff *= 2;\n\t}\t\n\n\tthis._doWrite = function(sendNull) {\n\t\tif (this._packetsInFlight) {\n\t\t\tif (sendNull) {\n\t\t\t\tthis._nullInBuffer = true;\n\t\t\t\treturn; \n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tthis.__doWrite(sendNull);\n\t}\n\t\n\tthis.__doWrite = function(sendNull) {\n\t\tlogger.debug('_writeBuffer:', this._writeBuffer);\n\t\tif (!this._packetsInFlight && this._writeBuffer) {\n\t\t\tthis._packetsInFlight = [this._transport.encodePacket(++this._lastSentId, this._writeBuffer, this._options)];\n\t\t\tthis._writeBuffer = \"\";\n\t\t}\n\t\tif (sendNull && !this._writeBuffer) {\n\t\t\tif (!this._packetsInFlight) {\n\t\t\t\tthis._packetsInFlight = [];\n\t\t\t}\n\t\t\tthis._packetsInFlight.push([++this._lastSentId, 0, null]);\n\t\t\tthis._nullInFlight = true;\n\t\t}\n\t\tif (!this._packetsInFlight) {\n\t\t\tlogger.debug(\"no packets to send\");\n\t\t\treturn;\n\t\t}\n\t\tlogger.debug('sending packets:', JSON.stringify(this._packetsInFlight));\n\t\tthis._transport.send(this._url, this._sessionKey, this._lastEventId || 0, JSON.stringify(this._packetsInFlight), this._options);\n\t}\n\t\n\tthis._doConnectComet = function() {\n\t\tlogger.debug('_doConnectComet');\n//\t\treturn;\n\t\tthis._transport.comet(this._url, this._sessionKey, this._lastEventId || 0, this._options);\n\t}\n\n\tthis._cometFailure = function(data) {\n\t\tif (this.readyState != READYSTATE.CONNECTED) { return; }\n\t\tif (data.status == 404 && data.response == 'Session not found') {\n\t\t\treturn this.close(new errors.ExpiredSession(data));\n\t\t}\n\t\t\n\t\tthis._cometTimer = setTimeout(bind(this, '_doConnectComet'), this._cometBackoff);\n\t\tthis._cometBackoff *= 2;\n\t}\n\t\n\tthis._cometSuccess = function(data) {\n\t\tif (this.readyState != READYSTATE.CONNECTED && this.readyState != READYSTATE.DISCONNECTING) { return; }\n\t\tlogger.debug('comet Success:', data);\n\t\tthis._cometBackoff = kDefaultBackoff;\n\t\tthis._resetTimeoutTimer();\n\t\t\n\t\tvar response = data.response;\n\t\tfor (var i = 0, packet; (packet = response[i]) || i < response.length; i++) {\n\t\t\tlogger.debug('process packet:', packet);\n\t\t\tif (packet === null) {\n\t\t\t\treturn this.close(new errors.ServerProtocolError(data));\n\t\t\t}\n\t\t\tlogger.debug('process packet', packet);\n\t\t\tvar ackId = packet[0];\n\t\t\tvar encoding = packet[1];\n\t\t\tvar data = packet[2];\n\t\t\tif (typeof(this._lastEventId) == 'number' && ackId <= this._lastEventId) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (typeof(this._lastEventId) == 'number' && ackId != this._lastEventId+1) {\n\t\t\t\treturn this._protocolError(\"Ack id too high\");\n\t\t\t}\n\t\t\tthis._lastEventId = ackId;\n\t\t\tif (data == null) {\n\t\t\t\treturn this._receivedNullPacket();\n\t\t\t}\n\t\t\tif (encoding == 1) { // base64 encoding\n\t\t\t\ttry {\n\t\t\t\t\tlogger.debug('before base64 decode:', data);\n\t\t\t\t\tdata = base64.decode(data);\n\t\t\t\t\tlogger.debug('after base64 decode:', data);\n\t\t\t\t} catch(e) {\n\t\t\t\t\treturn this._protocolError(\"Unable to decode base64 payload\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this._options.encoding == 'utf8') {\n\t\t\t\t// TODO: need an incremental utf8 decoder for this stuff.\n\t\t\t\tthis._utf8ReadBuffer += data;\n\t\t\t\tlogger.debug('before utf8 decode, _utf8ReadBuffer:', this._utf8ReadBuffer);\n\t\t\t\tvar result = utf8.decode(this._utf8ReadBuffer);\n\t\t\t\tdata = result[0];\n\t\t\t\tthis._utf8ReadBuffer = this._utf8ReadBuffer.slice(result[1]);\n\t\t\t\tlogger.debug('after utf8 decode, _utf8ReadBuffer:', this._utf8ReadBuffer, 'data:', data );\n\t\t\t}\n\t\t\tlogger.debug('dispatching data:', data);\n\n\t\t\t// TODO: possibly catch this error in production? but not in dev\n\t\t\tthis._doOnRead(data);\n\t\t}\n\t\t\n\t\tif (this.readyState != READYSTATE.CONNECTED && this.readyState != READYSTATE.DISCONNECTING) { return; }\n\t\t\n\t\t// reconnect comet last, after we process all of the packet ids\n\t\tthis._doConnectComet();\n\t\t\n\t}\n\n\tthis._doOnRead = function(data) {\n\t\tif (typeof(this.onread) == 'function') {\n\t\t\tlogger.debug('call onread function', data);\n\t\t\tthis.onread(data);\n\t\t}\n\t\telse {\n\t\t\tlogger.debug('skipping onread callback (function missing)');\n\t\t}\n\t}\n\t\n\tthis._doOnDisconnect = function(err) {\n\t\tif (typeof(this.ondisconnect) == 'function') {\n\t\t\tlogger.debug('call ondisconnect function', err);\n\t\t\tthis.ondisconnect(err);\n\t\t}\n\t\telse {\n\t\t\tlogger.debug('skipping ondisconnect callback (function missing)');\n\t\t}\n\t}\n\t\n\tthis._doOnConnect = function() {\n\t\tif (typeof(this.onconnect) == 'function') {\n\t\t\tlogger.debug('call onconnect function');\n\t\t\ttry {\n\t\t\t\tthis.onconnect();\n\t\t\t} catch(e) {\n\t\t\t\tlogger.debug('onconnect caused errror', e);\n\t\t\t\t// throw error later\n\t\t\t\tsetTimeout(function() { throw e }, 0);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tlogger.debug('skipping onconnect callback (function missing)');\n\t\t}\n\t}\n\n\tthis._resetTimeoutTimer = function() {\n\t\tclearTimeout(this._timeoutTimer);\n\t\tthis._timeoutTimer = setTimeout(bind(this, function() {\n\t\t\tlogger.debug('connection timeout expired');\n\t\t\tthis.close(new errors.ConnectionTimeout())\n\t\t}), this._getTimeoutInterval())\n\t}\n\t\n\tthis._getTimeoutInterval = function() {\n\t\treturn kDefaultTimeoutInterval;\n\t}\n\n});\n","pre":true},"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/std/base64.js":{"path":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/std/base64.js","friendlyPath":"std.base64","directory":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/std/","filename":"base64.js","src":"/*\n\"URL-safe\" Base64 Codec, by Jacob Rus\n\nThis library happily strips off as many trailing '=' as are included in the\ninput to 'decode', and doesn't worry whether its length is an even multiple\nof 4. It does not include trailing '=' in its own output. It uses the\n'URL safe' base64 alphabet, where the last two characters are '-' and '_'.\n\n--------------------\n\nCopyright (c) 2009 Jacob Rus\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n*/\n\nvar alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n\ttrailingPad = '=',\n\tpadChar = alphabet.charAt(alphabet.length - 1);\n\nvar decodeMap = {};\nfor (var i = 0, len = alphabet.length; i < len; i++) {\n\tdecodeMap[alphabet.charAt(i)] = i;\n}\n\n// use this regexp in the decode function to sniff out invalid characters.\nvar alphabet_inverse = new RegExp('[^' + alphabet.replace('-', '\\\\-') + ']');\n\nexports.Base64CodecError=__class__;exports.Base64CodecError=exports.Base64CodecError(function exports_Base64CodecError(){return this.init&&this.init.apply(this,arguments)},Error, function(supr) {\n\tthis.name = 'Base64CodecError';\n\t\n\tthis.init = function(message) {\n\t\tsupr(this, 'init', arguments);\n\t\tthis.message = message;\n\t}\n});\n\nvar assertOrBadInput = function (exp, message) {\n\tif (!exp) { throw new exports.Base64CodecError(message) };\n};\n\nexports.encode = function (bytes, skipPadding) {\n\tassertOrBadInput(!(/[^\\x00-\\xFF]/.test(bytes)), // disallow two-byte chars\n\t\t'Input contains out-of-range characters.');\n\tvar paddingSize = bytes.length % 3;\n\tvar padding = '\\x00\\x00\\x00'.slice(paddingSize || 3);\n\tbytes += padding; // pad with null bytes\n\tvar out_array = [];\n\tfor (var i=0, n=bytes.length; i < n; i+=3) {\n\t\tvar newchars = (\n\t\t\t(bytes.charCodeAt(i)   << 020) +\n\t\t\t(bytes.charCodeAt(i+1) << 010) +\n\t\t\t(bytes.charCodeAt(i+2)));\n\t\tout_array.push(\n\t\t\talphabet.charAt((newchars >> 18) & 077),\n\t\t\talphabet.charAt((newchars >> 12) & 077),\n\t\t\talphabet.charAt((newchars >> 6)  & 077),\n\t\t\talphabet.charAt((newchars)       & 077));\n\t};\n\t\n\tout_array.length -= padding.length;\n\tvar ret = out_array.join('');\n\tif (!skipPadding) {\n\t\tif (paddingSize == 1) {\n\t\t\tret += '==';\n\t\t} else if (paddingSize == 2) {\n\t\t\tret += '=';\n\t\t}\n\t}\n\t\n\treturn ret;\n};\n\nexports.decode = function (b64text) {\n\tlogger.debug('decode', b64text);\n\tb64text = b64text.replace(/\\s/g, ''); // kill whitespace\n\t\n\t// strip trailing pad characters from input; // XXX maybe some better way?\n\tvar i = b64text.length;\n\twhile (b64text.charAt(--i) === trailingPad) {};\n\tb64text = b64text.slice(0, i + 1);\n\t\n\tassertOrBadInput(!alphabet_inverse.test(b64text), 'Input contains out-of-range characters.');\n\t\n\tvar padLength = 4 - ((b64text.length % 4) || 4),\n\t\tpadding = Array(padLength + 1).join(padChar);\n\t\n\tb64text += padding; // pad with last letter of alphabet\n\t\n\tvar out_array = [],\n\t\tlength = i + padLength + 1; // length of b64text\n\t\n\tfor (var i = 0; i < length; i += 4) {\n\t\tnewchars = (\n\t\t\t(decodeMap[b64text.charAt(i)]   << 18) +\n\t\t\t(decodeMap[b64text.charAt(i+1)] << 12) +\n\t\t\t(decodeMap[b64text.charAt(i+2)] << 6)  +\n\t\t\t(decodeMap[b64text.charAt(i+3)]));\n\t\tout_array.push(\n\t\t\t(newchars >> 020) & 0xFF,\n\t\t\t(newchars >> 010) & 0xFF, \n\t\t\t(newchars)\t\t& 0xFF);\n\t};\n\t\n\tlength = (out_array.length -= padLength);\n\t\n\t// Safari fromCharCode can't be passed more than 65536 arguments at once\n\tvar result,\n\t\tMAX_CHUNK = 65536;\n\t\n\tif (length > MAX_CHUNK) {\n\t\tresult = [];\n\t\tvar i = 0, j = 0;\n\t\twhile (i < length) {\n\t\t\tresult[j++] = String.fromCharCode.apply(String, out_array.slice(i, i + MAX_CHUNK));\n\t\t\ti += MAX_CHUNK;\n\t\t}\n\t\tresult = result.join('');\n\t} else {\n\t\tresult = String.fromCharCode.apply(String, out_array);\n\t}\n\tlogger.debug('decoded', result);\n\treturn result;\n};\n","pre":true},"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/std/utf8.js":{"path":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/std/utf8.js","friendlyPath":"std.utf8","directory":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/std/","filename":"utf8.js","src":"/*\nFast incremental JavaScript UTF-8 encoder/decoder, by Jacob Rus.\n\nAPI for decode from Orbited: as far as I know, the first incremental\nJavaScript UTF-8 decoder.\n\nInspired by the observation by Johan Sundstrm published at:\nhttp://ecmanaut.blogspot.com/2006/07/encoding-decoding-utf8-in-javascript.html\n\nNote that this code throws an error for invalid UTF-8. Because it is so much\nfaster than previous implementations, the recommended way to do lenient\nparsing is to first try this decoder, and then fall back on a slower lenient\ndecoder if necessary for the particular use case.\n\n--------------------\n\nCopyright (c) 2009 Jacob Rus\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n*/\n//var utf8 = this.utf8 = exports;\n\nexports.UnicodeCodecError = function (message) { \n\tthis.message = message; \n};\n\nvar UnicodeCodecError = exports.UnicodeCodecError;\n\nUnicodeCodecError.prototype.toString = function () {\n\treturn 'UnicodeCodecError' + (this.message ? ': ' + this.message : '');\n};\n\nexports.encode = function (unicode_string) {\n\t// Unicode encoder: Given an arbitrary unicode string, returns a string\n\t// of characters with code points in range 0x00 - 0xFF corresponding to\n\t// the bytes of the utf-8 representation of those characters.\n\ttry {\n\t\treturn unescape(encodeURIComponent(unicode_string));\n\t}\n\tcatch (err) {\n\t\tthrow new UnicodeCodecError('invalid input string');\n\t};\n};\nexports.decode = function (bytes) {\n\t// Unicode decoder: Given a string of characters with code points in\n\t// range 0x00 - 0xFF, which, when interpreted as bytes, are valid UTF-8,\n\t// returns the corresponding Unicode string, along with the number of\n\t// bytes in the input string which were successfully parsed.\n\t//\n\t// Unlike most JavaScript utf-8 encode/decode implementations, properly\n\t// deals with partial multi-byte characters at the end of the byte string.\n\tif (/[^\\x00-\\xFF]/.test(bytes)) {\n\t\tthrow new UnicodeCodecError('invalid utf-8 bytes');\n\t};\n\tvar len, len_parsed;\n\tlen = len_parsed = bytes.length;\n\tvar last = len - 1;\n\t// test for non-ascii final byte. if last byte is ascii (00-7F) we're done.\n\tif (bytes.charCodeAt(last) >= 0x80) {\n\t\t// loop through last 3 bytes looking for first initial byte of unicode\n\t\t// multi-byte character. If the initial byte is 4th from the end, we'll\n\t\t// parse the whole string.\n\t\tfor (var i = 1; i <= 3; i++) {\n\t\t\t// initial bytes are in range C0-FF\n\t\t\tif (bytes.charCodeAt(len - i) >= 0xC0) {\n\t\t\t\tlen_parsed = len - i;\n\t\t\t\tbreak;\n\t\t\t};\n\t\t};\n\t\ttry {\n\t\t\t// if the last few bytes are a complete multi-byte character, parse\n\t\t\t// everything (by setting len_parsed)\n\t\t\tdecodeURIComponent(escape(bytes.slice(len_parsed)));\n\t\t\tlen_parsed = len;\n\t\t}\n\t\tcatch (err) { /* pass */ };\n\t};\n\ttry {\n\t\treturn [\n\t\t\tdecodeURIComponent(escape(bytes.slice(0, len_parsed))),\n\t\t\tlen_parsed\n\t\t];\n\t}\n\tcatch (err) {\n\t\tthrow new UnicodeCodecError('invalid utf-8 bytes');\n\t};\n};\n","pre":true},"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/net/errors.js":{"path":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/net/errors.js","friendlyPath":"net.errors","directory":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/net/","filename":"errors.js","src":"var makeErrorClass = function(name, _code) {\n\tvar toString = function() {\n\t\treturn name + (this.message ? ': ' + this.message : '');\n\t}\n\n\tvar ctor = function(data) {\n\t\tif (typeof data == 'string') {\n\t\t\tthis.message = data;\n\t\t} else {\n\t\t\tthis.data = data;\n\t\t}\n\t}\n\t\n\tctor.prototype = {\n\t\ttype: name,\n\t\ttoString: toString\n\t};\n\t\n\treturn ctor;\n}\n\nexports.ReadyStateError = makeErrorClass(\"ReadyStateError\");\nexports.InvalidEncodingError = makeErrorClass(\"InvalidEncodingError\");\nexports.ExpiredSession = makeErrorClass(\"ExpiredSession\");\n\nexports.ServerUnreachable = makeErrorClass(\"ServerUnreachable\", 100);\nexports.ConnectionTimeout = makeErrorClass(\"ConnectionTimeout\", 101);\n\nexports.ServerProtocolError = makeErrorClass(\"ServerProtocolError\", 200);\n\nexports.ServerClosedConnection = makeErrorClass(\"ServerClosedConnection\", 301);\nexports.ConnectionClosedCleanly = makeErrorClass(\"ConnectionClosedCleanly\", 300);","pre":true},"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/net/csp/transports.js":{"path":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/net/csp/transports.js","friendlyPath":".transports","directory":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/net/csp/","filename":"transports.js","src":"jsio('import std.uri as uri'); \njsio('import std.base64 as base64');\njsio('from util.browserdetect import BrowserDetect');\n\n;(function() {\n\tvar doc;\n\texports.getDoc = function() {\n\t\tif (doc) { return doc; }\n\t\ttry {\n\t\t\tdoc = window.ActiveXObject && new ActiveXObject('htmlfile');\n\t\t\tif (doc) {\n\t\t\t\tdoc.open().write('<html></html>');\n\t\t\t\tdoc.close();\n\t\t\t\twindow.attachEvent('onunload', function() {\n\t\t\t\t\ttry { doc.body.innerHTML = ''; } catch(e) {}\n\t\t\t\t\tdoc = null;\n\t\t\t\t});\n\t\t\t}\n\t\t} catch(e) {}\n\t\t\n\t\tif (!doc) { doc = document; }\n\t\treturn doc;\n\t};\n\n\texports.XHR = function() {\n\t\tvar win = window,\n\t\t\tdoc = exports.getDoc();\n\t\t//if (doc.parentWindow) { win = doc.parentWindow; }\n\t\t\n\t\treturn new (exports.XHR = win.XMLHttpRequest ? win.XMLHttpRequest\n\t\t\t: function() { return win.ActiveXObject && new win.ActiveXObject('Msxml2.XMLHTTP') || null; });\n\t}\n\t\n\texports.createXHR = function() { return new exports.XHR(); }\n\n})();\n\nfunction isLocalFile(url) { return /^file:\\/\\//.test(url); }\nfunction isWindowDomain(url) { return uri.isSameDomain(url, window.location.href); }\n\nvar xhrSupportsBinary = undefined;\nfunction checkXHRBinarySupport(xhr) {\n\txhrSupportsBinary = !!xhr.sendAsBinary;\n}\n\nfunction canUseXHR(url) {\n\t// always use jsonp for local files\n\tif (isLocalFile(url)) { return false; }\n\t\n\t// try to create an XHR using the same function the XHR transport uses\n\tvar xhr = new exports.XHR();\n\tif (!xhr) { return false; }\n\t\n\tcheckXHRBinarySupport(xhr);\n\t\n\t// if the URL requested is the same domain as the window,\n\t// then we can use same-domain XHRs\n\tif (isWindowDomain(url)) { return true; }\n\t\n\t// if the URL requested is a different domain than the window,\n\t// then we need to check for cross-domain support\n\tif (window.XMLHttpRequest\n\t\t\t&& (xhr.__proto__ == XMLHttpRequest.prototype // WebKit Bug 25205\n\t\t\t\t|| xhr instanceof window.XMLHttpRequest)\n\t\t\t&& xhr.withCredentials !== undefined\n\t\t|| window.XDomainRequest \n\t\t\t&& xhr instanceof window.XDomainRequest) {\n\t\treturn true;\n\t}\n};\n\nvar transports = exports.transports = {};\n\nexports.chooseTransport = function(url, options) {\n\tswitch(options.preferredTransport) {\n\t\tcase 'jsonp':\n\t\t\treturn transports.jsonp;\n\t\tcase 'xhr':\n\t\tdefault:\n\t\t\tif (canUseXHR(url)) { return transports.xhr; };\n\t\t\treturn transports.jsonp;\n\t}\n};\n\n// TODO: would be nice to use these somewhere...\n\nvar PARAMS = {\n\t'xhrstream':   {\"is\": \"1\", \"bs\": \"\\n\"},\n\t'xhrpoll':     {\"du\": \"0\"},\n\t'xhrlongpoll': {},\n\t'sselongpoll': {\"bp\": \"data: \", \"bs\": \"\\r\\n\", \"se\": \"1\"},\n\t'ssestream':   {\"bp\": \"data: \", \"bs\": \"\\r\\n\", \"se\": \"1\", \"is\": \"1\"}\n};\n\nexports.Transport=__class__;exports.Transport=exports.Transport(function exports_Transport(){return this.init&&this.init.apply(this,arguments)},function(supr) {\n\tthis.handshake = function(url, options) {\n\t\tthrow new Error(\"handshake Not Implemented\"); \n\t};\n\tthis.comet = function(url, sessionKey, lastEventId, options) { \n\t\tthrow new Error(\"comet Not Implemented\"); \n\t};\n\tthis.send = function(url, sessionKey, data, options) { \n\t\tthrow new Error(\"send Not Implemented\");\n\t};\n\tthis.encodePacket = function(packetId, data, options) { \n\t\tthrow new Error(\"encodePacket Not Implemented\"); \n\t};\n\tthis.abort = function() { \n\t\tthrow new Error(\"abort Not Implemented\"); \n\t};\n});\n\nbaseTransport=__class__;var baseTransport=baseTransport(function baseTransport(){return this.init&&this.init.apply(this,arguments)},exports.Transport, function(supr) {\n\tthis.init = function() {\n\t\tthis._aborted = false;\n\t\tthis._handshakeArgs = {ct:'application/javascript'};\n\t\tthis._handshakeData = '{}'\n\t};\n\t\n\tthis.handshake = function(url, options) {\n\t\tlogger.debug('handshake:', url, options);\n\t\tthis._makeRequest('send', url + '/handshake', \n\t\t\t\t\t\t  this._handshakeArgs,\n\t\t\t\t\t\t  this._handshakeData,\n\t\t\t\t\t\t  this.handshakeSuccess, \n\t\t\t\t\t\t  this.handshakeFailure);\n\t};\n\t\n\tthis.comet = function(url, sessionKey, lastEventId, options) {\n\t\tlogger.debug('comet:', url, sessionKey, lastEventId, options);\n\t\tvar args = {\n\t\t\ts: sessionKey,\n\t\t\ta: lastEventId\n\t\t};\n\t\tthis._makeRequest('comet', url + '/comet', \n\t\t\t\t\t\t  args,\n\t\t\t\t\t\t  null,\n\t\t\t\t\t\t  this.cometSuccess, \n\t\t\t\t\t\t  this.cometFailure);\n\t};\n\t\n\tthis.send = function(url, sessionKey, lastEventId, data, options) {\n\t\t//logger.debug('send:', url, sessionKey, data, options);\n\t\tvar args = {\n\t\t\ts: sessionKey,\n\t\t\ta: lastEventId\n\t\t};\n\t\tthis._makeRequest('send', url + '/send', \n\t\t\t\t\t\t  args,\n\t\t\t\t\t\t  data,\n\t\t\t\t\t\t  this.sendSuccess, \n\t\t\t\t\t\t  this.sendFailure);\n\t};\n});\n\ntransports.xhr=__class__;transports.xhr=transports.xhr(function transports_xhr(){return this.init&&this.init.apply(this,arguments)},baseTransport, function(supr) {\n\t\n\tthis.init = function() {\n\t\tsupr(this, 'init');\n\t\n\t\tthis._xhr = {\n\t\t\t'send': new exports.XHR(),\n\t\t\t'comet': new exports.XHR()\n\t\t};\n\t};\n\n\tthis.abort = function() {\n\t\tthis._aborted = true;\n\t\tfor(var i in this._xhr) {\n\t\t\tif(this._xhr.hasOwnProperty(i)) {\n\t\t\t\tthis._abortXHR(i);\n\t\t\t}\n\t\t}\n\t};\n\t\n\tthis._abortXHR = function(type) {\n\t\tlogger.debug('aborting XHR');\n\n\t\tvar xhr = this._xhr[type];\n\t\ttry {\n\t\t\tif('onload' in xhr) {\n\t\t\t\txhr.onload = xhr.onerror = xhr.ontimeout = null;\n\t\t\t} else if('onreadystatechange' in xhr) {\n\t\t\t\txhr.onreadystatechange = null;\n\t\t\t}\n\t\t\tif(xhr.abort) { xhr.abort(); }\n\t\t} catch(e) {\n\t\t\tlogger.debug('error aborting xhr', e);\n\t\t}\n\t\t\n\t\t// do not reuse aborted XHRs\n\t\tthis._xhr[type] = new exports.XHR();\n\t};\n\t\n\tthis.encodePacket = function(packetId, data, options) {\n\t\t// we don't need to base64 encode things unless there's a null character in there\n\t\treturn !xhrSupportsBinary ? [ packetId, 1, base64.encode(data) ] : [ packetId, 0, data ];\n\t};\n\n\tfunction onReadyStateChange(xhr, rType, cb, eb) {\n\t\ttry {\n\t\t\tvar data = {status: xhr.status};\n\t\t} catch(e) { eb({response: 'Could not access status'}); }\n\t\t\n\t\ttry {\n\t\t\tif(xhr.readyState != 4) { return; }\n\t\t\t\n\t\t\tdata.response = eval(xhr.responseText);\n\t\t\tif(data.status != 200) { \n\t\t\t\tlogger.debug('XHR failed with status ', xhr.status);\n\t\t\t\teb(data);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tlogger.debug('XHR data received');\n\t\t} catch(e) {\n\t\t\tlogger.debug('Error in XHR::onReadyStateChange', e);\n\t\t\teb(data);\n\t\t\tthis._abortXHR(rType);\n\t\t\tlogger.debug('done handling XHR error');\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tcb(data);\n\t};\n\n\t/**\n\t * even though we encode the POST body as in application/x-www-form-urlencoded\n\t */\n\tthis._makeRequest = function(rType, url, args, data, cb, eb) {\n\t\tif (this._aborted) { return; }\n\t\tvar xhr = this._xhr[rType];\n\t\txhr.open('POST', url + '?' + uri.buildQuery(args)); // must open XHR first\n\t\txhr.setRequestHeader('Content-Type', 'text/plain'); // avoid preflighting\n\t\tif('onload' in xhr) {\n\t\t\txhr.onload = bind(this, onReadyStateChange, xhr, rType, cb, eb);\n\t\t\txhr.onerror = xhr.ontimeout = eb;\n\t\t} else if('onreadystatechange' in xhr) {\n\t\t\txhr.onreadystatechange = bind(this, onReadyStateChange, xhr, rType, cb, eb);\n\t\t}\n\t\t// NOTE WELL: Firefox (and probably everyone else) likes to encode our nice\n\t\t//\t\t\t\t\t\tbinary strings as utf8. Don't let them! Say no to double utf8\n\t\t//\t\t\t\t\t\tencoding. Once is good, twice isn't better.\n\t\t// if (xhrSupportsBinary) {\n\t\t// \t\txhr.setRequestHeader('x-CSP-SendAsBinary', 'true');\n\t\t// }\n\t\tsetTimeout(function() {\n\t\t\txhr[xhrSupportsBinary ? 'sendAsBinary' : 'send'](data || null)\n\t\t}, 0);\n\t};\n});\n\nvar EMPTY_FUNCTION = function() {},\n\tSLICE = Array.prototype.slice;\n\ntransports.jsonp=__class__;transports.jsonp=transports.jsonp(function transports_jsonp(){return this.init&&this.init.apply(this,arguments)},baseTransport, function(supr) {\n\tvar doc;\n\t\n\tvar createIframe = function() {\n\t\tvar doc = exports.getDoc();\n\t\tif (!doc.body) { return false; }\n\t\t\n\t\tvar i = doc.createElement(\"iframe\");\n\t\twith(i.style) { display = 'block'; width = height = border = margin = padding = '0'; overflow = visibility = 'hidden'; position = 'absolute'; top = left = '-999px'; }\n\t\ti.cbId = 0;\n\t\tdoc.body.appendChild(i);\n\t\ti.src = 'about:blank';\n\t\treturn i;\n\t};\n\n\tvar cleanupIframe = function(ifr) {\n\t\tvar win = ifr.contentWindow, doc = win.document;\n\t\tlogger.debug('removing script tags');\n\t\t\n\t\tvar scripts = doc.getElementsByTagName('script');\n\t\tfor (var i = scripts.length - 1; i >= 0; --i) {\n\t\t\tdoc.body.removeChild(scripts[i]);\n\t\t}\n\t\t\n\t\tlogger.debug('deleting iframe callbacks');\n\t\twin['cb' + ifr.cbId] = win['eb' + ifr.cbId] = EMPTY_FUNCTION;\n\t};\n\n\tvar removeIframe = function(ifr) {\n\t\tsetTimeout(function() {\n\t\t\tif(ifr && ifr.parentNode) { ifr.parentNode.removeChild(ifr); }\n\t\t}, 60000);\n\t};\n\n\tthis.init = function() {\n\t\tsupr(this, 'init');\n\n\t\tthis._onReady = [];\n\t\tthis._isReady = false;\n\n\t\tthis._createIframes();\n\t};\n\n\tthis._createIframes = function() {\n\t\tthis._ifr = {\n\t\t\tsend: createIframe(),\n\t\t\tcomet: createIframe()\n\t\t};\n\t\t\n\t\tif(this._ifr.send === false) { return setTimeout(bind(this, '_createIframes'), 100); }\n\t\t\n\t\tthis._isReady = true;\n\n\t\tvar readyArgs = this._onReady;\n\t\tthis._onReady = [];\n\t\tfor(var i = 0, args; args = readyArgs[i]; ++i) {\n\t\t\tthis._makeRequest.apply(this, args);\n\t\t}\n\t};\n\n\tthis.encodePacket = function(packetId, data, options) {\n\t\treturn [ packetId, 1, base64.encode(data) ];\n\t};\n\n\tthis.abort = function() {\n\t\tthis._aborted = true;\n\t\tfor(var i in this._ifr) {\n\t\t\tif(this._ifr.hasOwnProperty(i)) {\n\t\t\t\tvar ifr = this._ifr[i];\n\t\t\t\tcleanupIframe(ifr);\n\t\t\t\tremoveIframe(ifr);\n\t\t\t}\n\t\t}\n\t};\n\t\n\tthis._makeRequest = function(rType, url, args, data, cb, eb) {\n\t\tif(!this._isReady) { return this._onReady.push(arguments); }\n\t\t\n\t\tvar ifr = this._ifr[rType],\n\t\t\tid = ++ifr.cbId,\n\t\t\treq = {\n\t\t\t\ttype: rType,\n\t\t\t\tid: id,\n\t\t\t\tcb: cb,\n\t\t\t\teb: eb,\n\t\t\t\tcbName: 'cb' + id,\n\t\t\t\tebName: 'eb' + id,\n\t\t\t\tcompleted: false\n\t\t\t};\n\t\t\n\t\targs.d = data;\n\t\targs.n = Math.random();\t\n\t\tswitch(rType) {\n\t\t\tcase 'send': args.rs = ';'; args.rp = req.cbName; break;\n\t\t\tcase 'comet': args.bs = ';'; args.bp = req.cbName; break;\n\t\t}\n\t\t\n\t\treq.url = url + '?' + uri.buildQuery(args)\n\t\t\n\t\tsetTimeout(bind(this, '_request', req), 0);\n\t}\n\t\n\tthis._request = function(req) {\n\t\tvar ifr = this._ifr[req.type],\n\t\t\twin = ifr.contentWindow,\n\t\t\tdoc = win.document,\n\t\t\tbody = doc.body;\n                /*added by skysbird for opera support*/\n                if (!body){return setTimeout(bind(this,'_request',req),100); }\n\t\twin[req.ebName] = bind(this, checkForError, req);\n\t\twin[req.cbName] = bind(this, onSuccess, req);\n\t\t\n\t\tif(BrowserDetect.isWebKit) {\n\t\t\t// this will probably cause loading bars in Safari -- might want to rethink?\n\t\t\tdoc.open();\n\t\t\tdoc.write('<scr'+'ipt src=\"'+req.url+'\"></scr'+'ipt><scr'+'ipt>'+ebName+'(false)</scr'+'ipt>');\n\t\t\tdoc.close();\n\t\t} else {\n\t\t\tvar s = doc.createElement('script');\n\t\t\ts.src = req.url;\n\t\t\t\n\t\t\t// IE\n\t\t\tif(s.onreadystatechange === null) { s.onreadystatechange = bind(this, onReadyStateChange, req, s); }\n\t\t\tbody.appendChild(s);\n\t\t\t\n\t\t\tif(!BrowserDetect.isIE) {\n\t\t\t\tvar s = doc.createElement('script');\n\t\t\t\ts.innerHTML = req.ebName+'(false)';\n\t\t\t\tbody.appendChild(s);\n\t\t\t}\n\t\t}\n\t\t\n\t\tkillLoadingBar();\n\t};\n\t\n\tfunction onSuccess(req, response) {\n\t\tlogger.debug('successful: ', req.url, response);\n\t\treq.completed = true;\n\t\t\n\t\tlogger.debug('calling the cb');\n\t\treq.cb.call(GLOBAL, {status: 200, response: response});\n\t\tlogger.debug('cb called');\n\t}\n\t\n\t// IE6/7 onReadyStateChange\n\tfunction onReadyStateChange(req, scriptTag) {\n\t\tif (scriptTag && scriptTag.readyState != 'loaded') { return; }\n\t\tscriptTag.onreadystatechange = function() {};\n\t\tcheckForError.call(this, req);\n\t}\n\n\tfunction checkForError(req, response) {\n\t\tcleanupIframe(this._ifr[req.type]);\n\t\t\n\t\tif (!req.completed) {\n\t\t\tvar data = {\n\t\t\t\tstatus: response ? 200 : 404,\n\t\t\t\tresponse: response || 'Unable to load resouce'\n\t\t\t};\n\t\t\t\n\t\t\tlogger.debug('error making request:', req.url, data);\n\t\t\tlogger.debug('calling eb');\n\t\t\treq.eb.call(GLOBAL, data);\n\t\t}\n\t}\n\t\n\tvar killLoadingBar = BrowserDetect.isFirefox || BrowserDetect.isOpera ? function() {\n\t\tvar b = document.body;\n\t\tif (!b) { return; }\n\t\t\n\t\tif (!killLoadingBar.iframe) { killLoadingBar.iframe = document.createElement('iframe'); }\n\t\tb.insertBefore(killLoadingBar.iframe, b.firstChild);\n\t\tb.removeChild(killLoadingBar.iframe);\n\t} : function() {};\n});\n\t\n","pre":true},"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/util/browserdetect.js":{"path":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/util/browserdetect.js","friendlyPath":"util.browserdetect","directory":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/util/","filename":"browserdetect.js","src":"exports.BrowserDetect = new function() {\n\tvar versionSearchString;\n\tvar dataBrowser = [\n\t\t{\n\t\t\tstring: navigator.userAgent,\n\t\t\tsubString: \"Chrome\"\n\t\t},\n\t\t{\n\t\t\tstring: navigator.userAgent,\n\t\t\tsubString: \"OmniWeb\",\n\t\t\tversionSearch: \"OmniWeb/\"\n\t\t},\n\t\t{\n\t\t\tstring: navigator.vendor,\n\t\t\tsubString: \"Apple\",\n\t\t\tidentity: \"Safari\",\n\t\t\tversionSearch: \"Version\"\n\t\t},\n\t\t{\n\t\t\tprop: window.opera,\n\t\t\tidentity: \"Opera\"\n\t\t},\n\t\t{\n\t\t\tstring: navigator.vendor,\n\t\t\tsubString: \"iCab\"\n\t\t},\n\t\t{\n\t\t\tstring: navigator.vendor,\n\t\t\tsubString: \"KDE\",\n\t\t\tidentity: \"Konqueror\"\n\t\t},\n\t\t{\n\t\t\tstring: navigator.userAgent,\n\t\t\tsubString: \"Firefox\"\n\t\t},\n\t\t{\n\t\t\tstring: navigator.vendor,\n\t\t\tsubString: \"Camino\"\n\t\t},\n\t\t{\t\t// for newer Netscapes (6+)\n\t\t\tstring: navigator.userAgent,\n\t\t\tsubString: \"Netscape\"\n\t\t},\n\t\t{\n\t\t\tstring: navigator.userAgent,\n\t\t\tsubString: \"MSIE\",\n\t\t\tidentity: \"IE\",\n\t\t\tversionSearch: \"MSIE\"\n\t\t},\n\t\t{\n\t\t\tstring: navigator.userAgent,\n\t\t\tsubString: \"Gecko\",\n\t\t\tidentity: \"Mozilla\",\n\t\t\tversionSearch: \"rv\"\n\t\t},\n\t\t{ \t\t// for older Netscapes (4-)\n\t\t\tstring: navigator.userAgent,\n\t\t\tsubString: \"Mozilla\",\n\t\t\tidentity: \"Netscape\",\n\t\t\tversionSearch: \"Mozilla\"\n\t\t}\n\t];\n\t\n\tvar dataOS = [\n\t\t{\n\t\t\tstring: navigator.platform,\n\t\t\tsubString: \"Win\",\n\t\t\tidentity: \"Windows\"\n\t\t},\n\t\t{\n\t\t\tstring: navigator.platform,\n\t\t\tsubString: \"Mac\"\n\t\t},\n\t\t{\n\t\t\tstring: navigator.userAgent,\n\t\t\tsubString: \"iPhone\",\n\t\t\tidentity: \"iPhone/iPod\"\n\t\t},\n\t\t{\n\t\t\tstring: navigator.platform,\n\t\t\tsubString: \"Linux\"\n\t\t}\n\t];\n\t\n\tfunction searchString(data) {\n\t\tfor (var i=0,item;item=data[i];i++)\t{\n\t\t\tvar dataString = item.string;\n\t\t\tvar dataProp = item.prop;\n\t\t\titem.identity = item.identity || item.subString;\n\t\t\tversionSearchString = item.versionSearch || item.identity;\n\t\t\tif (dataString) {\n\t\t\t\tif (dataString.indexOf(item.subString) != -1)\n\t\t\t\t\treturn item.identity;\n\t\t\t} else if (dataProp)\n\t\t\t\treturn item.identity;\n\t\t}\n\t}\n\t\n\tfunction searchVersion(dataString) {\n\t\tvar index = dataString.indexOf(versionSearchString);\n\t\tif (index == -1) return;\n\t\treturn parseFloat(dataString.substring(index+versionSearchString.length+1));\n\t}\n\t\n\tthis.browser = searchString(dataBrowser) || \"unknown\";\n\tthis.version = searchVersion(navigator.userAgent)\n\t\t|| searchVersion(navigator.appVersion)\n\t\t|| \"unknown\";\n\tthis.OS = searchString(dataOS) || \"unknown\";\n\tthis.isWebKit = RegExp(\" AppleWebKit/\").test(navigator.userAgent);\n\tthis['is'+this.browser] = this.version;\n};","pre":true},"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/net/env/browser/postmessage.js":{"path":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/net/env/browser/postmessage.js","friendlyPath":"net.env.browser.postmessage","directory":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/net/env/browser/","filename":"postmessage.js","src":"jsio(\"import net.interfaces\");\njsio(\"from util.browser import $\");\njsio(\"import std.uuid\");\n\n/**\n * @extends net.interfaces.Listener\n */\nexports.Listener=__class__;exports.Listener=exports.Listener(function exports_Listener(){return this.init&&this.init.apply(this,arguments)},net.interfaces.Listener, function(supr) {\n\tvar ID = 0;\n\t\n\tthis.init = function() {\n\t\tsupr(this, 'init', arguments);\n\t\tthis._clients = {};\n\t\tif (!this._opts.clientUrl) {\n\t\t\tthis._opts.clientUrl = jsio.__dir + '/networkConsole.html';\n\t\t}\n\n\t\tthis._port = '' + (this._opts.port || '');\n\t}\n\n\tthis.listen = function() {\n\t\t$.onEvent(window, 'message', bind(this, '_onMessage'));\n\t}\n\n\tthis.getButton = function(url, text) {\n\t\tvar button = $({\n\t\t\ttagName: 'button',\n\t\t\ttext: text || 'launch client',\n\t\t\tclassName: 'clientButton'\n\t\t});\n\t\t$.onEvent(button, 'click', bind(this, 'openWindow', url || this._opts.clientUrl));\n\t\treturn button; \n\t}\n\t\n\tvar uniqueId = 1;\n\tthis.openWindow = function (url) {\n\t\tvar options = { menubar: 'no', location: 'no', toolbar: 'no',\n\t\t\twidth: 550, height: 350, // left: 200, top: 200,\n\t\t\tscrollbars: 'yes', status: 'yes', resizable: 'yes' };\n\t\t\n\t\tvar arr = [];\n\t\tfor (var i in options) { arr.push(i + '=' + options[i]) }\n\t\tvar win = window.open(url, 'W' + uniqueId++, arr.join(','));\n\t\twin.focus();\n\t}\n\t\n\tthis._onMessage = function (evt) {\n\t\tif (this._port != evt.data.substring(0, this._port.length)) { return; }\n\t\tvar data = evt.data.substring(this._port.length);\n\n\t\ttry {\n\t\t\tdata = JSON.parse(data);\n\t\t} catch (e) {\n\t\t\tlogger.warn('invalid packet', evt.data);\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (data.type) {\n\t\t\tcase 'open':\n\t\t\t\tvar transport = this._clients[data.uid] = new exports.Transport(evt.source, this._port, data.uid);\n\t\t\t\tevt.source.postMessage(this._port + JSON.stringify({\"type\":\"open\", uid: data.uid}), '*');\n\t\t\t\tthis.onConnect(transport);\n\t\t\t\tbreak;\n\t\t\tcase 'data':\n\t\t\t\tvar transport = this._clients[data.uid];\n\t\t\t\tif (transport) { transport.onData(data.payload); }\n\t\t\t\tbreak;\n\t\t\tcase 'close':\n\t\t\t\tvar transport = this._clients[data.uid];\n\t\t\t\tif (transport) { transport.onClose(); }\n\t\t\t\tevt.source.postMessage(this._port + JSON.stringify({\"type\":\"close\", uid: data.uid}), '*');\n\t\t\t\tdelete this._clients[data.uid];\n\t\t\t\tbreak;\n\t\t}\n\t}\n});\n\n/**\n * @extends net.interfaces.Connector\n */\nexports.Connector=__class__;exports.Connector=exports.Connector(function exports_Connector(){return this.init&&this.init.apply(this,arguments)},net.interfaces.Connector, function() {\n\tthis.connect = function() {\n\t\tthis._port = '' + (this._opts.port || '');\n\t\tthis._win = this._opts.win || window.opener || window.parent;\n\t\t$.onEvent(window, 'message', bind(this, '_onMessage'));\n\n\t\tthis._uid = std.uuid.uuid();\n\t\tthis._win.postMessage(this._port + JSON.stringify({type: 'open', uid: this._uid}), '*');\n\t}\n\t\n\tthis._onMessage = function(evt) {\n\t\tif (this._port != evt.data.substring(0, this._port.length)) { return; }\n\t\tvar data = evt.data.substring(this._port.length);\n\n\t\t// At the moment, we include the uid in the data.  If we have many clients\n\t\t// on the same port with different UIDs then this would get expensive, but\n\t\t// this is a very rare use case for postmessage.\n\t\ttry {\n\t\t\tdata = JSON.parse(data);\n\t\t} catch (e) {\n\t\t\tlogger.warn('invalid packet', evt.data);\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (data.type) {\n\t\t\tcase 'open':\n\t\t\t\tthis._transport = new exports.Transport(evt.source, this._port, this._uid);\n\t\t\t\tthis.onConnect(this._transport);\n\t\t\t\tbreak;\n\t\t\tcase 'close':\n\t\t\t\tif (data.uid != this._uid) { return; }\n\t\t\t\tthis._transport.onClose();\n\t\t\t\tbreak;\n\t\t\tcase 'data':\n\t\t\t\tif (data.uid != this._uid) { return; }\n\t\t\t\tthis._transport.onData(data.payload);\n\t\t\t\tbreak;\n\t\t}\n\t}\n});\n\n/**\n * @extends net.interfaces.Transport\n */\nexports.Transport=__class__;exports.Transport=exports.Transport(function exports_Transport(){return this.init&&this.init.apply(this,arguments)},net.interfaces.Transport, function() {\n\tthis.init = function (win, port, uid) {if (!uid) debugger\n\t\tthis._win = win;\n\t\tthis._port = port;\n\t\tthis._uid = uid; // unique identifier for clients\n\t}\n\t\n\tthis.makeConnection = function (protocol) {\n\t\tthis._protocol = protocol;\n\t}\n\t\n\tthis.write = function (data, encoding) {\n\t\tif (this.encoding == 'utf8') {\n\t\t\tthis._win.postMessage(this._port + JSON.stringify({type: 'data', uid: this._uid, payload: utf8.encode(data)}), '*');\n\t\t} else {\n\t\t\tthis._win.postMessage(this._port + JSON.stringify({type: 'data', uid: this._uid, payload: data}), '*');\n\t\t} \n\t}\n\t\n\tthis.loseConnection = function (protocol) {\n\t\tthis._win.postMessage(this._port + JSON.stringify({type: 'close', uid: this._uid, code: 301}), '*');\n\t}\n\t\n\tthis.onData = function () { this._protocol.dataReceived.apply(this._protocol, arguments); }\n\tthis.onClose = function () { this._protocol._connectionLost.apply(this._protocol, arguments); }\n});\n","pre":true},"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/std/uuid.js":{"path":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/std/uuid.js","friendlyPath":"std.uuid","directory":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/std/","filename":"uuid.js","src":"/*\nBased on Math.uuid.js 1.4 by Robert Kieffer\n\n----\nCopyright (c) 2008, Robert Kieffer\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n  * Redistributions of source code must retain the above copyright notice,\n\tthis list of conditions and the following disclaimer.\n  * Redistributions in binary form must reproduce the above copyright\n\tnotice, this list of conditions and the following disclaimer in the\n\tdocumentation and/or other materials provided with the distribution.\n  * Neither the name of Robert Kieffer nor the names of its contributors\n\tmay be used to endorse or promote products derived from this software\n\twithout specific prior written permission.\n  \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n\n*/\n\n\n\n/*\n * Generate a random uuid.\n *\n * USAGE: uuid.uuid(length, radix)\n *   length - the desired number of characters\n *   radix  - the number of allowable values for each character.\n *\n * EXAMPLES:\n *   // No arguments  - returns RFC4122, version 4 ID\n *   >>> std.uuid()\n *   \"92329D39-6F5C-4520-ABFC-AAB64544E172\"\n * \n *   // One argument - returns ID of the specified length\n *   >>> std.uuid(15)\t // 15 character ID (default base=62)\n *   \"VcydxgltxrVZSTV\"\n *\n *   // Two arguments - returns ID of the specified length, and radix. (Radix must be <= 62)\n *   >>> std.uuid(8, 2)  // 8 character ID (base=2)\n *   \"01001010\"\n *   >>> std.uuid(8, 10) // 8 character ID (base=10)\n *   \"47473046\"\n *   >>> std.uuid(8, 16) // 8 character ID (base=16)\n *   \"098F4D35\"\n */\n\n\nvar CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split(''); \nexports.uuid = function (len, radix) {\n\tvar chars = CHARS, uuid = [], rnd = Math.random;\n\tradix = radix || chars.length;\n\n\tif (len) {\n\t\t// Compact form\n\t\tfor (var i = 0; i < len; i++) uuid[i] = chars[0 | rnd()*radix];\n\t} else {\n\t\t// rfc4122, version 4 form\n\t\tvar r;\n\n\t\t// rfc4122 requires these characters\n\t\tuuid[8] = uuid[13] = uuid[18] = uuid[23] = '-';\n\t\tuuid[14] = '4';\n\n\t\t// Fill in random data.  At i==19 set the high bits of clock sequence as\n\t\t// per rfc4122, sec. 4.1.5\n\t\tfor (var i = 0; i < 36; i++) {\n\t\t\tif (!uuid[i]) {\n\t\t\t\tr = 0 | rnd()*16;\n\t\t\t\tuuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r & 0xf];\n\t\t\t}\n\t\t}\n\t}\n\treturn uuid.join('');\n};\n\n","pre":true},"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/net/env.js":{"path":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/net/env.js","friendlyPath":"net.env","directory":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/net/","filename":"env.js","src":"function getObj(objectName, transportName, envName) {\n\t\n\ttry {\n\t\tvar DYNAMIC_IMPORT_ENV = 'from .env.' + (envName || jsio.__env.name) + '.' + transportName + ' import ' + objectName + ' as result';\n\t\tjsio(DYNAMIC_IMPORT_ENV);\n\t} catch(e) {\n\t\tthrow logger.error('Invalid transport (', transportName, ') or environment (', envName, ')');\n\t}\n\treturn result;\n}\n\nexports.getListener = bind(this, getObj, 'Listener');\nexports.getConnector = bind(this, getObj, 'Connector');\n","pre":true},"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/net/protocols/Cuppa.js":{"path":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/net/protocols/Cuppa.js","friendlyPath":"net.protocols.Cuppa","directory":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/net/protocols/","filename":"Cuppa.js","src":"\"use import\";\n\njsio(\"import lib.Callback\");\njsio(\"import lib.PubSub\");\n\njsio(\"from net.protocols.rtjp import RTJPProtocol\");\n\nError=__class__;var Error=Error(function Error(){return this.init&&this.init.apply(this,arguments)},function() {\n\tthis.init = function(protocol, id, msg, details, requestId) {\n\t\tthis.id = id;\n\t\tthis.msg = msg;\n\t\tthis.details = details;\n\t\tthis.requestId = requestId;\n\t}\n});\n\nRPCRequest=__class__;var RPCRequest=RPCRequest(function RPCRequest(){return this.init&&this.init.apply(this,arguments)},function() {\n\tthis.init = function(protocol, id) {\n\t\tthis.protocol = protocol;\n\t\tthis.id = id;\n\t\tthis._onError = new lib.Callback();\n\t\tthis._onSuccess = new lib.Callback();\n\t}\n\n\tthis.onError = function() { this._onError.forward(arguments); }\n\tthis.onSuccess = function() { this._onSuccess.forward(arguments); }\n\t\n\tthis.bindLater = function(l) {\n\t\tvar args = [].slice(arguments, 1);\n\t\tthis._onError.forward([l, l.fail].concat(args));\n\t\tthis._onSuccess.forward([l, l.succed].concat(args));\n\t\treturn l;\n\t}\n\t\n\t\n});\n\nReceivedRequest=__class__;var ReceivedRequest=ReceivedRequest(function ReceivedRequest(){return this.init&&this.init.apply(this,arguments)},function() {\n\tthis.type = \"request\"\n\n\tthis.init = function(protocol, id, name, args, target) {\n\t\tthis.protocol = protocol\n\t\tthis.id = id;\n\t\tthis.name = name\n\t\tthis.responded = false;\n\t\tthis.args = args;\n\t\tthis.target = target;\n\t}\n\n\tthis.error = function(msg, details) {\n\t\tif (this.responded) { throw new Error(\"already responded\"); }\n\t\tif (this._timer) { \n\t\t\tclearTimeout(this._timer); \n\t\t\tthis._timer = null; \n\t\t}\n\t\targs = {\n\t\t\tid: this.id,\n\t\t\tmsg: msg + \"\"\n\t\t}\n\t\tif (details !== undefined) { args.details = details }\n\t\tthis.responded = true;        \n\t\tthis.protocol.sendFrame('ERROR', args);\n\t}\n\n\tthis.respond = function(args) {\n\t\tif (this.responded) { throw new Error(\"already responded\"); }\n\t\tif (this._timer) { \n\t\t\tclearTimeout(this._timer); \n\t\t\tthis._timer = null; \n\t\t}\n\t\tthis.responded = true;\n\t\tthis.protocol.sendFrame('RESPONSE', {\n\t\t\tid: this.id,\n\t\t\targs: args == undefined ? {} : args // python cuppa ignores responses with undefined args\n\t\t});\n\t}\n\t\n\tthis.timeoutAfter = function(duration, msg) {\n\t\tif (this.responded) { return; }\n\t\tif (this._timer) { clearTimeout(this._timer); }\n\t\tthis._timer = setTimeout(bind(this, '_timeout', msg), duration);\n\t}\n\t\n\tthis._timeout = function(msg) {\n\t\tif (!this.responded) {\n\t\t\tthis.error(msg);\n\t\t}\n\t}\n    \n});\n\nReceivedEvent=__class__;var ReceivedEvent=ReceivedEvent(function ReceivedEvent(){return this.init&&this.init.apply(this,arguments)},function() {\n\tthis.init = function(protocol, id, name, args, target) {\n\t\tthis.id = id;\n\t\tthis.name = name;\n\t\tthis.args = args;\n\t\tthis.target = target;\n\t}\n});\n\n/**\n * @extends net.protocols.rtjp.RTJPProtocol;\n */\nvar Users_arnovandervegt_gameclosure_basil_sdk_jsio_net_protocols_Cuppa=__class__;exports=Users_arnovandervegt_gameclosure_basil_sdk_jsio_net_protocols_Cuppa(function Users_arnovandervegt_gameclosure_basil_sdk_jsio_net_protocols_Cuppa(){return this.init&&this.init.apply(this,arguments)},RTJPProtocol, function(supr) {\n\tthis.init = function() {\n\t\tsupr(this, 'init', arguments);\n\t\t\n\t\tthis._onConnect = new lib.Callback();\n\t\tthis._onDisconnect = new lib.Callback();\n\t\t\n\t\tthis._requests = {};\n\t\t\n\t\tthis.onEvent = new lib.PubSub();\n\t\tthis.onRequest = new lib.PubSub();\n\t}\n\t\n\tthis.disconnect = function() { this.transport.loseConnection(); }\n\t\n\t// pass something to call (ctx, method, args...) when connected\n\tthis.onConnect = function() { this._onConnect.forward(arguments); }\n\tthis.onDisconnect = function() { this._onDisconnect.forward(arguments); }\n\t\n\tthis.reset = function() {\n\t\tthis._onConnect.reset();\n\t\tthis._onDisconnect.reset();\n\t}\n\t\n\t// called when we're connected\n\tthis.connectionMade = function() {\n\t\tthis._isConnected = true;\n\t\tthis._onConnect.fire();\n\t}\n\t\n\tthis.connectionLost = function(err) {\n\t\tfor (var i in this._requests) {\n\t\t\tvar req = this._requests[i];\n\t\t\tdelete this._requests[i];\n\t\t\treq._onError.fire(err);\n\t\t}\n\t\t\n\t\tthis._isConnected = false;\n\t\tthis._onDisconnect.fire(err);\n\t}\n\t\n\tthis.sendRequest = function(name, args, target, cb) {\n\t\tif (arguments.length > 4) { // allow bound functions (e.g. [this, 'onResponse', 123])\n\t\t\tcb = bind.apply(GLOBAL, Array.prototype.slice.call(arguments, 3));\n\t\t}\n\t\t\n\t\tvar frameArgs = {\n\t\t\tname: name,\n\t\t\targs: args\n\t\t};\n\t\t\n\t\tif (target) { frameArgs.target = target; }\n\t\t\n\t\tvar id = this.sendFrame('RPC', frameArgs),\n\t\t\treq = this._requests[id] = new RPCRequest(this, id);\n\t\t\n\t\tif (cb) {\n\t\t\treq.onSuccess(GLOBAL, cb, false); // will call cb(false, args...)\n\t\t\treq.onError(GLOBAL, cb); // will call cb(err)\n\t\t}\n\t\t\n\t\treturn req;\n\t}\n\t\n\tthis.sendEvent = function(name, args, target) {\n\t\tthis.sendFrame('EVENT', {name: name, args: args, target: target || null});\n\t}\n\t\n\tthis.frameReceived = function(id, name, args) {\n\t\tlogger.debug('RECEIVED', id, name, args);\n\t\tswitch(name.toUpperCase()) {\n\t\t\tcase 'RESPONSE':\n\t\t\t\tvar req = this._requests[args.id];\n\t\t\t\tif (!req) { return; }\n\t\t\t\tdelete this._requests[args.id];\n\t\t\t\treq._onSuccess.fire(args.args);\n\t\t\t\tbreak;\n\t\t\tcase 'ERROR':\n\t\t\t\tvar msg = args.msg || 'unknown',\n\t\t\t\t\trequestId = args.id,\n\t\t\t\t\treq = this._requests[requestId],\n\t\t\t\t\terr = new Error(this, id, msg, args.details, requestId);\n\t\t\t\t\n\t\t\t\tif (!req) {\n\t\t\t\t\treturn this.errorReceived(err);\n\t\t\t\t} else {\n\t\t\t\t\tdelete this._requests[requestId];\n\t\t\t\t\treq._onError.fire(err);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'RPC':\n\t\t\tcase 'EVENT':\n\t\t\t\tif (!args.name) {\n\t\t\t\t\treturn self.sendFrame('ERROR', { 'id': args.id || id, 'msg': 'missing \"name\"' });\n\t\t\t\t}\n\t\t\t\tvar frameArgs = args.args || {},\n\t\t\t\t\ttarget = args.target || null,\n\t\t\t\t\tisRPC = name.toUpperCase() == 'RPC',\n\t\t\t\t\treqCtor = isRPC ? ReceivedRequest : ReceivedEvent,\n\t\t\t\t\tpubTarget = isRPC ? this.onRequest : this.onEvent,\n\t\t\t\t\treq = new reqCtor(this, args.id || id, args.name, frameArgs, target);\n\t\t\t\t\n\t\t\t\tpubTarget.publish(req.name, req);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n});\n","pre":true},"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/net/protocols/rtjp.js":{"path":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/net/protocols/rtjp.js","friendlyPath":"net.protocols.rtjp","directory":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/net/protocols/","filename":"rtjp.js","src":"jsio('import net.interfaces');\njsio('from net.protocols.delimited import DelimitedProtocol');\n\n/**\n * @extends net.protocols.delimited.DelimitedProtocol\n */\nexports.RTJPProtocol=__class__;exports.RTJPProtocol=exports.RTJPProtocol(function exports_RTJPProtocol(){return this.init&&this.init.apply(this,arguments)},DelimitedProtocol, function(supr) {\n\tthis.init = function() {\n\t\tvar delimiter = '\\r\\n';\n\t\tsupr(this, 'init', [delimiter]);\n\t\tthis.frameId = 0;\n\t}\n\n\tthis.connectionMade = function() {\n\t\tif (this._client && this._client.connectionMade) { this._client.connectionMade(); }\n\t\tlogger.debug(\"connectionMade\");\n\t}\n\t\n\tvar error = function(e) {\n\t\tlogger.error(e);\n\t}\n\t\n\t// Inherit and overwrite\n\tthis.frameReceived = function(id, name, args) {\n\t}\n\n\t// Public\n\tthis.sendFrame = function(name, args) {\n\t\tif (!args) {\n\t\t\targs = {}\n\t\t}\n\t\tlogger.debug('sendFrame', name, JSON.stringify(args));\n\t\tthis.sendLine(JSON.stringify([++this.frameId, name, args]));\n\t\treturn this.frameId;\n\t}\n\n\tthis.lineReceived = function(line) {\n\t\ttry {\n\t\t\tvar frame = JSON.parse(line);\n\t\t\tif (frame.length != 3) {\n\t\t\t\treturn error.call(this, \"Invalid frame length\");\n\t\t\t}\n\t\t\tif (typeof(frame[0]) != \"number\") {\n\t\t\t\treturn error.call(this, \"Invalid frame id\");\n\t\t\t}\n\t\t\tif (typeof(frame[1]) != \"string\") {\n\t\t\t\treturn error.call(this, \"Invalid frame name\");\n\t\t\t}\n\t\t\tlogger.debug(\"frameReceived:\", frame[0], frame[1], JSON.stringify(frame[2]));\n\t\t} catch(e) {\n\t\t\terror.call(this, e);\n\t\t}\n\t\t\n\t\tif (frame) {\n\t\t\tthis.frameReceived(frame[0], frame[1], frame[2]);\n\t\t}\n\t}\n\n\tthis.connectionLost = function() {\n\t\tlogger.debug('conn lost');\n\t}\n});\n\n\n\n","pre":true},"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/net/protocols/delimited.js":{"path":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/net/protocols/delimited.js","friendlyPath":"net.protocols.delimited","directory":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/net/protocols/","filename":"delimited.js","src":"jsio('import net.interfaces');\n\n/**\n * @extends net.interfaces.Protocol\n */\nexports.DelimitedProtocol=__class__;exports.DelimitedProtocol=exports.DelimitedProtocol(function exports_DelimitedProtocol(){return this.init&&this.init.apply(this,arguments)},net.interfaces.Protocol, function(supr) {\n\n\tthis.init = function(delimiter) {\n\t\tif (!delimiter) {\n\t\t\tdelimiter = '\\r\\n'\n\t\t}\n\t\tthis.delimiter = delimiter;\n\t\tthis.buffer = \"\"\n\t}\n\t\n\tthis.connectionMade = function() {\n\t\tlogger.debug('connectionMade');\n\t}\n\t\n\tthis.dataReceived = function(data) {\n\t\tif (!data) { return; }\n\t\tlogger.debug('dataReceived:(' + data.length + ')', data);\n\t\tlogger.debug('last 2:', JSON.stringify(data.slice(data.length-2)));\n\t\tthis.buffer += data;\n\t\tvar i;\n\t\twhile ((i = this.buffer.indexOf(this.delimiter)) != -1) {\n\t\t\tvar line = this.buffer.slice(0, i);\n\t\t\tthis.buffer = this.buffer.slice(i + this.delimiter.length);\n\t\t\tthis.lineReceived(line);\n\t\t}\n\t}\n\n\tthis.lineReceived = function(line) {\n\t\tlogger.debug('Not implemented, lineReceived:', line);\n\t}\n\tthis.sendLine = function(line) {\n\t\tlogger.debug('WRITE:', JSON.stringify(line + this.delimiter));\n\t\tthis.transport.write(line + this.delimiter);\n\t}\n\tthis.connectionLost = function() {\n\t\tlogger.debug('connectionLost');\n\t}\n});\n\n","pre":true},"../../../../sdk/timestep/ui/ImageView.js":{"path":"../../../../sdk/timestep/ui/ImageView.js","friendlyPath":"ui.ImageView","directory":"../../../../sdk/timestep/ui/","filename":"ImageView.js","src":"/**\n * @class ui.ImageView;\n * Import the ImageView from the Canvas/DOM rendering backend.\n *\n * @doc http://doc.gameclosure.com/api/ui-imageview.html\n * @docsrc https://github.com/gameclosure/doc/blob/master/api/ui/imageview.md\n */\n\njsio(\"import device\");\nexports = device.importUI('ImageView');\n","pre":true},"../../../../sdk/timestep/ui/widget/UIImageView.js":{"path":"../../../../sdk/timestep/ui/widget/UIImageView.js","friendlyPath":"ui.widget.UIImageView","directory":"../../../../sdk/timestep/ui/widget/","filename":"UIImageView.js","src":"/**\n * @package ui.widget.UIImageView;\n * @deprecated\n * @shim\n *\n * DEPRECATED. Renamed to ui.ImageScaleView.\n * The scaling should be working in to ui.ImageView, and perhaps the rest discarded.\n */\nlogger.warn('ui.widget.UIImageView is deprecated. Import ui.ImageScaleView instead.');\njsio(\"import ui.ImageScaleView as exports\");\n","pre":true},"../../../../sdk/timestep/ui/ImageScaleView.js":{"path":"../../../../sdk/timestep/ui/ImageScaleView.js","friendlyPath":"ui.ImageScaleView","directory":"../../../../sdk/timestep/ui/","filename":"ImageScaleView.js","src":"/**\n * @class ui.ImageScaleView\n *\n * @doc http://doc.gameclosure.com/api/ui-imageview.html#class-ui.imagescaleview\n * @docsrc https://github.com/gameclosure/doc/blob/master/api/ui/imageview.md\n */\n\njsio(\"import ui.View\");\njsio(\"import ui.resource.Image as Image\");\n\nvar sdk_timestep_ui_ImageScaleView=__class__;exports=sdk_timestep_ui_ImageScaleView(function sdk_timestep_ui_ImageScaleView(){return this.init&&this.init.apply(this,arguments)},ui.View, function (supr) {\n\n\tvar defaults = {\n\t\t\timage: null,\n\t\t\tautoSize: false,\n\t\t\tscaleMethod: 'stretch',\n\t\t\trenderCenter: true,\n\t\t\tclip: true\n\t\t};\n\n\tthis.init = function (opts) {\n\t\tvar opts = merge(opts, defaults);\n\t\tsupr(this, 'init', [opts]);\n\t};\n\n\tthis.updateOpts = function(opts) {\n\t\topts = supr(this, 'updateOpts', arguments);\n\n\t\tif (opts.scaleMethod) { this._scaleMethod = opts.scaleMethod; }\n\t\tif (opts.image) { this.setImage(opts.image, opts); }\n\t\tif (opts.verticalAlign) { this._verticalAlign = opts.verticalAlign; }\n\t\tif (opts.align) { this._align = opts.align; }\n\n\t\tthis.debug = (opts.debug) ? true : false;\n\n\t\t// {horizontal: {left: n, center: n, right: n}, vertical: {top: n, middle: n, bottom: n}}\n\t\tthis._sourceSlices = opts.sourceSlices;\n\t\t// {horizontal: {left: n, right: n}, vertical: {top: n, bottom: n}}\n\t\tthis._destSlices = opts.destSlices;\n\n\t\tif (this._sourceSlices && this._destSlices) {\n\t\t\tthis._sourceSlicesHor = [opts.sourceSlices.horizontal.left, opts.sourceSlices.horizontal.center, opts.sourceSlices.horizontal.right];\n\t\t\tthis._sourceSlicesVer = [opts.sourceSlices.vertical.top, opts.sourceSlices.vertical.middle, opts.sourceSlices.vertical.bottom];\n\t\t\tthis._destSlicesHor = [opts.destSlices.horizontal.left, 0, opts.destSlices.horizontal.right];\n\t\t\tthis._destSlicesVer = [opts.destSlices.vertical.top, 0, opts.destSlices.vertical.bottom];\n\t\t\tthis._checkBounds = true;\n\t\t}\n\n\t\treturn opts;\n\t};\n\n\tthis.getImage = function() { return this._img; };\n\n\tthis.setImage = function(img, opts) {\n\t\tif (typeof img == 'string') {\n\t\t\tthis._img = new Image({url: img});\n\t\t} else {\n\t\t\tthis._img = img;\n\t\t}\n\n\t\tif (this._img) {\n\t\t\tif (opts && opts.autoSize) {\n\t\t\t\tthis._img.doOnLoad(this, 'autoSize', opts.autoSize);\n\t\t\t}\n\n\t\t\tthis._img.doOnLoad(this, 'needsRepaint');\n\t\t}\n\t};\n\n\tthis.doOnLoad = function() {\n\t\tif (arguments.length == 1) {\n\t\t\tthis._img.doOnLoad(this, arguments[0]);\n\t\t} else {\n\t\t\tthis._img.doOnLoad.apply(this._img, arguments);\n\t\t}\n\t\treturn this;\n\t};\n\n\tthis.autoSize = function(method, url, width, height) {\n\t\tswitch (method) {\n\t\t\tcase 'resize':\n\t\t\tcase true:\n\t\t\t\tthis._scaleMethod = false;\n\t\t\t\tthis.style.width = width;\n\t\t\t\tthis.style.height = height;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthis._scaleMethod = method || false;\n\t\t\t\tbreak;\n\t\t}\n\t};\n\n\tthis.getOrigWidth = this.getOrigW = function() { return this._img.getOrigW(); };\n\tthis.getOrigHeight = this.getOrigH = function() { return this._img.getOrigH(); };\n\n\tthis.render = function(ctx) {\n\t\tif (!this._img) { return; }\n\n\t\tvar s = this.style;\n\t\tvar w = s.width;\n\t\tvar h = s.height;\n\n\t\tvar bounds = this._img.getBounds();\n\t\tvar iw = bounds.width;\n\t\tvar ih = bounds.height;\n\n\t\tswitch (this._scaleMethod) {\n\t\t\tcase 'none':\n\t\t\t\tthis._img.render(ctx, 0, 0);\n\t\t\t\tbreak;\n\n\t\t\tcase 'stretch':\n\t\t\t\tthis._img.render(ctx, 0, 0, w, h);\n\t\t\t\tbreak;\n\n\t\t\tcase 'contain':\n\t\t\tcase 'cover':\n\t\t\t\tvar scale = 1;\n\t\t\t\tvar targetRatio = iw / ih;\n\t\t\t\tvar ratio = w / h;\n\t\t\t\tif (this._scaleMethod == 'cover' ? ratio > targetRatio : ratio < targetRatio) {\n\t\t\t\t\tscale = w / iw;\n\t\t\t\t} else {\n\t\t\t\t\tscale = h / ih;\n\t\t\t\t}\n\t\t\t\tvar finalWidth = iw * scale;\n\t\t\t\tvar finalHeight = ih * scale;\n\t\t\t\tvar x = this._align == 'left' ? 0 : this._align == 'right' ? w - finalWidth : (w - finalWidth) / 2;\n\t\t\t\tvar y = this._verticalAlign == 'top' ? 0 : this._verticalAlign == 'bottom' ? h - finalHeight : (h - finalHeight) / 2;\n\t\t\t\tthis._img.render(ctx, x, y, finalWidth, finalHeight);\n\t\t\t\tbreak;\n\n\t\t\tcase '9slice':\n\t\t\t\tvar debugColors = ['#FF0000', '#00FF00', '#0000FF'];\n\t\t\t\tvar image = this._img.getSource();\n\t\t\t\tvar bounds = this._img.getBounds();\n\t\t\t\tvar sourceSlicesHor = this._sourceSlicesHor;\n\t\t\t\tvar sourceSlicesVer = this._sourceSlicesVer;\n\t\t\t\tvar destSlicesHor = [];\n\t\t\t\tvar destSlicesVer = [];\n\t\t\t\tvar style = this.style;\n\t\t\t\tvar width = style.width;\n\t\t\t\tvar height = style.height;\n\t\t\t\tvar sx, sy, sw, sh;\n\t\t\t\tvar dx, dy, dw, dh;\n\t\t\t\tvar i, j;\n\n\t\t\t\tif ((bounds.width <= 0) || (bounds.height <= 0)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (this._checkBounds) {\n\t\t\t\t\tthis._checkBounds = false;\n\t\t\t\t\tsw = 0;\n\t\t\t\t\tsh = 0;\n\t\t\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\t\t\tsw += sourceSlicesHor[i];\n\t\t\t\t\t\tsh += sourceSlicesVer[i];\n\t\t\t\t\t}\n\t\t\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\t\t\tsourceSlicesHor[i] = (sourceSlicesHor[i] * bounds.width / sw) | 0;\n\t\t\t\t\t\tsourceSlicesVer[i] = (sourceSlicesVer[i] * bounds.height / sh) | 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdestSlicesHor[0] = this._destSlicesHor[0];\n\t\t\t\tdestSlicesHor[2] = this._destSlicesHor[2];\n\t\t\t\tdestSlicesHor[1] = width - destSlicesHor[0] - destSlicesHor[2];\n\t\t\t\tif (destSlicesHor[1] < 0) {\n\t\t\t\t\tdw = destSlicesHor[0] + destSlicesHor[2];\n\t\t\t\t\tdestSlicesHor[0] = (destSlicesHor[0] * width / dw) | 0;\n\t\t\t\t\tdestSlicesHor[1] = 0;\n\t\t\t\t\tdestSlicesHor[2] = width - destSlicesHor[0];\n\t\t\t\t}\n\n\t\t\t\tdestSlicesVer[0] = this._destSlicesVer[0];\n\t\t\t\tdestSlicesVer[2] = this._destSlicesVer[2];\n\t\t\t\tdestSlicesVer[1] = height - destSlicesVer[0] - destSlicesVer[2];\n\t\t\t\tif (destSlicesVer[1] < 0) {\n\t\t\t\t\tdh = destSlicesVer[0] + destSlicesVer[2];\n\t\t\t\t\tdestSlicesVer[0] = (destSlicesVer[0] * height / dh) | 0;\n\t\t\t\t\tdestSlicesVer[1] = 0;\n\t\t\t\t\tdestSlicesVer[2] = height - destSlicesVer[0];\n\t\t\t\t}\n\n\t\t\t\tsy = bounds.y;\n\t\t\t\tdy = 0;\n\t\t\t\tfor (j = 0; j < 3; j++) {\n\t\t\t\t\tsh = sourceSlicesVer[j];\n\t\t\t\t\tdh = destSlicesVer[j];\n\t\t\t\t\tsx = bounds.x;\n\t\t\t\t\tdx = 0;\n\t\t\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\t\t\tsw = sourceSlicesHor[i];\n\t\t\t\t\t\tdw = destSlicesHor[i];\n\t\t\t\t\t\tif ((dw > 0) && (dh > 0)) {\n\t\t\t\t\t\t\tctx.drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh);\n\t\t\t\t\t\t\tif (this.debug) {\n\t\t\t\t\t\t\t\tctx.strokeStyle = debugColors[(j + i) % 3];\n\t\t\t\t\t\t\t\tctx.strokeRect(dx + 0.5, dy + 0.5, dw - 1, dh - 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tsx += sw;\n\t\t\t\t\t\tdx += dw;\n\t\t\t\t\t}\n\t\t\t\t\tsy += sh;\n\t\t\t\t\tdy += dh;\n\t\t\t\t}\n\t\t\t\tbreak; //end 9slice\n\t\t}\n\t};\n\n\tthis.getTag = function() { return 'ImageScaleView' + this.uid + ':' + (this._img && this._img._map.url.substring(0, 16)); };\n});\n","pre":true},"../../../../sdk/timestep/ui/TextView.js":{"path":"../../../../sdk/timestep/ui/TextView.js","friendlyPath":"ui.TextView","directory":"../../../../sdk/timestep/ui/","filename":"TextView.js","src":"/**\n * @class ui.TextView;\n * Import the Canvas/DOM implementation of TextView.\n *\n * @doc http://doc.gameclosure.com/api/ui-text.html#class-ui.textview\n * @docsrc https://github.com/gameclosure/doc/blob/master/api/ui/text.md\n */\n\njsio(\"import device\");\n\nexports = device.importUI('TextView');\n","pre":true},"../../../../sdk/_api/client/init.js":{"path":"../../../../sdk/_api/client/init.js","friendlyPath":"_api.client.init","directory":"../../../../sdk/_api/client/","filename":"init.js","src":"// Import this before importing GC\n// _api.client.init sets up the GC object for the client apis\n\njsio(\"import ..shared.Common\");\njsio(\"import std.uri as URI\");\n\njsio(\"import GCDataSource\");\n\nif (!GLOBAL.CONFIG) { GLOBAL.CONFIG = {}; }\nif (!GLOBAL.DEBUG) { GLOBAL.DEBUG = false; }\n\nvar uid = 0;\n\nNotification=__class__;var Notification=Notification(function Notification(){return this.init&&this.init.apply(this,arguments)},function() {\n\tthis.init = function(opts) {\n\t\tthis.type = opts.type;\n\t\tthis.created = new Date(opts.created);\n\t\tthis.source = opts.source;\n\t\tthis.app = opts.app;\n\t\tthis.data = opts.data;\n\t\tthis.id = opts.id;\n\t\tthis.showInStatusBar = opts.showInStatusBar;\n\t\tthis._wasHandled = false;\n\t}\n\n\tthis.wasHandled = function () { return this._wasHandled; }\n\n\tthis.handled = function() {\n\t\tthis._wasHandled = true;\n\t\t_notifications.remove(this);\n\t\tif (GLOBAL.NATIVE && NATIVE.alerts) {\n\t\t\tNATIVE.alerts.cancelNotification(this.id);\n\t\t}\n\t}\n});\n\n_notifications = new GCDataSource({ctor: Notification});\n\nif (GLOBAL.NATIVE && NATIVE.alerts) {\n\tNATIVE.alerts.subscribe('New', function(value) {\n\t\tvar item = _notifications.add(value);\n\t\tGC._handlePushNotification(item);\n\t});\n}\n\nvar sdk__api_client_init=__class__;exports=sdk__api_client_init(function sdk__api_client_init(){return this.init&&this.init.apply(this,arguments)},shared.Common, function() {\n\tvar ua = navigator.userAgent;\n\tthis.isNative = /TeaLeaf/.test(ua);\n\tif (this.isNative) {\n\t\tthis.isIOS = /iPhone OS/.test(ua);\n\t\tthis.isAndroid = /Android/.test(ua);\n\t} else if (/(iPod|iPhone|iPad)/i.test(ua)) {\n\t\tthis.isMobileBrowser = true;\n\t\tthis.isIOS = true;\n\t\tthis.isUIWebView = !/Safari/.test(ua);\n\t} else if (/Android/.test(ua)) {\n\t\tthis.isMobileBrowser = true;\n\t\tthis.isAndroid = true;\n\t} else {\n\t\tthis.isDesktop = true;\n\t\tthis.isFacebook = GLOBAL.CONFIG.isFacebookApp;\n\t}\n\n\tthis.__init__ = function (opts) {\n\t\tif (DEBUG) {\n\t\t\tif (GLOBAL.window && window.top) {\n\t\t\t\twindow.top.GC = GLOBAL.GC;\n\t\t\t}\n\t\t}\n\n\t\tif (GLOBAL.ADDON_SOCIAL && ADDON_SOCIAL) {\n\n\t\t\tjsio(\"import GCSocial.GCSocial\");\n\t\t\tGC.social = GCSocial.GCSocial;\n\t\t\t\n\t\t\tGLOBAL.gcsocial = GC.social; // deprecated\n\n\t\t\tGC.social.init({\n\t\t\t\tappID: GLOBAL.CONFIG.appID,\n\t\t\t\tshortName: GLOBAL.CONFIG.shortName,\n\t\t\t\tinviteURLTemplate: GLOBAL.CONFIG.inviteURLTemplate,\n\t\t\t\tendpoint: GLOBAL.CONFIG.servicesURL,\n\t\t\t});\n\n\t\t\tthis.track = gcsocial.tracker;\n\t\t}\n\n\t\twindow.addEventListener('pageshow', bind(this, '_onShow'), false);\n\n\t\twindow.addEventListener('pagehide', bind(this, '_onHide'), false);\n\n\t\tthis.isOnline = navigator.onLine;\n\n\t\twindow.addEventListener('online', bind(this, function() {\n\t\t\tif (!this.isOnline) {\n\t\t\t\tthis.isOnline = true;\n\t\t\t\tthis.publish('OnlineStateChanged', true);\n\t\t\t}\n\t\t}), false);\n\n\t\twindow.addEventListener('offline', bind(this, function() {\n\t\t\tif (this.isOnline) {\n\t\t\t\tthis.isOnline = false;\n\t\t\t\tthis.publish('OnlineStateChanged', false);\n\t\t\t}\n\t\t}), false);\n\n\t\t// var uri = new URI(window.location);\n\t\t// var campaign = uri.query('campaign') || \"NO CAMPAIGN\";\n\t\t//\n\t\t// XXX: The following lines cause a DOMException in some browsers\n\t\t// because we're using a <base> tag, which doesn't resolve the URL relative correctly.\n\t\t//get rid of it in case the game uses something\n\t\t// if (window.history && window.history.replaceState) {\n\t\t// \thistory.replaceState(null, null, uri.toString().replace(\"?campaign=\" + campaign, \"\"));\n\t\t// }\n\t\t//\n\t\t// if (!localStorage.getItem(\"campaignID\")) {\n\t\t// \tlocalStorage.setItem(\"campaignID\", campaign)\n\t\t// }\n\n\n\t\tif (CONFIG.version) {\n\t\t\tlogger.log('Version', CONFIG.version);\n\t\t}\n\n\t\tjsio(\"import .Application\");\n\n\t\topts = merge(opts, {\n\t\t\tui: false,\n\t\t\toverlay: false,\n\t\t\tinvites: true,\n\t\t\tscores: true,\n\t\t\tgames: true,\n\t\t\tcontacts: true\n\t\t});\n\n\t\tthis.Application = Application;\n\n\t\t// this.track({\n\t\t// \tname: \"campaignID\",\n\t\t// \tcategory: \"campaign\",\n\t\t// \tsubcategory: \"id\",\n\t\t// \tdata: campaign\n\t\t// });\n\n\t\tif (opts.ui) {\n\t\t\tjsio('import _api.client.UI as UI');\n\t\t\tthis.ui = new UI();\n\t\t}\n\n\t\tif (opts.overlay) {\n\t\t\tvar OverlayAPI = jsio('import .OverlayAPI');\n\t\t\tthis.overlay = new OverlayAPI(this.env);\n\t\t}\n\n\t\ttry {\n\t\t\tvar map = JSON.parse(GLOBAL.CACHE['spritesheets/map.json']);\n\t\t} catch (e) {\n\t\t\tlogger.warn(\"spritesheet map failed to parse\", e);\n\t\t}\n\t\t\n\t\tjsio(\"import ui.resource.loader\");\n\t\tthis.resources = ui.resource.loader;\n\t\tthis.resources.setMap(map);\n\n\t\tif (this.env == 'browser') { setTimeout(bind(this, '_onShow'), 0); }\n\t}\n\n\n\tthis._onHide = function() {\n\t\t// signal to the app that the window is going away\n\t\tthis.app && this.app.onPause();\n\n\t\tthis.publish('Hide');\n\t\tthis.publish('AfterHide');\n\n\t\tif (this.tracker) {\n\t\t\tthis.tracker.endSession();\n\t\t}\n\t};\n\n\tthis._onShow = function() {\n\t\tthis.app && this.app.onResume();\n\n\t\tthis.publish('Show');\n\t\tthis.publish('AfterShow');\n\t}\n\n\tthis.buildApp = function(entry) {\n\t\ttry {\n\t\t\tjsio(\"import src.Application as Application\");\n\t\t\tthis.app = new Application();\n\t\t\tthis.app.subscribe('onLoadError', this, '_onAppLoadError');\n\n\t\t\tGC.Application.start(this.app, entry);\n\t\t} catch(error) {\n\t\t\tthis._onAppLoadError(error);\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn this.app;\n\t};\n\n\tthis._onAppLoadError = function(error) {\n\t\tlogger.error('encountered error when creating src Application: ', JSON.stringify(error));\n\t\tvar preloader = CONFIG.preload;\n\t\tif(preloader && preloader.onAppLoadError) {\n\t\t\tpreloader.onAppLoadError(error);\n\t\t}\n\t};\n\n\tthis.hidePreloader = function(cb) {\n\t\tvar preloader = CONFIG.preload;\n\t\tif (preloader && preloader.hide && !preloader.hidden) {\n\t\t\tpreloader.hide(cb);\n\t\t\tpreloader.hidden = true;\n\t\t} else {\n\t\t\tcb && cb();\n\t\t}\n\t};\n\n\tthis._handlePushNotification = function(item) {\n\t\t// allow internal GC APIs to catch and handle push notifications\n\t\tthis.publish('__internal_push_notification', item);\n\n\t\t// if no one handled it...\n\t\tif (!item.wasHandled()) {\n\t\t\tthis.publish('PushNotificationReceived', item);\n\t\t}\n\t}\n\n\tthis.getPushNotifications = function() { return _notifications.toArray(); }\n\tthis.clearPushNotifications = function() {\n\t\t_notifications.toArray().forEach(function(n) {\n\t\t\tn.handled();\n\t\t});\n\t};\n});\n\nGLOBAL.GC = new exports();\n","pre":true},"../../../../sdk/_api/shared/Common.js":{"path":"../../../../sdk/_api/shared/Common.js","friendlyPath":"..shared.Common","directory":"../../../../sdk/_api/shared/","filename":"Common.js","src":"\"use import\";\n\njsio(\"import math.util\");\njsio(\"import lib.PubSub\");\n\nvar sdk__api_shared_Common=__class__;exports=sdk__api_shared_Common(function sdk__api_shared_Common(){return this.init&&this.init.apply(this,arguments)},lib.PubSub, function() {\n\t\n\tvar baseJsio = jsio.__jsio;\n\tlogger.log(baseJsio.__env.name, ' is name');\n\tswitch(baseJsio.__env.name) {\n\t\tcase 'node':\n\t\tcase 'jsrunner':\n\t\t\tthis.env = 'server';\n\t\t\tbreak;\n\t\tcase 'browser':\n\t\t\tthis.env = 'browser';\n\t\t\tbreak;\n\t\tcase 'ios':\n\t\t\tthis.env = 'ios';\n\t\t\tbreak;\n\t\tcase 'android':\n\t\t\tthis.env = 'android';\n\t\t\tbreak;\n\t}\n\n});\n\n","pre":true},"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/math/util.js":{"path":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/math/util.js","friendlyPath":"math.util","directory":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/math/","filename":"util.js","src":"jsio('import lib.Enum as Enum');\n\n/**\n * @package math.util;\n */\n\n/**\n * Interpolate between values a and b at the point x in the interval.\n */\n\nexports.interpolate = function(a, b, x) { return a * (1 - x) + b * x; }\n\n/**\n * Return a random integer between a and b. Optionally, a random seed can be\n * given.\n */\n\nexports.random = function(a, b, rand) { return a + ((rand || Math.random)() * (b - a) | 0); }\n\n/**\n * Return a random integer between a and b, inclusive. Optionally, a random seed\n * can be given.\n */\n\nexports.randomInclusive = function(a, b, rand) { return exports.random(a, b+1, rand); }\n\n/**\n * Return a value where min <= num <= max.\n */\n\nexports.clip = function(num, min, max) { return Math.max(Math.min(num, max), min); }\n\n/**\n * Return the sign of a number.\n */\n\nexports.sign = function (num) {\n\treturn num && num / Math.abs(num);\n};\n\n/**\n * Rounding a value with the given precision, given the provided rounding\n * method.\n */\n\nvar round = exports.round = function(a, precision, method) {\n\tif (!method || method == round.ROUND_HALF_AWAY_FROM_ZERO) {\n\t\treturn a.toFixed(precision);\n\t}\n\t\n\tif(!precision) {\n\t\tif (method == round.ROUND_HALF_UP) { Math.round(a); }\n\t\n\t\t//FIXME integer is a reserved word XXX\t\n\t\tvar integer = a | 0,\n\t\t\tfrac = a - integer \n\t\t\thalf = frac == 0.5 || frac == -0.5;\n\t\tif (!half) { return Math.round(a); }\n\t\t\n\t\tvar sign = a < 0 ? -1 : 1;\n\t\tswitch(method) {\n\t\t\tcase round.ROUND_HALF_TO_EVEN:\n\t\t\t\treturn integer % 2 ? integer + sign : integer \n\t\t\tcase round.ROUND_HALF_TO_ODD:\n\t\t\t\treturn integer % 2 ? integer : integer + sign;\n\t\t\tcase round.ROUND_HALF_STOCHASTIC:\n\t\t\t\treturn Math.random() < 0.5 ? integer + sign : integer \n\t\t\tcase round.ROUND_HALF_ALTERNATE:\n\t\t\t\treturn (round.alt = !round.alt) ? integer + sign : integer \n\t\t}\n\t}\n\t\n\tvar integer = a | 0,\n\t\tfrac = a - integer \n\t\tp = Math.pow(10, precision);\n\treturn (integer + round(frac * p, 0, method) / p).toFixed(precision);\n}\n\n/**\n * Available rounding possibilities.\n */\n\nEnum.call(round, 'ROUND_HALF_UP', 'ROUND_HALF_AWAY_FROM_ZERO', 'ROUND_HALF_TO_EVEN', 'ROUND_HALF_TO_ODD', 'ROUND_HALF_STOCHASTIC', 'ROUND_HALF_ALTERNATE');\n\n/**\n * Alternating flag for rounding strategy ROUND_HALF_ALTERNATE.\n */\n\nround.alt = true;\n","pre":true},"../../../../sdk/api/GCDataSource.js":{"path":"../../../../sdk/api/GCDataSource.js","friendlyPath":"GCDataSource","directory":"../../../../sdk/api/","filename":"GCDataSource.js","baseMod":"GCDataSource","basePath":"../../../../sdk/api","src":"/**\n * @extends squill.models.DataSource\n */\nexports = jsio('import squill.models.DataSource');\n","pre":true},"../../../../sdk/squill/models/DataSource.js":{"path":"../../../../sdk/squill/models/DataSource.js","friendlyPath":"squill.models.DataSource","directory":"../../../../sdk/squill/models/","filename":"DataSource.js","baseMod":"squill","basePath":"../../../../sdk","src":"\"use import\";\n\njsio(\"import lib.Callback\");\njsio(\"import .BasicDataSource as BasicDataSource\");\n\nvar sdk_squill_models_DataSource=__class__;var DataSource = exports=sdk_squill_models_DataSource(function sdk_squill_models_DataSource(){return this.init&&this.init.apply(this,arguments)},BasicDataSource, function(supr) {\n\n\tvar defaults = {\n\t\tkey: 'id'\n\t};\n\n\tthis.init = function(opts) {\n\t\tthis._opts = opts = merge(opts, defaults);\n\n\t\tsupr(this, 'init', [opts]);\n\n\t\tthis._byIndex = [];\n\t\tthis._byID = {};\n\t\tthis._ctor = opts.ctor;\n\t\tthis._reverse = opts.reverse;\n\n\t\tthis.length = 0;\n\n\t\tthis.onLoad = new lib.Callback();\n\n\t\tthis.setSorter(opts.sorter);\n\t\tthis.setPersistence(opts.persistence);\n\n\t\tthis._changeDataSave = false;\n\t\tthis._changeData = {\n\t\t\tupdated: [], \n\t\t\tupdatedHash: {},\n\t\t\tremoved: [],\n\t\t\tremovedHash: {}\n\t\t};\n\t};\n\n\tthis.setPersistence = function(persistence) {\n\t\tthis._persistence = persistence;\n\t\tif (persistence) {\n\t\t\tthis.onLoad.clear();\n\t\t\tpersistence.load(this, this.onLoad.chain());\n\t\t}\n\t}\n\n\tthis._saveChanges = function(type, key) {\n\t\tif (this._changeDataSave && !this._changeData[type + 'Hash'][key]) {\n\t\t\tthis._changeData[type + 'Hash'][key] = true;\n\t\t\tthis._changeData[type].push(key);\n\t\t}\n\t};\n\t\n\tthis.getFilteredDataSource = function(filterFn) {\n\t\tvar ds = new DataSource(this._opts);\n\t\tthis.forEach(function (item) {\n\t\t\tif (filterFn(item)) {\n\t\t\t\tds.add(item);\n\t\t\t}\n\t\t});\n\n\t\tthis.subscribe('Update', function (id, item) {\n\t\t\tif (filterFn(item)) {\n\t\t\t\tds.add(item);\n\t\t\t} else {\n\t\t\t\tds.remove(item);\n\t\t\t}\n\t\t});\n\n\t\tthis.subscribe('Remove', function (id, item) { ds.remove(item); });\n\t\treturn ds;\n\t};\n\n\tthis.signalUpdate = function(type, item, id) {\n\t\tif (item[this.key] === undefined) {\n\t\t\treturn;\n\t\t}\n\t\tswitch (type) {\n\t\t\tcase 'UPDATE':\n\t\t\t\tthis._saveChanges('updated', item[this.key]);\n\t\t\t\tthis.publish('Update', item[this.key], item);\n\t\t\t\tbreak;\n\n\t\t\tcase 'REMOVE':\n\t\t\t\tthis._saveChanges('removed', item[this.key]);\n\t\t\t\tthis.publish('Remove', id, item);\n\t\t\t\tbreak;\n\t\t}\n\t};\n\n\tvar toStringSort = function() {\n\t\treturn this._sortKey;\n\t};\n\t// NEVER CHANGE THE ID OF AN ITEM WITHOUT REMOVING IT FROM THE DATASOURCE FIRST.\n\t// Love, Jeff Hubbard and Marcus Cavanaugh\n\n\tthis.updated = \n\tthis.add = function(item) {\n\t\tif (isArray(item)) {\n\t\t\tfor (var i = 0, len = item.length; i < len; ++i) {\n\t\t\t\titem[i] && this.add(item[i]);\n\t\t\t}\n\t\t} else {\n\t\t\tvar id = item[this.key];\n\n\t\t\t// note: not the same as `if (!id) { ... }`\n\t\t\tif (id == null) { return; }\n\n\t\t\tvar index = null;\n\t\t\tif (this._byID[id]) {\n\t\t\t\tfor (var i = 0, _item; _item = this._byIndex[i]; ++i) {\n\t\t\t\t\tif (_item[this.key] == id) {\n\t\t\t\t\t\tif (typeof _item.update == 'function') {\n\t\t\t\t\t\t\t_item.update(item);\n\t\t\t\t\t\t\titem = _item;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tindex = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tindex = this.length++;\n\t\t\t}\n\n\t\t\t// if we're adding it to the array:\n\t\t\tif (index !== null) {\n\n\t\t\t\t// make sure it's an instance of the specified class\n\t\t\t\tif (this._ctor && !(item instanceof this._ctor)) {\n\t\t\t\t\titem = new this._ctor(item);\n\t\t\t\t}\n\n\t\t\t\tthis._byIndex[index] = item;\n\t\t\t}\n\n\t\t\tthis._byID[id] = item;\n\n\t\t\tthis.signalUpdate('UPDATE', item);\n\n\t\t\tif (this._sorter) {\n\t\t\t\titem._sortKey = this._sorter(item);\n\t\t\t\titem.toString = toStringSort;\n\t\t\t}\n\t\t}\n\n\t\treturn item;\n\t};\n\t\n\tthis.remove = function(id) {\n\t\tif (typeof id == 'object') { id = id[this.key]; }\n\t\tif (id == null) { return; }\n\n\t\tif (this._byID[id]) {\n\t\t\tthis.signalUpdate('REMOVE', this._byID[id], id);\n\t\t\tdelete this._byID[id];\n\t\t\tfor (var i = 0, item; item = this._byIndex[i]; ++i) {\n\t\t\t\tif (item[this.key] == id) {\n\t\t\t\t\t--this.length;\n\t\t\t\t\treturn this._byIndex.splice(i, 1)[0];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tthis.keepOnly = function(list) {\n\t\tthis.compare(list, function(dataSource, local, remote) {\n\t\t\tif (!remote) {\n\t\t\t\tdataSource.remove(local);\n\t\t\t}\n\t\t});\n\t};\n\n\tthis.clear = function() {\n\t\tvar index = this._byIndex;\n\n\t\tthis._byIndex = [];\n\t\tthis._byID = {};\n\t\tthis.length = 0;\n\n\t\tfor (var i = 0, item; item = index[i]; ++i) {\n\t\t\tthis.signalUpdate('REMOVE', item, item[this.key]);\n\t\t}\n\t};\n\n\tthis.getCount = function() {\n\t\treturn this.length;\n\t};\n\n\tthis.setSorter = function(sorter) {\n\t\tthis._sorter = sorter;\n\t\tif (sorter) {\n\t\t\tfor (var i = 0, item; item = this._byIndex[i]; ++i) {\n\t\t\t\titem._sortKey = sorter(item);\n\t\t\t\titem.toString = toStringSort;\n\t\t\t}\n\t\t}\n\t\tthis.sort();\n\t\treturn this;\n\t};\n\n\tthis.contains = function(id) {\n\t\treturn !!this._byID[id];\n\t};\n\n\tthis.getKey = function() {\n\t\treturn this.key;\n\t}\n\n\tthis.get = this.getItemForID = function(id) {\n\t\treturn this._byID[id] || null;\n\t};\n\n\tthis.getItemForIndex = function(index) {\n\t\treturn this._byIndex[index];\n\t};\n\n\tthis.sort = function() {\n\t\tthis._byIndex.sort();\n\t\tthis._reverse && this._byIndex.reverse();\n\t};\n\n\tthis.forEach = this.each = function(cb, context) {\n\t\tfor (var i = 0; i < this.length; ++i) {\n\t\t\tif (cb.call(context, this._byIndex[i], i)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t};\n\n\tthis.toJSON = function() {\n\t\treturn {\n\t\t\tkey: this.key,\n\t\t\titems: this._byIndex\n\t\t};\n\t};\n\n\tthis.fromJSON = function(data) {\n\t\tthis.clear();\n\t\tvar key = this.key = data.key;\n\t\tthis.add(data.items);\n\t};\n\n\tthis.toArray = function() { return this._byIndex.slice(0); }\n\n\tthis.beginChanges = function() {\n\t\tthis._changeDataSave = true;\n\t\tthis._changeData = {\n\t\t\tupdated: [], \n\t\t\tupdatedHash: {},\n\t\t\tremoved: [],\n\t\t\tremovedHash: {}\n\t\t};\n\t};\n\n\tthis.saveChanges = function() {\n\t\tthis._changeDataSave = false;\n\t\tif (this._persistence) {\n\t\t\tvar changeData = this._changeData,\n\t\t\t\ti, j;\n\n\t\t\tthis._persistence.remove(changeData.removed);\n\n\t\t\tif (changeData.updated.length) {\n\t\t\t\tvar updateList = [];\n\t\t\t\tfor (i = 0, j = changeData.updated.length; i < j; i++) {\n\t\t\t\t\tupdateList.push(this._byID[changeData.updated[i]]);\n\t\t\t\t}\n\t\t\t\tthis._persistence.update(updateList);\n\t\t\t}\n\n\t\t\tthis._persistence.commit();\n\t\t}\n\t};\n\n\tthis.load = function(cb) {\n\t\tif (this._persistence) {\n\t\t\tthis._persistence.load(this, function(err) {\n\t\t\t\tif (err) {\n\t\t\t\t\tlogger.log('error loading', JSON.stringify(err));\n\t\t\t\t}\n\t\t\t\tcb && cb(err);\n\t\t\t});\n\t\t}\n\t};\n\n\tthis.save = function() {\n\t\tif (this._persistence) {\n\t\t\tthis._persistence.save(this);\n\t\t}\n\t}\n\n\tthis.compare = function(dict, cb) {\n\t\tvar key = this.key;\n\n\t\t// create a key-indexed copy of dict to run the comparison against\n\t\tvar compareTo = {};\n\t\tif (isArray(dict)) {\n\t\t\tfor (var i = 0, n = dict.length; i < n; ++i) {\n\t\t\t\tcompareTo[dict[i][key]] = dict[i];\n\t\t\t}\n\t\t} else {\n\t\t\tfor (var k in dict) {\n\t\t\t\tcompareTo[k] = dict[k];\n\t\t\t}\n\t\t}\n\n\t\t// first, compare all items in the index to the dict items\n\t\tvar items = this._byIndex.slice(0);\n\t\tfor (var i = 0, item; item = items[i]; ++i) {\n\t\t\tvar k = item[key];\n\t\t\tcb.call(this, this, item, compareTo[k]);\n\t\t\tdelete compareTo[k];\n\t\t}\n\n\t\t// then, for any remaining dict items, they don't exist in the local version\n\t\tfor (var k in compareTo) {\n\t\t\tcb.call(this, this, null, compareTo[k]);\n\t\t}\n\t}\n\n\tthis.filter = function(filter) {\n\t\tvar result = new DataSource({key: this.key});\n\t\tvar key;\n\t\tvar item;\n\t\tvar match;\n\t\tvar i;\n\t\tvar j = this.length;\n\n\t\tresult.key = this.key;\n\t\tfor (i = 0; i < j; ++i) {\n\t\t\titem = this._byIndex[i];\n\t\t\tmatch = true;\n\t\t\tfor (key in filter) {\n\t\t\t\tif ((typeof item[key] == 'string') && (item[key].toLowerCase().indexOf(filter[key]) == -1)) {\n\t\t\t\t\tmatch = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (match) {\n\t\t\t\tresult.add(item);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t};\n});\n","pre":true},"../../../../sdk/squill/models/BasicDataSource.js":{"path":"../../../../sdk/squill/models/BasicDataSource.js","friendlyPath":".BasicDataSource","directory":"../../../../sdk/squill/models/","filename":"BasicDataSource.js","src":"\"use import\";\n\njsio(\"import lib.PubSub as PubSub\");\n\nvar sdk_squill_models_BasicDataSource=__class__;var BasicDataSource = exports=sdk_squill_models_BasicDataSource(function sdk_squill_models_BasicDataSource(){return this.init&&this.init.apply(this,arguments)},PubSub, function(supr) {\n\tthis.init = function(opts) {\n\t\tsupr(this, 'init', arguments);\n\n\t\tthis.key = this._key = opts.key;\n\t\tthis._channel = opts.channel;\n\t\tthis._hasRemote = opts.hasRemote;\n\t};\n\n\tthis.getKey = function() {\n\t\treturn this._key;\n\t};\n});","pre":true},"../../../social/lib/GCSocial/GCSocial.js":{"path":"../../../social/lib/GCSocial/GCSocial.js","friendlyPath":"GCSocial.GCSocial","directory":"../../../social/lib/GCSocial/","filename":"GCSocial.js","baseMod":"GCSocial","basePath":"../../../social/lib","src":"jsio(\"import lib.PubSub as PubSub\");\njsio(\"import std.uri\");\njsio(\"import .App\");\njsio(\"import .User\");\njsio(\"import .CurrentUser\");\njsio(\"import .Notification\");\njsio(\"import .node.ff as ff\");\njsio(\"import .internal.CrossDomainLocalStorage as CrossDomainLocalStorage\");\njsio(\"import .internal.ObservableCollection as ObservableCollection\");\njsio(\"import .internal.tracker as tracker\");\njsio(\"import .internal.connection as Connection\");\njsio(\"import .internal.generator as generator\");\njsio(\"import std.uuid\");\njsio(\"import math.array\");\n\n\nvar ua = navigator.userAgent;\nvar IS_TEALEAF = /TeaLeaf/.test(navigator.userAgent); // use sparingly\nvar IS_IOS_WEBVIEW = !IS_TEALEAF && (/(iPod|iPhone|iPad)/i.test(ua) && !/Safari/.test(ua));\n\nif (IS_IOS_WEBVIEW) {\n\tconsole.log = function(log) {\n\t\tvar iframe = document.createElement(\"IFRAME\");\n\t\tiframe.setAttribute(\"src\", \"ios-log:\" + log);\n\t\tdocument.documentElement.appendChild(iframe);\n\t\tiframe.parentNode.removeChild(iframe);\n\t\tiframe = null;\n\t}\n}\n/**\n * @module GCSocial\n */\n\n// TODO: if you request notifications/invites before you get\n// native/server contacts, you might not get full users back...\n\n/**\n * The GCSocial class (exposed as `window.gcsocial`) is the entry point\n * for all social functionality. You'll use this class to directly\n * access global settings like notifications and configuration.\n *\n * The init function must be called first to initialize GC Social:\n *\n *     gcsocial.init({appID: \"YOUR_APP_ID\"});\n *\n * **User-specific actions, friend lists, etc., are provided through the\n * {{#crossLink \"CurrentUser\"}}{{/crossLink}} class:**\n *\n *     var name = gcsocial.user.getName();\n *\n * **App-specific actions are provided via {{#crossLink \"App\"}}{{/crossLink}}:**\n *\n *     gcsocial.app.getScores(function (err, scores) { ... });\n *\n * **EVENT DOCUMENTATION**\n *\n * - **\"install\"**: {referrer: \"some&referrer\"}\n *\n * @class gcsocial\n * @static\n */\nGCSocial=__class__;var GCSocial=GCSocial(function GCSocial(){return this.init&&this.init.apply(this,arguments)},PubSub, function () {\n\tvar INVITE_CACHE_SIZE = 500;\n\n\tvar LOGGED_OUT = \"loggedOut\";\n\tvar LOGGING_IN = \"loggingIn\";\n\tvar LOGGED_IN = \"loggedIn\";\n\n\t// WITH_GC_SOCIAL is a private interface used for loading in runtimeBrowser.\n\n\t// public interface\n\n\tthis._construct = function () {\n\t\tthis.isTeaLeaf = IS_TEALEAF;\n\t\tthis.isNative = !!(this.isTeaLeaf || window.NativeSocial || IS_IOS_WEBVIEW);\n\n\t\tif (this.isTeaLeaf) {\n\t\t\tNATIVE.social.subscribe(\"NativeSocial\", this._handleNativeEvent.bind(this));\n\t\t} else {\n\t\t\twindow.onNativeSocialEvent = function(urlEncodedData) {\n\t\t\t\tvar data = JSON.parse(decodeURIComponent(urlEncodedData));\n\t\t\t\tthis._handleNativeEvent(data.data ? data.data : data);\n\t\t\t}.bind(this);\n\t\t}\n\t}\n\n\t/**\n\t * Initialize GC Social. You MUST call this method before any others.\n\t *\n\t * @method init\n\t * @param {object} options\n\t * @param {string} options.appID the appID of your application\n\t * @param {string} options.shortName the shortName of your application\n\t * @param {string} options.inviteURLTemplate\n\t * @param {string} [options.expireInvite] whether or not to expire an invite upon receipt (default true)\n\t * @param {string} [options.endpoint] the endpoint of the social API server\n\t */\n\tthis.init = function (options) {\n\t\t// allow init to be invoked manually when we have the appID available\n\t\tif (!options) {\n\t\t\tthis._construct();\n\t\t\treturn;\n\t\t}\n\n\t\toptions.endpoint = options.endpoint || \"http://api.gameclosure.com\";\n\n\t\tthis.options = options;\n\t\tthis.key = null;\n\t\tthis.guestMode = false;\n\t\tthis.authState = LOGGING_IN;\n\n\t\tthis._requestsToRunOnLogin = ff.defer();\n\t\tthis._requestsToRunOnConnections = ff.defer();\n\t\tthis._contactsUploaded = ff.defer();\n\t\tthis._requestingConnections = false;\n\t\tthis._phoneConnectionsRequested = false;\n\n\t\tthis._runOnInvite = ff.defer();\n\t\tthis.once(\"invite\", this._runOnInvite);\n\n\t\tif (!options.appID) {\n\t\t\tconsole.log(\"GCSocial error: No appID specified\");\n\t\t\tthrow new Error(\"No appID specified\");\n\t\t}\n\n\t\t/**\n\t\t * The current application.\n\t\t * @property app\n\t\t * @type App\n\t\t */\n\t\tthis.app = new App({\n\t\t\tid: options.appID,\n\t\t\tshortName: options.shortName,\n\t\t\tinviteURLTemplate: options.inviteURLTemplate,\n\t\t});\n\n\t\t/**\n\t\t * The current user.\n\t\t * @property user\n\t\t * @type CurrentUser\n\t\t */\n\t\tthis.user = new CurrentUser();\n\t\tthis.storage = new CrossDomainLocalStorage(options.endpoint + '/auth/session/');\n\n\n\t\t// start the session, then initialize the tracker, which sends the initial event.\n\t\ttracker.initialize(this);\n\t\tthis._tracker = tracker;\n\n\t\tthis.callNative(\"getAppID\", function(err, appID) {\n\t\t\tconsole.log(\"NATIVE got App ID \", appID);\n\t\t});\n\n\t\tthis._connection = new Connection();\n\t\tthis._connection.on('change', function(state) {\n\t\t\t// emit an online or offline event (just like window)\n\t\t\tthis.emit(state == \"online\" ? \"online\" : \"offline\");\n\n\t\t\tif (state == \"online\" && this.authState == LOGGED_OUT) {\n\t\t\t\tconsole.log(\"Social connection online; logging in\");\n\t\t\t\tthis._loadUser();\n\t\t\t}\n\t\t}.bind(this));\n\n\t\tthis.on('uploadContacts', function(status) {\n\t\t\tthis._contactsUploaded();\n\t\t}.bind(this));\n\n\t\tif (window.WITH_GC_SOCIAL) {\n\t\t\twindow.WITH_GC_SOCIAL.forEach(function (withGCSocialCallback) {\n\t\t\t\twithGCSocialCallback(this);\n\t\t\t}, this);\n\t\t}\n\n\t\tsetTimeout(this._loadUser.bind(this), 0);\n\t};\n\n\t/**\n\t * Tracks an event given a name and optional data map. The event\n\t * will be sent to the server sometime in the future when possible.\n\t * @method track\n\t * @param {string} name the name of the event\n\t * @param {object|null} data an optional map of {string->string} pairs\n\t */\n\tthis.track = function (name, data, cb) {\n\t\tif (!this._tracker) {\n\t\t\tthrow new Error(\"Social must be initialized before you can call gcsocial.track().\");\n\t\t}\n\t\treturn this._tracker.track.apply(this._tracker, arguments);\n\t}\n\n\t// DEPRECATED\n\tvar oldMethods = \"startSession endSession setExperiment funnelStep newUserFlow startLevel \" +\n\t\t \"finishLevel failLevel retryLevel quitLevel custom impersonate count\";\n\n\tthis.tracker = {};\n\toldMethods.split(' ').forEach(function (method) {\n\t\tthis.tracker[method] = function () {\n\t\t\tlogger.log(\"The method \" + method + \" is no longer active. Please use gcsocial.track().\");\n\n\t\t\tif(method == \"custom\") {\n\t\t\t\tgcsocial.track.apply(gcsocial, arguments);\n\t\t\t}\n\t\t};\n\t}.bind(this));\n\n\n\t/**\n\t * Load the current user (called right after `gcsocial.init()`).\n\t *\n\t * @method _loadUser\n\t * @private\n\t */\n\tthis._loadUser = function(cb) {\n\t\tif (this.isNative) {\n\t\t\tvar f = ff(this, function () {\n\t\t\t\t//this.callNative(\"getCurrentUser\", f());\n\t\t\t\tthis.callNative(\"getAuthKey\", f());\n\t\t\t}, function (key) {\n\t\t\t\tf(key);\n\t\t\t\tthis.ajax(\"GET\", \"/users/me/\", {\n\t\t\t\t\tparams: {\n\t\t\t\t\t\tkey: key,\n\t\t\t\t\t},\n\t\t\t\t\tignoreKey: true\n\t\t\t\t}, f());\n\t\t\t}, function (key, user) {\n\t\t\t\tconsole.log(\"GOT USER\", user);\n\t\t\t\t//delete user.connections; // these shouldn't come from native\n\t\t\t\tthis._updateAfterAuth(user, key);\n\t\t\t\t// native can't have invites.\n\t\t\t\tthis.emit(\"invite\", {invite: null});\n\t\t\t}).error(function(err) {\n\t\t\t\tlogger.log(\"FAILED TO GET USER: \" + err.message);\n\t\t\t}).cb(cb);\n\t\t} else {\n\t\t\tthis._loginViaWeb(cb);\n\t\t}\n\t}\n\n\t/**\n\t * Set the user and auth key after login.\n\t * @method _updateAfterAuth\n\t * @private\n\t */\n\tthis._updateAfterAuth = function (user, key, cb) {\n\t\tthis.authState = !!key ? LOGGED_IN : LOGGED_OUT;\n\t\tconsole.log(\"Update: authState=\" + this.authState +\n\t\t\t\t\t\", userID=\" + (user && user.id || null) +\n\t\t\t\t\t\", key=\" + (key || null));\n\n\t\tthis.user._update(user || {});\n\n\t\t// don't persist the auth key in guest mode\n\t\tif (!this.guestMode) {\n\t\t\tthis.storage.setItem(\"authKey\", key, cb);\n\t\t}\n\t\tthis.key = key;\n\n\t\tthis._requestsToRunOnLogin(key);\n\n\t\tthis.app.refresh();\n\n\t\tthis.emit(\"auth\", this.authState);\n\t}\n\n\t/**\n\t * Determine connection pre-fetching dependencies\n\t */\n\tthis._requestGetConnections = function() {\n\t\tif (this.requestingConnections) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.requestingConnections = true;\n\n\t\tif (this._phoneConnectionsRequested) {\n\t\t\tthis._contactsUploaded.cb(bind(this, this._runGetConnections));\n\t\t} else {\n\t\t\tthis._runGetConnections();\t\n\t\t}\n\t};\n\n\t/**\n\t * Preform connection pre-fetching\n\t */\n\tthis._runGetConnections = function() {\n\t\tvar connectionType = this._phoneConnectionsRequested ? this.user.ALL : this.user.ALL_SERVER;\n\n\t\tthis.user.getConnections(connectionType, function (err, connections) {\n\t\t\tif (err) {\n\t\t\t\tthis.requestingConnections = false;\n\t\t\t}\n\n\t\t\tthis._requestsToRunOnConnections(connections);\n\t\t}.bind(this));\t\n\t};\n\n\tvar nativeCallbacks = {};\n\tvar _initID = \"\" + Math.random() + (+new Date());\n\tvar nativeID = _initID;\n\t/**\n\t * Call into the native runtime using the given method name and arguments object.\n\t * @method callNative\n\t * @param {string} method\n\t * @param {object} arguments (an OBJECT representing the arguments requested, not an array)\n\t * @param {function(err, result)} cb\n\t * @private\n\t */\n\tthis.callNative = function (method, args, cb) {\n\t\t// NOTE: THIS METHOD SHOULD BE STATIC\n\t\tconsole.log(\"callNative\", method, JSON.stringify(args));\n\t\tif (!cb && typeof args === 'function') {\n\t\t\tcb = args;\n\t\t\targs = {};\n\t\t} else if (arguments.length === 1) {\n\t\t\targs = {};\n\t\t}\n\t\tvar id = nativeID;\n\t\tnativeID = _initID + Math.random() + Math.random();\n\t\tvar jsonStr = JSON.stringify({\n\t\t\t\tid: id + \"\",\n\t\t\t\tmethod: method,\n\t\t\t\targuments: args,\n\t\t\t});\n\n\t\tif (IS_TEALEAF) {\n\t\t\tnativeCallbacks[id] = cb;\n\t\t\tNATIVE.social.sendEvent(jsonStr);\n\t\t} else if (window.NativeSocial) {\n\t\t\tnativeCallbacks[id] = cb;\n\t\t\tNativeSocial.sendEvent(jsonStr);\n\t\t} else {\n\t\t\tif (IS_IOS_WEBVIEW) {\n\t\t\t\tnativeCallbacks[id] = cb;\n\t\t\t\tvar iframe = document.createElement(\"IFRAME\");\n  \t\t\t\tiframe.setAttribute(\"src\", \"social:\"+jsonStr);\n  \t\t\t\tdocument.documentElement.appendChild(iframe);\n  \t\t\t\tiframe.parentNode.removeChild(iframe);\n  \t\t\t\tiframe = null;\n\t\t\t} else {\n\t\t\t\tdelete nativeCallbacks[id];\n\t\t\t  \tcb && cb(new Error(\"No Native Social interface.\"));\n\t\t\t}\n\n\t\t}\n\t}\n\n\t/**\n\t * Handle an event from Native (usually as a method return value from callNative)\n\t *\n\t * @param {string} dataJSON\n\t * @this {GCSocial}\n\t * @private\n\t */\n\tthis._handleNativeEvent = function (data) {\n\t\tif (typeof data === \"string\") {\n\t\t\tdata = JSON.parse(data);\n\t\t}\n\n\t\tif (data.id !== undefined) {\n\t\t\t// this is a method result\n\t\t\tvar id = data.id;\n\t\t\tvar err = data.err;\n\t\t\tvar result = data.result;\n\t\t\tvar cb = nativeCallbacks[id];\n\t\t\tdelete nativeCallbacks[id];\n\t\t\tcb && cb(err, result);\n\t\t} else {\n\t\t\t// this is an event\n\t\t\tvar type = data.type;\n\t\t\tvar data = data.data;\n\n\t\t\tif (type == \"updateCurrentUser\") {\n\t\t\t\tvar user = data;\n\t\t\t\tthis._updateAfterAuth(user, user.key);\n\t\t\t} else if (type === \"_notification\" || type === '_notificationTap') {\n\t\t\t\tthis.emit(type, new Notification(typeof data === 'string' ? JSON.parse(data) : data));\n\t\t\t} else if (type === \"install\") {\n\t\t\t\tgcsocial.track(\"social.firstplay\", {\n\t\t\t\t\tsourceUserID: data.sourceUserID || \"null\",\n\t\t\t\t\ttargetUserID: data.userID || \"null\",\n\t\t\t\t\ttargetDeviceID: data.deviceID || \"null\",\n\t\t\t\t\tinviteCode: data.inviteCode || \"null\"\n\t\t\t\t}, { deviceID: data.inviteCode });\n\n\t\t\t\tthis.emit(type, data);\t\n\t\t\t} else {\n\t\t\t\tthis.emit(type, data);\n\t\t\t}\n\t\t}\n\t}\n\n\t// TODO: logout\n\t// TODO: when you change user info here, post to NATIVE to update user\n\n\tthis._getInviteCode = function() {\n\t\tvar uri = new std.uri(window.NATIVE && NATIVE.uri || window.location);\n\t\tvar code = uri.query('i') || uri.hash('i') || null;\n\t\treturn code;\n\t}\n\n\t/**\n\t * Log in via web.\n\t * Web login is complex, because you might have an invite code to accept,\n\t * and that invite might be for a different user.\n\t * @method _loginViaWeb\n\t * @private\n\t */\n\tthis._loginViaWeb = function (cb) {\n\t\tvar invite = null;\n\t\tvar inviteCache = [];\n\t\tvar code = this._getInviteCode();\n\t\tvar loginWithInvite = !!code;\n\t\tconsole.log(\"Login via web. Invite code: \" + code);\n\n\t\tthis.authState = LOGGING_IN;\n\n\t\tvar f = ff(this, function () {\n\t\t\tthis.storage.getItem(\"inviteCache\", f.slotPlain(2));\n\t\t}, function (_cacheErr, inviteCache) {\n\t\t\tinviteCache = inviteCache || [];\n\n\t\t\tif (code) {\n\t\t\t\t// Try to retrieve this invite info from cache.\n\t\t\t\tfor (var i = 0, inviteInfo; inviteInfo = inviteCache[i]; i++) {\n\t\t\t\t\tif (inviteInfo.code == code) {\n\t\t\t\t\t\tconsole.log(\"Invite loaded from cache.\");\n\t\t\t\t\t\tinvite = inviteInfo.invite;\n\t\t\t\t\t\tloginWithInvite = false; // don't try to use it again.\n\t\t\t\t\t\tif (invite.guestKey) {\n\t\t\t\t\t\t\tthis.guestMode = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinviteCache.splice(i, 1); // we'll move it to the front below\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar loginURL, loginBody;\n\t\t\tif (loginWithInvite) {\n\t\t\t\tconsole.log(\"Logging in with invite for the first time...\");\n\t\t\t\tloginURL = \"/apps/:appID/invites/\" + code + \"/\";\n\t\t\t\tloginBody = {\n\t\t\t\t\texpire: (this.options.expireInvite !== false),\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tconsole.log(\"Logging in...\");\n\t\t\t\tloginURL = \"/users/:userID/\";\n\t\t\t\tloginBody = {};\n\t\t\t}\n\n\t\t\t// slot the error as well, to handle it below\n\t\t\tthis.ajax(\"POST\", loginURL, {\n\t\t\t\tignoreKey: true,\n\t\t\t\tparams: {key: (loginWithInvite ? \"\" : undefined)},\n\t\t\t\tbody: loginBody\n\t\t\t}, f.slotPlain(3));\n\t\t}, function (err, rsp, xhr) {\n\t\t\tconsole.log(\"Login response status: \" + xhr.status);\n\n\t\t\t// When logging in, we can either:\n\t\t\t// - fail\n\t\t\t// - fail with a conflict, which means try again in guest mode\n\t\t\t// - succeed\n\t\t\tvar user, key;\n\t\t\tif (loginWithInvite) {\n\t\t\t\tif (err && err.status == 400) {\n\t\t\t\t\t// Invite was for a different user. Try guest mode.\n\t\t\t\t\tthis.guestMode = true;\n\t\t\t\t\tthis._loginViaWeb(cb);\n\t\t\t\t\treturn f.exit();\n\t\t\t\t}\n\t\t\t\tuser = rsp && rsp.invite.target;\n\t\t\t\tkey = rsp && rsp.key;\n\t\t\t\tinvite = rsp && rsp.invite;\n\t\t\t} else if (rsp) {\n\t\t\t\tuser = rsp;\n\t\t\t\tif (this.guestMode && invite) {\n\t\t\t\t\tkey = invite.guestKey || rsp.key;\n\t\t\t\t} else {\n\t\t\t\t\tkey = rsp.key;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// inviteCache is an array with recently used items at the front.\n\t\t\tif (invite) {\n\t\t\t\tif (this.guestMode) {\n\t\t\t\t\tinvite.guestKey = key;\n\t\t\t\t}\n\t\t\t\t// put the invite at the beginning of the cache.\n\t\t\t\tinviteCache.unshift({code: code, invite: invite});\n\t\t\t\tif (inviteCache.length > INVITE_CACHE_SIZE) {\n\t\t\t\t\tinviteCache.length = INVITE_CACHE_SIZE; // truncate it\n\t\t\t\t}\n\t\t\t\tthis.storage.setItem(\"inviteCache\", inviteCache);\n\n\t\t\t}\n\n\t\t\tthis._updateAfterAuth(user, key, f());\n\n\t\t\tthis.emit(\"invite\", {invite: invite || null});\n\n\t\t}).error(function (err) {\n\t\t\t// on error, no invite exists.\n\t\t\tthis.emit(\"invite\", {invite: null});\n\t\t}).cb(cb);\n\t}\n\n\t/**\n\t * @method generateDeviceID\n\t * @return {string} a new unique deviceID\n\t * @private\n\t */\n\tthis.generateDeviceID = function() {\n\t\treturn std.uuid.uuid() + (+new Date());\n\t}\n\n\t/**\n\t * @method getDeviceID\n\t * @return {string} the deviceID of the current phone\n\t * @private\n\t */\n\tthis.getDeviceID = function(cb) {\n\t\tvar f = ff(this, function() {\n\t\t\tthis.isNative && this.callNative(\"getDeviceID\", f.slotPlain(2));\n\t\t}, function (err, deviceID) {\n\t\t\tif (!err && deviceID) {\n\t\t\t\tf(\"native\");\n\t\t\t\tf(deviceID);\n\t\t\t} else if (this._getInviteCode()) {\n\t\t\t\tvar next = f.slotPlain(2);\n\t\t\t\tthis._runOnInvite.cb(function (err, evt) {\n\t\t\t\t\tvar deviceID;\n\t\t\t\t\tif (!err && evt && evt.invite) {\n\t\t\t\t\t\tdeviceID = evt.invite.data._deviceID;\n\t\t\t\t\t}\n\t\t\t\t\tnext(\"invite\", deviceID);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tf(\"storage\");\n\t\t\t\tthis.storage.getItem(\"deviceID\", f());\n\t\t\t}\n\t\t}, function(source, deviceID) {\n\t\t\tif (!deviceID) {\n\t\t\t\tdeviceID = this.generateDeviceID();\n\t\t\t\tconsole.log(\"Creating a new deviceID:\", deviceID);\n\t\t\t} else {\n\t\t\t\tconsole.log(\"Got deviceID from \" + source + \": \" + deviceID);\n\t\t\t}\n\t\t\tthis.storage.setItem(\"deviceID\", deviceID);\n\n\t\t\tf(deviceID);\n\t\t}).cb(cb);\n\t}\n\n\t/**\n\t * @method getApp\n\t * @param {string} [appID] an appID\n\t * @return {App|null} the application corresponding to the given ID\n\t */\n\tthis.getApp = function (appID) {\n\t\tif (!appID) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\treturn App.create({id: appID});\n\t\t}\n\t}\n\n\t/**\n\t * @method getUser\n\t * @param {string} [id] an userID\n\t * @return {User|null} the user corresponding to the given ID\n\t */\n\tthis.getUser = function (userID) {\n\t\tif (!userID) {\n\t\t\treturn null;\n\t\t} else if (userID === 'me') {\n\t\t\treturn this.user;\n\t\t} else {\n\t\t\treturn User.create({id: userID});\n\t\t}\n\t}\n\n\t/**\n\t * Return whether or not there is a connection to GC Social's servers.\n\t * @return {boolean}\n\t */\n\tthis.isOnline = function() {\n\t\treturn this._connection.getState();\n\t}\n\n\t/**\n\t * Return the API endpoint currently in use, typically \"http://api.gameclosure.com\".\n\t * @return {string}\n\t */\n\tthis.getEndpoint = function() {\n\t\treturn this.options.endpoint;\n\t}\n\n\t/**\n\t * Call the API server directly.\n\t * @param {string} method the HTTP method\n\t * @param {string} method the URL, with replacable :userID and :appID\n\t * @param {opts} object other options like timeout, params, headers, body\n\t * @this {GCSocial}\n\t * @private\n\t */\n\tthis.ajax = function (method, url, opts, cb) {\n\t\tvar xhr = null;\n\t\t// opts is optional\n\t\tif (!cb && typeof opts === 'function') {\n\t\t\tcb = opts;\n\t\t\topts = {};\n\t\t}\n\t\topts = opts || {};\n\t\tmethod = method.toUpperCase();\n\n\t\tvar f = ff(this, function() {\n\t\t\tif (!this.guestMode) {\n\t\t\t\tthis.storage.getItem(\"authKey\", f());\n\t\t\t} else {\n\t\t\t\tf(this.key);\n\t\t\t}\n\t\t}, function (authKey) {\n\t\t\topts = opts || {};\n\t\t\topts.headers = opts.headers || {};\n\t\t\topts.params = opts.params || {};\n\t\t\topts.timeout = opts.timeout || 20000;\n\t\t\topts.tries = opts.tries || 0;\n\t\t\topts.body = (typeof opts.body === 'object' ? JSON.stringify(opts.body) : opts.body);\n\n\t\t\tif (opts.params.key == null) { // empty is important here\n\t\t\t\topts.params.key = authKey || '';\n\t\t\t}\n\n\t\t\tif (opts.params.key === \"undefined\") {\n\t\t\t\tconsole.log(\"ERROR: authKey in gcsocial.ajax was the string 'undefined'.\");\n\t\t\t\topts.params.key = null;\n\t\t\t}\n\n\t\t\t// Requests that require login should block until login completes.\n\t\t\tif (!opts.ignoreKey) {\n\t\t\t\tvar next = f.wait();\n\t\t\t\tthis._requestsToRunOnLogin.cb(function (err, key) {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tnext(err);\n\t\t\t\t\t} else {\n\t\t\t\t\t\topts.params.key = key || '';\n\t\t\t\t\t\tnext();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Requests that return a user summary should block until\n\t\t\t// server connections are fetched\n\t\t\tif (opts.requireConnections) {\n\t\t\t\tvar wait = f.wait();\n\t\t\t\tthis._requestsToRunOnConnections.cb(function () {\n\t\t\t\t\twait();\n\t\t\t\t});\n\t\t\t\tthis._requestGetConnections();\n\t\t\t}\n\t\t}, function (authErr) {\n\t\t\tif (authErr) {\n\t\t\t\tcb && cb({status: 0}, null, null);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\txhr = new XMLHttpRequest();\n\n\t\t\tif (url.indexOf(\"://\") == -1) {\n\t\t\t\turl = this.options.endpoint + url;\n\t\t\t\tif (method != \"GET\" && method != \"POST\") {\n\t\t\t\t\topts.params.method = method;\n\t\t\t\t\tmethod = \"POST\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\topts.params.app = this.app.id;\n\n\t\t\tvar builtParams = [];\n\t\t\tfor (var param in opts.params) {\n\t\t\t\tbuiltParams.push(encodeURIComponent(param) + '=' +\n\t\t\t\t\t\t\t\t encodeURIComponent(opts.params[param]));\n\t\t\t}\n\t\t\tif (builtParams.length && url.indexOf('?') == -1) {\n\t\t\t\turl += '?';\n\t\t\t}\n\n\n\t\t\tvar replacements = {\n\t\t\t\tuserID: this.user.getID() || \"me\",\n\t\t\t\tappID: this.app.id\n\t\t\t};\n\n\t\t\turl = url.split('/').map(function (piece) {\n\t\t\t\tif (piece.charAt(0) == ':' && replacements[piece.substring(1)]) {\n\t\t\t\t\treturn replacements[piece.substring(1)];\n\t\t\t\t} else {\n\t\t\t\t\treturn piece;\n\t\t\t\t}\n\t\t\t}).join('/');\n\n\t\t\tvar timeoutCall = setTimeout(function () {\n\t\t\t\txhr.onreadystatechange = null;\n\t\t\t\tconsole.log(\"XHR Timeout:\", url);\n\t\t\t\tthis.emit('error', xhr);\n\t\t\t\tcb && cb({status: 0}, null, xhr);\n\t\t\t}.bind(this), opts.timeout || 60000);\n\n\t\t\txhr.url = url + builtParams.join('&');\n\t\t\txhr.open(method, url + builtParams.join('&'), true);\n\t\t\txhr.onreadystatechange = function() {\n\t\t\t\tclearTimeout(timeoutCall);\n\t\t\t\tif (xhr.readyState != 4) { return; }\n\t\t\t\tif (xhr.status == 200) {\n\t\t\t\t\tvar body = xhr.responseText;\n\t\t\t\t\tif (/json/.test((xhr.getResponseHeader('Content-Type') || '').toLowerCase())) {\n\t\t\t\t\t\tbody = JSON.parse(body);\n\t\t\t\t\t}\n\t\t\t\t\tthis.emit('success', xhr);\n\t\t\t\t\tcb && cb(null, body, xhr);\n\t\t\t\t} else {\n\t\t\t\t\tvar body = {};\n\t\t\t\t\tif (/json/.test((xhr.getResponseHeader('Content-Type') || '').toLowerCase())) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tbody = JSON.parse(xhr.responseText);\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tbody = {};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis.emit('error', xhr);\n\t\t\t\t\tconsole.log(\"XHR Error \" + xhr.status + \" on \" + url + \"\\n\" +\n\t\t\t\t\t\t\t\t\t   (body.error || \"(no content)\"));\n\t\t\t\t\tcb && cb(new Error(\"XHR Error \" + xhr.status + \" on \" + url + \"\\n\" +\n\t\t\t\t\t\t\t\t\t   (body.error || \"(no content)\")), null, xhr);\n\t\t\t\t}\n\t\t\t}.bind(this);\n\n\t\t\t// prevent preflighting when possible\n\t\t\txhr.setRequestHeader(\"Content-Type\", \"text/plain\");\n\n\t\t\tfor (var header in opts.headers) {\n\t\t\t\txhr.setRequestHeader(header, opts.headers[header]);\n\t\t\t}\n\n\t\t\tconsole.log(\"AJAX \" + method + \" \" + xhr.url + \" \" + opts.body);\n\t\t\t// finally send the request as binary data\n\t\t\txhr.send(opts.body || '');\n\t\t}).error(function (err) {\n\t\t\tconsole.log(err);\n\t\t\t// if the XHR was started already or we haven't yet fired off an XHR,\n\t\t\t// handle this error here. Nulling out onreadystatechange ensures\n\t\t\t// that we only handle this error once.\n\t\t\tif (xhr && xhr.onreadystatechange || !xhr) {\n\t\t\t\tif (xhr) {\n\t\t\t\t\txhr.onreadystatechange = null;\n\t\t\t\t}\n\t\t\t\tthis.emit('error', {status: 0});\n\t\t\t\tcb && cb({status: 0}, null, xhr);\n\t\t\t}\n\t\t}).timeout(opts && opts.timeout || 30000);\n\t}\n\n\t/**\n\t * @method configure\n\t * @param {object} options\n \t * @param {string} [options.expireInvite] whether or not to expire an invite upon receipt\n \t * @param {string} [options.androidAppID] the appID on the Google Play store (com.*.*)\n \t * @param {string} [options.iosAppID] the appID on the ios app store (com.*.*)\n\t */\n\tthis.configure = function (options) {\n\t\tthis.options = merge(options, this.options);\n\t}\n\n\t/**\n\t * Generate a number of names and rooms for your app to use.\n\t * @method shim\n\t * @param {object} types\n\t * @param {number} [types.connections]\n\t * @param {number} [types.scores]\n\t * @param {number} [types.notifications]\n\t * @param {number} [types.rooms] --Not implemented.\n\t */\n\tthis.shim = function (types) {\n\t\tif (DEBUG) {\n\t\t\tif (typeof types !== 'object') {\n\t\t\t\tthrow new TypeError(\"shim(types): Argument must be an object.\");\n\t\t\t}\n\t\t\tif (types.connections &&\n\t\t\t\t\ttypeof types.connections !== 'number' && !Array.isArray(types.connections)) {\n\t\t\t\tthrow new TypeError(\"shim(types): types.connections must be a number or an array.\");\n\t\t\t}\n\t\t\tif (types.rooms && typeof types.rooms !== 'number') {\n\t\t\t\tthrow new TypeError(\"shim(types): types.rooms must be a number.\");\n\t\t\t}\n\t\t}\n\n\t\tif (typeof types.connections === 'number') {\n\t\t\tfor (var i = 0, n = types.connections, connections = [], k; i < n; i++) {\n\t\t\t\tk = Math.random().toString().slice(-10);\n\t\t\t\tconnections.push({\n\t\t\t\t\tname: generator.tautogram(),\n\t\t\t\t\tid: null,\n\t\t\t\t\tservices: [{service: 'phone', key: k}]\n\t\t\t\t});\n\t\t\t}\n\t\t\tthis.user._shimConnections = connections;\n\t\t} else if (types.connections) {\n\t\t\tthis.user._shimConnections = types.connections;\n\t\t}\n\n\t\tif (types.scores) {\n\t\t\tfor (var i = 0, n = types.scores, scores = [], k; i < n; i++) {\n\t\t\t\tk = Math.random().toString().slice(-10);\n\t\t\t\tscores.push({\n\t\t\t\t\tid: \"\" + ~~(Math.random() * 1000000),\n\t\t\t\t\tapp: { id: gcsocial.app.getID() },\n\t\t\t\t\tuser: {\n\t\t\t\t\t\tname: generator.tautogram(),\n\t\t\t\t\t\tid: \"\" + ~~(Math.random() * 1000000),\n\t\t\t\t\t\tservices: [{service: 'phone', key: k}]\n\t\t\t\t\t},\n\t\t\t\t\tscore: ~~(Math.random() * 1000)\n\t\t\t\t});\n\t\t\t}\n\t\t\tthis.user._shimScores = scores;\n\t\t}\n\n\t\tif (types.notifications) {\n\t\t\tfor (var i = 0, n = types.notifications.number, notifications = [], k; i < n; i++) {\n\t\t\t\tk = Math.random().toString().slice(-10);\n\t\t\t\tnotifications.push(new Notification({\n\t\t\t\t\tid: \"\" + ~~(Math.random() * 1000000),\n\t\t\t\t\ttype: types.notifications.types ? math.array.shuffle(types.notifications.types)[0] : null,\n\t\t\t\t\tmessage: \"Message \" + ~~(Math.random() * 1000000),\n\t\t\t\t\ttitle: \"Title \" + ~~(Math.random() * 1000000),\n\t\t\t\t\tticker: \"Ticker \" + ~~(Math.random() * 1000000),\n\t\t\t\t\tapp: { id: gcsocial.app.getID() },\n\t\t\t\t\tsource: {\n\t\t\t\t\t\tname: generator.tautogram(),\n\t\t\t\t\t\tid: \"\" + ~~(Math.random() * 1000000)\n\t\t\t\t\t},\n\t\t\t\t\tdata: {}\n\t\t\t\t}));\n\t\t\t}\n\t\t\tthis.user._shimNotifications = notifications;\n\t\t}\n\t}\n\n\t/**\n\t * Show the profile of the given user, or yourself if no arguments are passed.\n\t * @method showProfile\n\t * @deprecated\n\t * @param {User} [user]\n\t */\n\tthis.showProfile = function(user, cb) {\n\t\tvar userID = user ? user.getID() : 'me';\n\t\tlogger.log('JAVASCRIPT SHOW PROFILE: ' + userID);\n\t\tthis.open(\"/users/\" + userID);\n\t}\n\t\n\t/**\n\t * Open the Social UI to a given page.\n\t * @method open\n\t * @param {\n\t */\n\tthis.open = function(path, cb) {\n\t\tthis.callNative(\"open\", {\n\t\t\tpath: path\n\t\t}, cb);\n\t}\n\n});\n\nexports = new GCSocial();\n","pre":true},"../../../social/lib/GCSocial/App.js":{"path":"../../../social/lib/GCSocial/App.js","friendlyPath":".App","directory":"../../../social/lib/GCSocial/","filename":"App.js","src":"jsio(\"import lib.PubSub as PubSub\");\njsio(\"import .node.ff as ff\");\njsio(\"import .Score\");\njsio(\"import .User\");\njsio(\"import .Room\");\n\nvar ua = navigator.userAgent;\nvar platform = /(iPod|iPhone|iPad)/i.test(ua) ? \"ios\" :\n\t\t\t   /Android/.test(ua) ? \"android\" : \n\t\t       \"desktop\";\n\n/**\n * @class App\n * @constructor\n * @param {object} opts metadata as returned from the server\n */\nApp=__class__;var App=App(function App(){return this.init&&this.init.apply(this,arguments)},PubSub, function () {\n\n\tvar NOTIF_LAST_ACCESS_KEY = '_gt_lastNotificationAccess';\n\tvar NOTIF_BUBBLED_KEY = '_gt_notifBubbled';\n\tvar NOTIF_ORDER_KEY = '_gt_order';\n\tvar MAX_NOTIF_SIZE = 50;\n\t\n\tthis.init = function (opts) {\n\t\tvar that = this;\n\n\t\tthis.id = opts.id;\n\t\tthis._inviteURLTemplate = opts && opts.inviteURLTemplate;\n\t\tthis._update(opts);\n\t\tthis._notificationsBubbled = JSON.parse(localStorage.getItem(NOTIF_BUBBLED_KEY)) || {'_gt_order': []};\n\t\tthis._notificationsOrderArr = this._notificationsBubbled[NOTIF_ORDER_KEY];\n\n\t\t// events\n\t\tgcsocial.on('_notification', function(notification) {\n\t\t\tif (that._notificationsBubbled[notification.getID()] !== true) {\n\t\t\t\tgcsocial.emit('notification', notification);\n\t\t\t}\n\n\t\t\tthat._addBubbledNotif(notification.getID());\n\t\t});\n\n\t\tgcsocial.on('_notificationTapped', function(notification) {\n\t\t\tgcsocial.emit('notificationTap', notification);\n\t\t});\n\n\t\tgcsocial.on('_onResume', function() {\n\t\t\tthat.getNotifications();\n\t\t});\n\t}\n\n\tthis._addBubbledNotif = function(id) {\n\t\tthis._notificationsBubbled[id] = true;\t\n\t\tthis._notificationsOrderArr.push(id);\n\n\t\tif (this._notificationsOrderArr.length > MAX_NOTIF_SIZE) {\n\t\t\tfor (var i = 0; i < this._notificationsOrderArr.length - MAX_NOTIF_SIZE; i++) {\n\t\t\t\tdelete this._notificationsBubbled[this._notificationsOrderArr[i]];\n\t\t\t}\t\n\n\t\t\tthis._notificationsOrderArr.splice(0, this._notificationsOrderArr.length - MAX_NOTIF_SIZE);\n\t\t}\n\n\t\tlocalStorage.setItem(NOTIF_BUBBLED_KEY, JSON.stringify(this._notificationsBubbled));\n\t};\n\n\tthis._update = function (opts) {\n\t\tthis.name = opts.name;\n\t\tthis.studio = opts.studio ? new Studio(opts.studio) : null;\n\t\tthis.shortName = opts.shortName;\n\t\tthis.updated = opts.updated ? new Date(opts.updated) : null;\n\t\tthis.created = opts.created ? new Date(opts.created) : null;\n\t\tif (this.studio) {\n\t\t\tthis._urlTemplate = this._inviteURLTemplate || \n\t\t\t\t\"http://\" + this.shortName + \".\" + this.studio.domain + \"/?i={code}\";\n\t\t} else {\n\t\t\tthis._urlTemplate = this._inviteURLTemplate;\n\t\t}\n\n\t\tthis.emit('change', this);\n\t}\n\t\n\tthis._getInviteURLTemplate = function () {\n\t\treturn this._urlTemplate;\n\t}\n\t\n\t/**\n\t * @method getID\n\t * @return {string} the appID of this application\n\t */\n\tthis.getID = function () {\n\t\treturn this.id;\n\t}\n\n\t/**\n\t * @method getName\n\t * @return {string} the name of this application\n\t */\n\tthis.getName = function () {\n\t\treturn this.name;\n\t}\n\n\t/**\n\t * @method getStudio\n\t * @return {Studio} the studio for this application\n\t */\n\tthis.getStudio = function () {\n\t\treturn this.studio;\n\t}\n\n\t/**\n\t * @method getCreated\n\t * @return {Date}\n\t */\n\tthis.getCreated = function () {\n\t\treturn this.created;\n\t}\n\n\t/**\n\t * @method getUpdated\n\t * @return {Date}\n\t */\n\tthis.getUpdated = function () {\n\t\treturn this.updated;\n\t}\n\n\t/**\n\t * Reload the data for this application.\n\t * @method refresh\n\t * @param {function(err)} cb\n\t */\n\tthis.refresh = function (cb) {\n\t\tvar f = ff(this, function () {\n\t\t\tgcsocial.ajax(\"GET\", \"/apps/:appID/\", f());\n\t\t}, function (app) {\n\t\t\tthis._update(app);\n\t\t\tf(this);\n\t\t}).cb(cb || function() {}); // if no handler was passed, ignore errors\n\t}\n\n\t/**\n\t * Redirect the user to the native app store, if possible.\n\t * You must populate the androidAppID or iosAppID via gcsocial.configure() first.\n\t * @method upsell\n\t */\n\tthis.upsell = function (cb) {\n\t\tvar f = ff(this, function () {\n\t\t\tgcsocial.user.getInvite(f());\n\t\t\tgcsocial.getDeviceID(f());\n\t\t}, function (invite, deviceID) {\n\t\t\tvar code = gcsocial._getInviteCode();\n\t\t\tvar sourceUserID = invite ? invite.getSourceUser().getID() : \"\";\n\t\t\tvar url, appID;\n\t\t\tvar referrer = encodeURIComponent(\"key=\" + (gcsocial.user.getAuthKey() || \"\") + \n\t\t\t\t\t\t\t\t\t\t\t  \"&sourceUserID=\" + (sourceUserID || \"\") +  \n\t\t\t\t\t\t\t\t\t\t\t  \"&inviteCode=\" + (code || \"\") + \n\t\t\t\t\t\t\t\t\t\t\t  \"&userID=\" + (gcsocial.user.getID() || \"\") + \n\t\t\t\t\t\t\t\t\t\t\t  \"&deviceID=\" + (deviceID || \"\"));\n\t\t\tif (platform == \"android\") {\n\t\t\t\tappID = gcsocial.options.androidAppID;\n\t\t\t\turl = \"market://details?id=\" + appID + \"&referrer=\" + referrer;\n\t\t\t} else {\n\t\t\t\tappID = gcsocial.options.iosAppID;\n\t\t\t\turl = \"itms-apps://itunes.apple.com/us/app/pages/id\" + appID + \"?mt=8&uo=4\";\n\t\t\t}\n\t\t\t\n\t\t\tif (!appID) {\n\t\t\t\tconsole.error(\"ERROR: You must provide an ID for the google/ios market for upsell.\");\n\t\t\t} else if (!url) {\n\t\t\t\tconsole.error(\"This platform does not support upsells.\");\n\t\t\t} else {\n\t\t\t\tgcsocial.track(\"social.upsell\", {\n\t\t\t\t\tsourceUserID: sourceUserID,\n\t\t\t\t\ttargetUserID: gcsocial.user.getID(),\n\t\t\t\t\ttargetDeviceID: deviceID,\n\t\t\t\t\tinviteCode: invite.getID()\n\t\t\t\t}, {deviceID: invite.getID()}, function () {\n\t\t\t\t\tconsole.log(\"Redirecting: \" + url);\n\t\t\t\t\twindow.location = url;\n\t\t\t\t});\n\t\t\t}\n\t\t}).cb(cb);\n\t},\n\t\n\t/**\n\t * Get a random user of this application.\n\t * @param {function(err, User)} cb\n\t */\n\tthis.getRandomUser = function (cb) {\n\t\tgcsocial.ajax(\"GET\", \"/apps/:appID/users/random/\", {\n\t\t\trequireConnections: true\n\t\t}, function (err, response) {\n\t\t\tif (err || !response) {\n\t\t\t\tconsole.log(\"Unable to fetch random friend\", err);\n\t\t\t\tcb && cb(err);\n\t\t\t} else {\n\t\t\t\tcb && cb(null, User.create(response));\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Fetch the global config data for this app.\n\t * @param {function(err, data)} cb\n\t */\n\tthis.fetchConfig = function (cb) {\n\t\tgcsocial.ajax(\"GET\", \"/apps/:appID/config/\", cb);\n\t}\n\t\n\t/**\n\t * Return the highest scores for the leaderboard for this app.\n\t * @method getScores\n\t * @param {string=} leaderboard The leaderboard to retrieve (or \"default\")\n\t * @param {function(err, obj)} cb obj = {items: Score[]}\n\t */\n\tthis.getScores = function (leaderboard, cb) {\n\t\tif (typeof leaderboard == 'function') {\n\t\t\tcb = leaderboard;\n\t\t\tleaderboard = null;\n\t\t}\n\n\t\tleaderboard = leaderboard || Score.defaultLeaderboard;\n\t\tvar url = '/apps/' + this.id + '/leaderboards/' + leaderboard + '/scores/';\n\t\tgcsocial.ajax('GET', url, {\n\t\t\trequireConnections: true\n\t\t}, function (err, response) {\n\t\t\tif (err || !response) {\n\t\t\t\tconsole.log('Unable to retrieve app scores');\n\t\t\t\tcb && cb(err || 'Empty score response');\n\t\t\t} else {\n\t\t\t\tcb && cb(null, Score.parseScoreResponse(response));\n\t\t\t}\n\t\t});\n\t}\n\t\n\t/**\n\t * Create a new multiplayer game room.\n\t * @method createRoom\n\t * @param {object} opts\n\t * @param {User[]} opts.users An array of users to be added to the room, excluding yourself.\n\t * @param {object} [opts.metadata] initial metadata with which to create the room.\n\t * @param {object} [opts.data] initial data with which to create the room.\n\t * @param {function(err, Room)} cb\n\t */\n\tthis.createRoom = function (opts, cb) {\n\t\tif (typeof opts == \"function\") {\n\t\t\tcb = opts;\n\t\t\topts = {};\n\t\t}\n\n\t\tif (!opts.users || !opts.users.length) {\n\t\t\tconsole.log(\"No opponents specified for new room\");\n\t\t\treturn cb && cb({error: \"No opponents specified for new room\"});\n\t\t}\n\t\t\n\t\topts.users = opts.users.map(function (user) {\n\t\t\tif (user instanceof User) {\n\t\t\t\treturn user.toJSON();\n\t\t\t} else {\n\t\t\t\treturn user;\n\t\t\t}\n\t\t});\n\n\t\tvar url = \"/apps/:appID/users/:userID/rooms/\";\n\t\tgcsocial.ajax(\"POST\", url, {\n\t\t\tbody: {\n\t\t\t\tusers: opts.users,\n\t\t\t\tmetadata: opts.metadata || {},\n\t\t\t\tdata: opts.data || {}\n\t\t\t},\n\t\t\trequireConnections: true\n\t\t}, function (err, response) {\n\t\t\tif (err) {\n\t\t\t\tlogger.log('Error in new room:', JSON.stringify(err));\n\t\t\t\tcb && cb(err);\n\t\t\t} else {\n\t\t\t\tvar room = Room.create(response);\n\t\t\t\tgcsocial.user._rooms.add(room);\n\t\t\t\tcb && cb(null, room);\n\t\t\t}\n\t\t}.bind(this));\n\t}\n\t\n\t/**\n\t * Put yourself in a queue to wait for new multiplayer matches. If\n\t * you are the host of a room (you enter first), the given\n\t * metadata and data will be applied to the room. You should poll\n\t * on your room list using `gcsocial.user.pollRooms()` to await new rooms.\n\t * @method requestMatch\n\t * @param {object} [opts]\n\t * @param {object} opts.metadata initial metadata with which to create the room.\n\t * @param {object} opts.data initial data with which to create the room.\n\t * @param {object} opts.bucket a string representing a group for which only users in this bucket will be matched against.\n\t * @param {function(err)} cb\n\t */\n\tthis.requestMatch = function (opts, cb) {\n\t\tif (typeof opts == \"function\") {\n\t\t\tcb = opts;\n\t\t\topts = {};\n\t\t}\n\t\t// Tell the server that you'd like to recieve a push\n\t\t// notification when the server has found a match for you.\n\t\t// on. The user will receive a push notification or SMS\n\t\t// when they've been matched with an opponent. You can call\n\t\t// this multiple times to be placed in multiple rooms.\n\n\t\t// The push notification will contain the game's room id.\n\t\tvar url = \"/apps/:appID/matchmaker/:userID/\";\n\t\tgcsocial.ajax(\"POST\", url, {\n\t\t\tbody: {\n\t\t\t\tmetadata: opts.metadata || {},\n\t\t\t\tdata: opts.data || {},\n\t\t\t\tbucket: (opts.bucket ? opts.bucket + \"\" : null),\n\t\t\t}\n\t\t}, function (err, response) {\n\t\t\tif (err) {\n\t\t\t\tlogger.error('Error in requestMatch:', JSON.stringify(err));\n\t\t\t}\n\t\t\tcb && cb(err, response);\n\t\t});\n\t}\n\n\t/**\n\t * Cancel your awaiting match request you previously created with\n\t * `gcsocial.user.requestMatch()`\n\t * @method cancelRequestMatch\n\t * @param {function(err)} cb\n\t */\n\tthis.cancelRequestMatch = function (cb) {\n\t\tvar url = \"/apps/:appID/matchmaker/:userID/\";\n\t\tgcsocial.ajax(\"DELETE\", url, function (err, response) {\n\t\t\tif (err) {\n\t\t\t\tlogger.error('Error in cancelRequestMatch:', JSON.stringify(err));\n\t\t\t}\n\t\t\tcb && cb(err, response);\n\t\t});\n\t}\n\n\t/**\n\t * Gets your notification queue from server.\n\t * @method getNotifications\n\t */\n\tthis.getNotifications = function() {\n\t\tvar that = this;\n\t\tvar lastAccess = localStorage.getItem(NOTIF_LAST_ACCESS_KEY);\n\t\tvar url = '/users/me/notifications/';\n\n\t\tif (lastAccess != null) {\n\t\t\turl += '?since=' + lastAccess;\n\t\t}\n\n\t\tgcsocial.ajax('GET', url, function(err, response) {\n\t\t\tif (response != null && response.length > 0) {\n\t\t\t\tfor (var i = 0, notif; (notif = response[i]) != null; i++) {\n\t\t\t\t\tif (that._notificationsBubbled[notif.getID()] !== true) {\n\t\t\t\t\t\tgcsocial.emit('notification', notif);\n\t\t\t\t\t}\n\n\t\t\t\t\tthat._addBubbledNotif(notif.getID());\n\t\t\t\t}\n\n\t\t\t\tlocalStorage.setItem(NOTIF_LAST_ACCESS_KEY, Date.now());\t\t\n\t\t\t\tlocalStorage.setItem(NOTIF_BUBBLED_KEY, JSON.stringify(that._notificationsBubbled));\n\t\t\t}\n\t\t});\n\t};\n\n\t/**\n\t * Sent a notification to all connections\n\t *\n\t * @method send\n\t * @param {object} data\t\tjson data repsenting data to send\n\t * @param {object} opts\t\t\toptional parameters\n\t */\n\tthis.send = function(data, opts) {\n\t\tvar url = '/users/me/app/:appID/notifications';\n\n\t\tgcsocial.ajax('PUT', url, {\n\t\t\tbody: {\n\t\t\t\tdata: data,\n\t\t\t\topts: opts\n\t\t\t}\n\t\t}, function(err, response) {});\n\t};\n});\n\nvar _appCache = {};\n\nApp.create = function (appInfo) {\n\tif (!appInfo) { return null; }\n\tif (appInfo.id && appInfo.id == gcsocial.app.getID()) {\n\t\treturn gcsocial.app;\n\t} else {\n\t\tvar app = _appCache[appInfo.id];\n\t\tif (app && app.id != null) {\n\t\t\tapp._update(appInfo);\n\t\t} else {\n\t\t\t_appCache[info.id] = app = new App(appInfo);\n\t\t}\n\t\treturn app;\n\t}\n}\n\n/**\n * @class Studio\n */\nStudio=__class__;var Studio=Studio(function Studio(){return this.init&&this.init.apply(this,arguments)},function () {\n\t\n\tthis.init = function (opts) {\n\t\t\n\t\t/** \n\t\t * the name of the studio\n\t\t * @property name\n\t\t * @type string\n\t\t */\n\t\tthis.name = opts.name;\n\n\t\t/** \n\t\t * the domain of the studio\n\t\t * @property domain\n\t\t * @type string\n\t\t */\n\t\tthis.domain = opts.domain;\n\t}\n});\n\nexports = App;\n","pre":true},"../../../social/lib/GCSocial/node/ff.js":{"path":"../../../social/lib/GCSocial/node/ff.js","friendlyPath":".node.ff","directory":"../../../social/lib/GCSocial/node/","filename":"ff.js","src":"/*\n Copyright (c) 2011 Tim Caswell <tim@creationix.com>\n Copyright (c) 2012 Marcus Cavanaugh <m@mcav.com>\n Copyright (c) 2012 Michael Henretty <michael.henretty@gmail.com>\n\n MIT License\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in all\n copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n SOFTWARE.\n */\n\n// This is ff, by Marcus Cavanaugh and Michael Henretty.\n// It was inspired by TwoStep by Tim Caswell (https://gist.github.com/1524578),\n// which was in turn inspired by Will Conant's flow-js.\n\nif (typeof exports !== 'undefined') {\n\texports = ff; // jsio\n}\nif (typeof module !== 'undefined') {\n\tmodule.exports = ff;\n}\n\nvar slice = Array.prototype.slice;\n\nfunction copyToFunction (group, f) {\n\tfor (var method in group) {\n\t\tf[method] = (function(method) {\n\t\t\treturn function() {\n\t\t\t\treturn group[method].apply(group, arguments);\n\t\t\t};\n\t\t})(method);\n\t}\n}\n\n// custom error used to break out of step\nfunction DoneError(args) {\n\tthis.args = args; // should be passed to result, if exists\n\tthis.name = \"DoneError\";\n\tthis.message = \"Group done\";\n}\nDoneError.prototype = new Error();\n\nfunction Group(superGroup, callback, firstSlotCallback) {\n\tthis.args = [null];\n\tthis.left = 0;\n\tthis.callback = callback;\n\tthis.isDone = false;\n\tthis.firstSlotCallback = firstSlotCallback; // mcav\n\tthis.superGroup = superGroup;\n}\n\nGroup.prototype.done = function done() {\n\tif (this.isDone) return;\n\tthis.isDone = true;\n\tthis.callback.apply(null, this.args);\n};\n\nGroup.prototype.succeed = function () {\n\tif (this.isDone) return;\n\tthis.isDone = true;\n\tthis.superGroup.result = [null].concat(slice.call(arguments));\n\t\n\tif (!this.superGroup._started) {\n\t\t// if we didn't start the chain of .next() steps,\n\t\t// just call the final results immediately.\n\t\tthis.superGroup._runResultHandlers.apply(this.superGroup, this.superGroup.result);\n\t}\n};\n\nGroup.prototype.fail = function (err) {\n\tif (this.isDone) return;\n\tthis.isDone = true;\n\tif (err == null) {\n\t\terr = new Error(\"f.fail()\");\n\t}\n\tthis.superGroup.result = [err];\n\tif (!this.superGroup._started) {\n\t\t// if we didn't start the chain of .next() steps,\n\t\t// just call the final results immediately.\n\t\tthis.superGroup._runResultHandlers.apply(this.superGroup, this.superGroup.result);\n\t}\n};\n\n// DEPRECATED:\nGroup.prototype.exit = function exit() {\n\tif (this.isDone) return;\n\tthis.isDone = true;\n\tthrow new DoneError();\n};\n\nGroup.prototype.error = function error(err) {\n\tif (this.isDone) return;\n\tthis.isDone = true;\n\tvar callback = this.callback;\n\tcallback(err);\n};\n\n// Simple utility for passing a sync value to the next step.\nGroup.prototype.slot = function () {\n\tif (arguments.length > 0) {\n\t\tfor (var i = 0, l = arguments.length; i < l; i++) {\n\t\t\tthis.args.push(arguments[i]);\n\t\t}\n\t} else {\n\t\treturn this.slotMulti(1);\n\t}\n};\n\n// Register a slot in the next step and return a callback\nGroup.prototype.slotMulti = function (argLength) {\n\tthis.debug && console.log(\"slotting\", this.left);\n\tif (!argLength) argLength = 1;\n\tvar group = this;\n\tvar index = group.args.length;\n\tgroup.args.length += argLength;\n\tgroup.left++;\n\tif (this.firstSlotCallback) { // mcav\n\t\tthis.firstSlotCallback();\n\t\tthis.firstSlotCallback = null;\n\t}\n\treturn function (err) {\n\t\tgroup.debug && console.log(\"slot DONE\", group.left);\n\t\tif (err) return group.error(err);\n\t\tvar values = slice.call(arguments, 1);\n\t\tfor (var i = 0; i < argLength; i++) {\n\t\t\tgroup.args[index + i] = values[i];\n\t\t}\n\t\tif (--group.left === 0) group.done();\n\t};\n};\n\n// Register a slot in the next function which includes first param\nGroup.prototype.slotPlain = function slotPlain(argLength) {\n\tthis.debug && console.log(\"slotting (no error)\", this.left);\n\tvar group = this;\n\tvar slot = group.slotMulti(argLength);\n\treturn function () {\n\t\tgroup.debug && console.log(\"slot DONE (no error)\", group.left);\n\t\tslot.apply(group, [null].concat(slice.call(arguments)));\n\t}\n};\n\n// Block on this callback, but dont slot data\nGroup.prototype.wait = function wait() {\n\tthis.debug && console.log(\"waiting\", this.left);\n\tvar group = this;\n\tgroup.left++;\n\tif (this.firstSlotCallback) { // mcav\n\t\tthis.firstSlotCallback();\n\t\tthis.firstSlotCallback = null;\n\t}\n\treturn function (err, data) {\n\t\tgroup.debug && console.log(\"wait DONE\", group.left);\n\t\tif (err) return group.error(err);\n\t\tif (--group.left === 0) group.done();\n\t};\n};\n\n// Wait, but don't forward error\nGroup.prototype.waitPlain = function waitPlain() {\n\tthis.debug && console.log(\"waiting (no error)\", this.left);\n\tvar group = this;\n\tvar wait = this.wait();\n\treturn function () {\n\t\tgroup.debug && console.log(\"wait DONE (no error)\", group.left);\n\t\twait.apply(group, [null].concat(slice.call(arguments)));\n\t}\n};\n\n// Creates a nested group where several callbacks go into a single array.\nGroup.prototype.group = function group() {\n\tvar group = this;\n\tvar index = this.args.length++;\n\tvar subgroup = new Group(this.superGroup, function (err) {\n\t\tif (err) return group.error(err);\n\t\tvar data = slice.call(arguments, 1);\n\t\tgroup.args[index] = data;\n\t\tif (--group.left === 0) group.done();\n\t}, function () {\n\t\tgroup.left++;\n\t});\n\t\n\tvar f = function () {\n\t\treturn subgroup.slot.apply(subgroup, arguments);\n\t};\n\t\n\tcopyToFunction(subgroup, f);\n\t\n\treturn f;\n};\n\n// backwards-compatibility:\nGroup.prototype.makeGroup = Group.prototype.group;\nGroup.prototype.slotNoError = Group.prototype.slotPlain;\nGroup.prototype.waitNoError = Group.prototype.waitPlain;\nGroup.prototype.pass = Group.prototype.slot;\n\n// global group\nfunction SuperGroup(args) {\n\tvar context;\n\tif (typeof args[0] === \"function\") {\n\t\tcontext = null;\n\t} else {\n\t\tcontext = args.shift();\n\t}\n\t\n\tthis.f = null; // the chaining f function\n\tthis.currentGroup = new Group(this, function () {});\n\tthis.context = context;\n\tthis.steps = [];\n\tthis.completionHandlers = [];\n\tthis._started = false;\n\tthis.result = null;\n\n\targs.forEach(function (fn) {\n\t\tif (fn) {\n\t\t\tif (fn._ffMethod) { // backwards-compat\n\t\t\t\tthis[fn._ffMethod](fn);\n\t\t\t} else {\n\t\t\t\tthis.next(fn);\n\t\t\t}\n\t\t}\n\t}, this);\n}\n\nfor (var method in Group.prototype) if (Group.prototype.hasOwnProperty(method)) {\n\tSuperGroup.prototype[method] = (\n\t\tfunction (method) {\n\t\t\treturn function () {\n\t\t\t\tif (this.currentGroup) {\n\t\t\t\t\treturn this.currentGroup[method].apply(this.currentGroup, arguments);\n\t\t\t\t}\n\t\t\t};\n\t\t})(method);\n}\n\n//****************************************************************\n// Completion Handlers\n\n/**\n * Call this function regardless of whether or not an error has\n * propagated down the chain. You'll usually want to call this at the\n * end of your chain.\n */\nSuperGroup.prototype.cb = function (cb, _onlySuccess) {\n\tif (!_onlySuccess) {\n\t\tthis._hasErrorCallback = true;\n\t}\n\tif (this.result) {\n\t\tcb && cb.apply(this.context || this, this.result);\n\t} else {\n\t\tcb && this.completionHandlers.push(cb);\n\t}\n\treturn this.f;\n}\n\n/**\n * If and only if there was no error (this far in the chain), call cb\n * WITHOUT passing any error at all. Again, error won't be null, it'll\n * not be passed at all. Your function should only accept the next\n * arguments.\n */\nSuperGroup.prototype.success = function (cb) {\n\treturn this.cb(function(err) {\n\t\t!err && cb.apply(this, slice.call(arguments, 1));\n\t}, true);\n}\n\n/**\n * If and only if there was an error, call cb with the\n * error as an argument.\n */\nSuperGroup.prototype.error = SuperGroup.prototype.failure = function (cb) {\n\treturn this.cb(function(err) {\n\t\terr && cb.apply(this, arguments);\n\t}); \n}\n\nSuperGroup.prototype.next = function (cb) {\n\tthis.steps.push(cb);\n\treturn this.f;\n}\n\nSuperGroup.prototype.timeout = function (milliseconds) {\n\tif (!this.result) {\n\t\tif (this._timeout) {\n\t\t\tclearTimeout(this._timeout);\n\t\t}\n\t\tthis._timeout = setTimeout(function () {\n\t\t\tthis.fail(new Error(\"timeout\"));\n\t\t\t// we might not have run the result handler previously:\n\t\t\tthis._runResultHandlers.apply(this, this.result);\n\t\t}.bind(this), milliseconds);\n\t}\n\t\n\treturn this.f;\n}\n\n//****************************************************************\n\n\n// Stepper function\nSuperGroup.prototype._execNextStep = function(err) {\n\tif (this.result) {\n\t\treturn;\n\t}\n\t\n\tthis._started = true;\n\t\n\tvar step = this.steps.shift();\n\tif (err || !step) {\n\t\tthis._runResultHandlers.apply(this, arguments);\n\t} else {\n\t\tvar group = new Group(this, this._execNextStep.bind(this));\n\t\ttry {\n\t\t\t// make sure next function isnt applied\n\t\t\t// until current function has completed\n\t\t\tgroup.left++;\n\t\t\tthis.currentGroup = group;\n\t\t\tstep.apply(this.context || this, slice.call(arguments, 1));\n\t\t\tgroup.left--;\n\t\t\tif (this.result) {\n\t\t\t\tthis._runResultHandlers.apply(this, this.result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t} catch (e) {\n\t\t\tgroup.left--;\n\t\t\t\n\t\t\tif ((e instanceof ReferenceError) || \n\t\t\t\t(e instanceof SyntaxError)) {\n\t\t\t\te.rethrow = true;\n\t\t\t}\n\t\t\tif (e instanceof DoneError) {\n\t\t\t\treturn; // don't call anything else (exit()); deprecated.\n\t\t\t} else if (e.rethrow) {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t\tgroup.error(e);\n\t\t}\n\t\tif (group.left === 0) group.done();\n\t}\n}\n\nSuperGroup.prototype._runResultHandlers = function (err) {\n\tif (this._finished) { return; }\n\tthis._finished = true;\n\t\n\tif (this._timeout) {\n\t\tclearTimeout(this._timeout);\n\t}\n\n\t// if we're running the callback chain, an error occured, and no one\n\t// attached an error handler, log it out with ff.onerror.\n\tif (!this._hasErrorCallback && err && this._started) {\n\t\tthis.completionHandlers.push(ff.onerror);\n\t}\n\t\n\tthis.result = slice.call(arguments);\n\t\n\tthis.currentGroup = null;\n\t\n\t// fire these in a timeout so that if any handler throws an\n\t// exception, the rest of the handlers will get called, and the\n\t// exception will be reported as unhandled (in node) or in the web\n\t// console (in the browser)\n\tvar args = arguments;\n\t\n\tthis.completionHandlers.forEach(function (handler) {\n\t\tsetTimeout(function () {\n\t\t\thandler && handler.apply(this.context || this, args);\n\t\t}.bind(this), 0);\n\t}, this);\n\t\n\tthis.completionHandlers.length = 0; // null it out\n}\n\n//****************************************************************\n\nfunction ff(context) {\n\tvar superGroup = new SuperGroup(slice.call(arguments));\n\n\t// execute steps in next tick\n\tvar f = function () {\n\t\treturn superGroup.slot.apply(superGroup, arguments);\n\t};\n\t\n\tsetTimeout(function(){ superGroup._execNextStep(); }, 0);\n\n\tsuperGroup.f = f;\n\tcopyToFunction(superGroup, f);\n\treturn f;\n}\n\nff.defer = function (context) {\n\tvar superGroup = new SuperGroup(slice.call(arguments));\n\n\tvar f = function () {\n\t\tif (!superGroup._started) {\n\t\t\tsuperGroup._execNextStep.apply(superGroup, [null].concat(slice.call(arguments)));\n\t\t} else {\n\t\t\treturn superGroup.slot.apply(superGroup, arguments);\n\t\t}\n\t};\n\t\n\tsuperGroup.f = f;\n\tcopyToFunction(superGroup, f);\n\treturn f;\n}\n\n//****************************************************************\n\nff.onerror = function(err) {\n\terr.rethrow = true;\n\tconsole.log(\"Unhandled ff error:\", err, err && err.stack);\n\tthrow err;\n}\n\n// backwards-compatibility (disregard):\n\nff.cb = function (fn) {\n\tif (fn) {\n\t\tfn._ffMethod = 'cb';\n\t}\n\treturn fn;\n}\n\nff.error = function (fn) {\n\tif (fn) {\n\t\tfn._ffMethod = 'error';\n\t}\n\treturn fn;\n}\n\nff.success = function (fn) {\n\tif (fn) {\n\t\tfn._ffMethod = 'success';\n\t}\n\treturn fn;\n}\n\n","pre":true},"../../../social/lib/GCSocial/Score.js":{"path":"../../../social/lib/GCSocial/Score.js","friendlyPath":".Score","directory":"../../../social/lib/GCSocial/","filename":"Score.js","src":"/**\n * Represents a high score for a particular leaderboard.\n * \n * @class Score\n * @constructor\n * @param {object} opts metadata as returned from the server\n */\nScore=__class__;var Score=Score(function Score(){return this.init&&this.init.apply(this,arguments)},function () {\n\t\n\tthis.init = function (opts) {\n\t\tthis.id = opts.id;\n\t\tthis._update(opts);\n\t}\n\n\tthis._update = function (opts) {\n\t\tvar User = jsio(\"import .User\");\n\t\tvar App = jsio(\"import .App\");\n\t\tthis.leaderboard = opts.leaderboard;\n\t\tthis.user = User.create(opts.user);\n\t\tthis.app = opts.app.id == gcsocial.app.getID() ?\n\t\t\t\t\tgcsocial.app :\n\t\t\t\t\tnew App(opts.app);\n\t\tthis.score = opts.score;\n\t\tthis.data = opts.data;\n\t}\n\n\t/**\n\t * @method getID\n\t * @return {string}\n\t */\n\tthis.getID = function () {\n\t\treturn this.id;\n\t}\n\n\t/** \n\t * @method getLeaderboard\n\t * @return {string} the leaderboard for this score \n\t */\n\tthis.getLeaderboard = function () {\n\t\treturn this.leaderboard;\n\t}\n\n\t/**\n\t * @method getUser\n\t * @return {User}\n\t */\n\tthis.getUser = function () {\n\t\treturn this.user;\n\t}\n\n\t/**\n\t * @method getApp\n\t * @return {App}\n\t */\n\tthis.getApp = function () {\n\t\treturn this.app;\n\t}\n\n\t/**\n\t * @method getScore\n\t * @return {number} the value of this score\n\t */\n\tthis.getScore = function () {\n\t\treturn this.score;\n\t}\n\n\t/**\n\t * @method getData\n\t * @return {object|null} the arbitrary data for this score, or null\n\t */\n\tthis.getData = function () {\n\t\treturn this.data;\n\t}\n});\n\n/**\n * @property defaultLeaderboard\n * @static\n * @type {string}\n */\nScore.defaultLeaderboard = \"default\";\n\n/**\n * @property parseScoreResponse\n * @static\n * @private\n */\nScore.parseScoreResponse = function (response) {\n\tresponse.items = response.items || [];\n\treturn response.items.map(function (scoreData) {\n\t\treturn new Score(scoreData);\n\t});\n}\n\nexports = Score;\n","pre":true},"../../../social/lib/GCSocial/User.js":{"path":"../../../social/lib/GCSocial/User.js","friendlyPath":".User","directory":"../../../social/lib/GCSocial/","filename":"User.js","src":"jsio(\"import lib.PubSub as PubSub\");\njsio(\"import .node.ff as ff\");\njsio(\"import .BaseUser\");\njsio(\"import std.uri\");\n\n/**\n * Static count of number of connections, \n * used to key observable collection\n * @type {Number}\n */\nvar connectionCount = 0;\n\n/**\n * This class represents a user, and any connections (via various\n * services like facebook, twitter, and the phone's contact list) to\n * the current user.\n * \n * Do not instantiate a user yourself; instead, call the static method\n * `User.create(info)` which caches users.\n * \n * Call social actions, like `sendGift` and `sendInvite` on this class.\n * \n * @class User\n * @extends BaseUser\n */\nvar social_lib_GCSocial_User=__class__;var User = exports=social_lib_GCSocial_User(function social_lib_GCSocial_User(){return this.init&&this.init.apply(this,arguments)},BaseUser, function (supr) {\n\n\t// Don't instantiate a user directly; use User.create() instead.\n\t\n\tthis.init = function (userInfo, _calledCorrectly) {\n\t\tif (!_calledCorrectly) {\n\t\t\tthrow new Error(\"Call User.create() instead of new User()\");\n\t\t}\n\t\tthis._nativeContact = null;\n\n\t\tthis.connectionID = ++connectionCount;\n\n\t\tsupr(this, 'init', arguments);\n\t}\n\n\t/**\n\t * Called to update a user's information when new data is received from the server.\n\t * @method _update\n\t * @param {object} userInfo\n\t * @protected\n\t */\n\tthis._update = function (userInfo) {\n\t\tsupr(this, '_update', [userInfo, true]);\n\t\t\n\t\t// add any services from the server\n\t\tuserInfo.services && userInfo.services.forEach(function(service) {\n\t\t\tthis._addService(service);\n\t\t}, this);\n\t\t\n\t\t// add any services from native\n\t\tif (userInfo.nativeContact) {\n\t\t\tthis._nativeContact = userInfo.nativeContact;\n\t\t\tfor (var n = 0; n < this._nativeContact.numbersList.length; n++) {\n\t\t\t\tthis._addService({\n\t\t\t\t\tservice: \"phone\",\n\t\t\t\t\tname: this._nativeContact.name,\n\t\t\t\t\tkey: this._nativeContact.digitsMD5List[n],\n\t\t\t\t\tdigits: this._nativeContact.numbersList[n],\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tthis.emit('change', this);\n\t}\n\t\n\tthis._addService = function (info) {\n\t\tfor (var i = 0, existingService; existingService = this._services[i]; i++) {\n\t\t\tif (existingService.getKey() == info.key) {\n\t\t\t\texistingService._update(info);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tthis._services.push(new ServiceConnection(info));\n\t}\n\n\t/**\n\t * @method getName\n\t */\n\tthis.getName = function () {\n\t\tvar name = supr(this, 'getName');\n\t\tif (name && this.getNameSource() == \"manual\") {\n\t\t\treturn name;\n\t\t} else if (this._nativeContact && this._nativeContact.name) {\n\t\t\treturn this._nativeContact.name;\n\t\t} else {\n\t\t\treturn name;\n\t\t}\n\t}\n\n\t/**\n\t * @method getImageURL\n\t */\n\tthis.getImageURL = function () {\n\t\tvar origURL = supr(this, 'getImageURL', arguments);\n\t\tvar nativeLookup = this._nativeContact && this._nativeContact.lookup;\n\t\tvar nativeURL = '@CONTACTPICTURE|' + nativeLookup;\n\t\tif (origURL) {\n\t\t\treturn origURL;\n\t\t}\n\t\t\n\t\tvar url = new std.uri(gcsocial.getEndpoint() + \"/users/\" + \n\t\t\t\t\t\t\t  this._getURLID() + \"/image\");\n\t\tif (nativeLookup) {\n\t\t\turl = url.addQuery({redirect: nativeURL})\n\t\t}\n\t\treturn url.toString();\n\t}\n\n\t/**\n\t * Returns type flags representing the services this user is connected to.\n\t * @method getTypeFlags\n\t * @return {number}\n\t */\n\tthis.getTypeFlags = function () {\n\t\tvar flags = 1;\n\t\tif (this.id != null) {\n\t\t\tflags |= this.IN_NETWORK;\n\t\t}\n\t\tif (this.getService(\"phone\")) {\n\t\t\tflags |= this.PHONE; \n\t\t}\n\t\treturn flags;\n\t}\t\n\n\t/**\n\t * Send a gift to the given user. The user must have a GC user ID.\n\t * @method sendGift\n\t * @param {object} opts the default value \n\t * @param {string} opts.giftID the UUID of the gift\n\t * @param {string} opts.title the title to show upon receipt\n\t * @param {string} opts.message the message to show upon receipt\n\t * @param {string} opts.data extra data to pass along\n\t * @param {function(err, result)} cb\n\t * @deprecated\n\t */\n\tthis.sendGift = function(opts, cb) {\n\t\tif (!this.getID()) {\n\t\t\t// TODO: if this person doesn't have a userID, what now?\n\t\t\tconsole.error(\"User\", this, \"does not have an ID and can't be sent a gift.\");\n\t\t\tcb && cb(new Error(\"This user does not have an ID.\"));\n\t\t\treturn;\n\t\t}\n\t\tvar f = ff(this, function () {\n\t\t\tgcsocial.ajax(\"PUT\", \"/apps/:appID/gifts/\" + opts.giftID +\n\t\t\t\t\t\t  \"/users/\" + this.getID() + \"/\", {\n\t\t\t\t\t\t\t  body: {\n\t\t\t\t\t\t\t\t  title: opts.title,\n\t\t\t\t\t\t\t\t  message: opts.message,\n\t\t\t\t\t\t\t\t  data: opts.data,\n\t\t\t\t\t\t\t  },\n\t\t\t\t\t\t  }, f());\n\t\t}).cb(cb);\n\t}\n\n\t/**\n\t * Send an invite to this user.\n\t * @method sendInvite\n\t * @param {object} opts\n\t * @param {string} opts.title the title of the invite (required)\n\t * @param {string} opts.message the message text of the invite (required)\n\t * @param {string} [opts.smsMessage] an alternate message to be used only when sending an SMS (replaces message)\n\t * @param {boolean} [opts.includeLink] whether or not to include a URL in the invite\n\t * @param {string} [opts.inviteURLTemplate] a URL with a placeholder for the invite code as {code}\n\t * @param {object} [opts.data] arbitrary data to associate with this object\n\t * @param {boolean} [opts.forceSMS] force the invite to be sent over SMS even if the user accepts push\n\t * @param {function(err, invite)} [cb] the callback\n\t */\n\tthis.sendInvite = function (opts, cb) {\n\t\topts = merge(opts, {\n\t\t\tincludeLink: true,\n\t\t\tinviteURLTemplate: gcsocial.app._getInviteURLTemplate(),\n\t\t\tdata: {},\n\t\t\tforceSMS: false, // force invite via SMS instead of push\n\t\t\ttitle: null,\n\t\t\tmessage: null,\n\t\t\tsmsMessage: opts.message,\n\t\t});\n\n\t\t// generate a device id to track invite flow\n\t\topts.data = merge(opts.data, {\n\t\t\t_deviceID: gcsocial.generateDeviceID()\n\t\t});\n\n\t\tif (!opts.message) {\n\t\t\tthrow new Error(\"You must include a message in sendInvite.\");\n\t\t}\n\t\t\n\t\tvar numbersToMatchOnServer = [];\n\t\tvar phoneService = this.getService(\"phone\");\n\t\tvar numbersToSendSMS = [];\n\t\t\n\t\tif (phoneService) {\n\t\t\t// TODO: multiple phones from multiple phone services?\n\t\t\tnumbersToSendSMS.push(phoneService.getDialableNumber()); // send to max 3 numbers\n\t\t\tnumbersToMatchOnServer = [phoneService.getKey()]; // match based on key\n\t\t}\n\t\t\n\t\tvar f = ff(this, function() {\n\t\t\t// First, create an invite.\n\t\t\tgcsocial.ajax('POST', '/apps/:appID/invites/',\n\t\t\t\t\t\t  {body: {\n\t\t\t\t\t\t\t  user: {\n\t\t\t\t\t\t\t\t  phones: numbersToMatchOnServer,\n\t\t\t\t\t\t\t\t  id: this.getID(), // may be null\n\t\t\t\t\t\t\t  },\n\t\t\t\t\t\t\t  data: opts.data,\n\t\t\t\t\t\t  }}, f());\n\t\t}, function (rsp) {\n\t\t\tvar invite = rsp.invite;\n\t\t\tvar push = rsp.push;\n\t\t\t// forego URL shortening (like we did in dev_sdk)\t\t\t\n\t\t\tvar url = opts.inviteURLTemplate.replace('{code}', invite.code);\n\t\t\t\n\t\t\tif (!numbersToSendSMS.length && rsp.mainPhone) {\n\t\t\t\tnumbersToSendSMS.unshift(rsp.mainPhone); // this number takes priority\n\t\t\t}\n\n\t\t\tvar shouldSendSMS = (!push || opts.forceSMS);\n\t\t\tconsole.log(\"SENDING INVITE\", \"push\", push, \"FORCESMS\", opts.forceSMS, \"---\", JSON.stringify(opts));\n\t\t\tconsole.log(\"INVITE:\", url);\n\t\t\t\n\t\t\t// update the message\n\t\t\tif (opts.includeLink !== false && shouldSendSMS) {\n\t\t\t\topts.message += ' ' + url;\n\t\t\t\topts.smsMessage += ' ' + url;\n\t\t\t}\n\n\t\t\tf(invite, push); // pass the invite along\n\t\t\t\n\t\t\tif (window.NATIVE && shouldSendSMS) {\n\t\t\t\t// try to send via SMS\n\t\t\t\tnumbersToSendSMS.forEach(function (number) {\n\t\t\t\t\tgcsocial.callNative(\"sendSMS\", {\n\t\t\t\t\t\tnumber: number,\n\t\t\t\t\t\ttext: opts.smsMessage,\n\t\t\t\t\t}, f.slotPlain(2));\n\t\t\t\t}, this);\n\t\t\t} else {\n\t\t\t\tf(\"send via server\", null);\n\t\t\t}\n\t\t}, function (invite, push, smsErr, smsResult) {\n\t\t\tf(invite); // pass the invite along as the final result\n\n\t\t\t// track invited event on behalf of potential new user\n\t\t\tif (!push) {\n\t\t\t\tgcsocial.getDeviceID(function (err, deviceID) {\n\t\t\t\t\tgcsocial.track(\"social.invite\", {\n\t\t\t\t\t\tsourceUserID: gcsocial.user.getID(),\n\t\t\t\t\t\tsourceDeviceID: deviceID,\n\t\t\t\t\t\ttargetUserID: invite.target && invite.target.id,\n\t\t\t\t\t\ttargetDeviceID: opts.data._deviceID,\n\t\t\t\t\t\tinviteCode: invite.code\n\t\t\t\t\t}, {deviceID: invite.code});\n\t\t\t\t\t//Use invite code as the device ID so all events are unique\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (smsErr) {\n\t\t\t\t// send via native SMS failed (or just try via server)\n\t\t\t\tgcsocial.ajax(\"POST\", \"/apps/:appID/invites/\" + invite.code + \"/sent/\", {\n\t\t\t\t\tbody: {\n\t\t\t\t\t\ttitle: opts.title,\n\t\t\t\t\t\tmessage: opts.message,\n\t\t\t\t\t\tsmsMessage: opts.smsMessage,\n\t\t\t\t\t\tpushOverride: opts.forceSMS ? false : null\n\t\t\t\t\t}\n\t\t\t\t}, f());\n\t\t\t}\n\t\t}).cb(cb);\n\t}\n});\n\n\nvar _idCache = {};\nvar _allUserCache = [];\n\n/**\n * Create a new User instance, or return one if an existing user matches that\n * same user's ID.\n * @method create\n * @param {object} info user information as returned from the server\n * @static\n */\nUser.create = function(info) {\n\tif (!info) { return null; }\n\n\tvar user;\n\tif (info.id != null && window.gcsocial && info.id == gcsocial.user.id) {\n\t\tgcsocial.user._update(info);\n\t\tuser = gcsocial.user;\n\t} else if (info.id && _idCache[info.id]) {\n\t\tuser = _idCache[info.id];\n\t\tuser._update(info);\n\t} else {\n\t\t// info.services is data that comes from the server,\n\t\t// check our cached users to see if any services\n\t\t// match this data coming from the server\n\t\tinfo.services && _allUserCache.some(function (cachedUser) {\n\t\t\treturn info.services.some(function (service) {\n\t\t\t\tvar checkService = cachedUser.getService(service.service);\n\t\t\t\tif (checkService && checkService.getKey() == service.key) {\n\t\t\t\t\tuser = cachedUser;\n\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\t// check all the phone numbers and email addresses coming from\n\t\t// the native contact to see if they match any cached users\n\t\tif (!user && info.nativeContact) {\n\t\t\t_allUserCache.some(function (cachedUser) {\n\t\t\t\tvar phoneService = cachedUser.getService(\"phone\");\n\t\t\t\tvar phoneKey = phoneService && phoneService.getKey();\n\t\t\t\tif (info.nativeContact.digitsMD5List.indexOf(phoneKey) !== -1) {\n\t\t\t\t\tuser = cachedUser;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tvar emailService = cachedUser.getService(\"email\");\n\t\t\t\tvar emailKey = emailService && emailService.getKey();\n\t\t\t\tif (info.nativeContact.emailsList.indexOf(emailKey) !== -1) {\n\t\t\t\t\tuser = cachedUser;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t});\n\t\t}\n\n\t\t// if we found a user in our cache, update it\n\t\t// otherwise create a new user, and cache it\n\t\tif (user) {\n\t\t\tuser._update(info);\n\t\t} else {\n\t\t\tuser = new User(info, true);\n\t\t\t_allUserCache.push(user);\n\t\t}\n\n\t\t// cache by id if appropriate\n\t\tif (info.id) {\n\t\t\t_idCache[info.id] = user;\n\t\t}\n\t}\n\n\treturn user;\n}\n\n\n\n\n/**\n * @class ServiceConnection\n */\nServiceConnection=__class__;var ServiceConnection=ServiceConnection(function ServiceConnection(){return this.init&&this.init.apply(this,arguments)},function () {\n\n\tthis.init = function (data) {\n\t\tthis._data = data;\n\t}\n\t\n\tthis.toJSON = function () {\n\t\treturn this._data;\n\t}\n\t\n\tthis._update = function (data) {\n\t\tthis._data = merge(this._data, data);\n\t}\n\t\n\t/**\n\t * @method getServiceName\n\t * @return {string} the name of the service (\"phone\", \"twitter\"...)\n\t */\n\tthis.getServiceName = function () {\n\t\treturn this._data.service;\n\t}\n\t\n\t/**\n\t * @method getName\n\t * @return {string} the name of the user on this service.\n\t */\n\tthis.getName = function () {\n\t\treturn this._data.name;\n\t}\n\t\n\t/**\n\t * @method getDialableNumber\n\t * @return {string|null} a phone number which can be dialed, or null\n\t */\n\tthis.getDialableNumber = function () {\n\t\treturn this._data.digits || null;\n\t}\n\n\t/**\n\t * @method getKey\n\t * @return {string} the key uniquely identifying the user on this service.\n\t * @protected\n\t */\n\tthis.getKey = function () {\n\t\treturn this._data.key;\n\t}\n\t\t\n});\n","pre":true},"../../../social/lib/GCSocial/BaseUser.js":{"path":"../../../social/lib/GCSocial/BaseUser.js","friendlyPath":".BaseUser","directory":"../../../social/lib/GCSocial/","filename":"BaseUser.js","src":"jsio(\"import lib.PubSub as PubSub\");\njsio(\"import .internal.ObservableCollection as ObservableCollection\");\njsio(\"import .Score\");\njsio(\"import .node.ff as ff\");\n\n/**\n * @class BaseUser\n */\nBaseUser=__class__;var BaseUser=BaseUser(function BaseUser(){return this.init&&this.init.apply(this,arguments)},PubSub, function (supr) {\n\t\n\tthis.init = function (userInfo) {\n\t\tsupr(this, 'init', arguments);\n\t\t\n\t\tthis.info = {};\n\t\tthis._services = [];\n\t\tthis._timeChanged = +new Date();\n\n\t\tif (userInfo) {\n\t\t\tthis._update(userInfo);\n\t\t}\n\t}\n\n\tthis.toJSON = function () {\n\t\treturn merge({\n\t\t\tservices: this.getServices().map(function(service) {\n\t\t\t\treturn service.toJSON();\n\t\t\t})\n\t\t}, this.info);\n\t}\n\t\n\tthis._cachebust = function (url) {\n\t\t// TeaLeaf doesn't respect HTTP caching headers.\n\t\tif (gcsocial.isTeaLeaf && url) {\n\t\t\tvar sep = (url.indexOf(\"?\") != -1 ? \"&\" : \"?\");\n\t\t\treturn url + sep + \"cachebuster=\" + this._timeChanged;\n\t\t} else {\n\t\t\treturn url;\n\t\t}\n\t}\n\t\n\t/**\n\t * Update the user's info after downloading an update.\n\t * \n\t * @method _update\n\t * @protected\n\t */\n\tthis._update = function (userInfo, skipChangeEvent) {\n\t\tthis._timeChanged = +new Date();\n\t\tif (userInfo.info) {\n\t\t\tthrow new Error(\"AUGH\");\n\t\t}\n\t\tthis.info = merge(userInfo, this.info, {\n\t\t\tid: null,\n\t\t\tname: \"\",\n\t\t\timage: null,\n\t\t});\n\n\t\tif (!skipChangeEvent) {\n\t\t\tthis.emit('change', this);\n\t\t}\n\t}\n\n    /**\n\t * @method refresh\n\t * @param {function(err, user)} cb\n\t */\n\tthis.refresh = function (cb) {\n\t\tconsole.log(\"User Refresh...\");\n\t\tvar f = ff(this, function () {\n\t\t\tgcsocial.ajax('GET', '/users/' + this._getURLID() + '/', f());\n\t\t}, function (userInfo) {\n\t\t\tconsole.log(\"User refresh complete.\");\n\t\t\tthis._update(userInfo);\n\t\t\t\n\t\t\tif (this != gcsocial.user && \n\t\t\t\tthis.getID() != null &&\n\t\t\t\tthis.getID() == gcsocial.user.getID()) {\n\t\t\t\tconsole.log(\"Updating CurrentUser as well.\");\n\t\t\t\tgcsocial.user._update(userInfo);\n\t\t\t}\n\t\t\tf(this);\n\t\t}).cb(cb);\n\t}\n\t\n\t/** \n\t * @method getID\n\t * @return {string} the GC user ID of this user, or {null} if the\n\t * user is not part of the GC network\n\t */\n\tthis.getID = function () {\n\t\treturn this.info.id;\n\t}\n\t\n\tthis._getURLID = function () {\n\t\treturn this.getID();\n\t}\n\n\t/**\n\t * @method getName\n\t * @return {string} the name of this user\n\t */\n\tthis.getName = function () {\n\t\treturn this.info.name;\n\t}\n\n    /**\n     * @method getNameSource\n     */\n    this.getNameSource = function() {\n      return this.info.nameSource; \n    }\n\n\t/**\n\t * @method getStatus\n\t * @return {string} the current status of this user, if available\n\t */\n\tthis.getStatus = function () {\n\t\treturn this.info.status;\n\t}\n\n\t/**\n\t * @method getImageURL\n\t * @return a URL representing the user's profile image.\n\t */\n\tthis.getImageURL = function () {\n\t\treturn this._cachebust(this.info.image);\n\t}\n\t\n\t/**\n\t * Returns an array of all services this User connection represents.\n\t * @method getServices\n\t * @return {ServiceConnection[]}\n\t */\n\tthis.getServices = function () {\n\t\treturn this._services || [];\n\t}\n\n\t/**\n\t * Returns a {@link ServiceConnection} object representing the\n\t * user's connection to the given service (phone, facebook, etc.).\n\t * @method getService\n\t * @param {string} service the service name (\"phone\", \"email\", \"facebook\", \"twitter\")\n\t * @return {ServiceConnection}\n\t */\n\tthis.getService = function (service) {\n\t\tvar services = this.getServices();\n\t\tfor (var i = 0; i < services.length; i++) {\n\t\t\tif (services[i].getServiceName() == service) {\n\t\t\t\treturn services[i];\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/** \n\t * Get the public data (in server-side storage) for this user. \n\t * @method getPublicData\n\t * @param {object} [opts]\n\t * @param {string} [opts.appID] the appID from which to retrieve data (optional)\n\t * @param {function(err, data)} cb\n\t */\n\tthis.getPublicData = function (opts, cb) {\n\t\tif (typeof opts == \"function\") {\n\t\t\tcb = opts;\n\t\t\topts = {};\n\t\t}\n\t\tif (!opts.appID) {\n\t\t\topts.appID = gcsocial.app.getID();\n\t\t}\n\t\tgcsocial.ajax('GET', '/users/' + this._getURLID() + '/apps/' + opts.appID + '/data/', cb);\n\t}\n\n\tthis._scores = new ObservableCollection({key: \"id\"});\n\n\t/**\n\t * Get the scores for a specific user.\n\t * \n\t * @method getScores\n\t * @param {string} leaderboard the leaderboard to use (otherwise \"default\")\n\t * @param {function(err, result)} cb result = {items: {@link Score}}\n\t */\n\tthis.getScores = function (leaderboard, cb) {\n\t\tif (typeof leaderboard == 'function') {\n\t\t\tcb = leaderboard;\n\t\t\tleaderboard = null;\n\t\t}\n\n\t\tleaderboard = leaderboard || Score.defaultLeaderboard;\n\t\tvar url = '/apps/:appID/leaderboards/' + leaderboard + '/scores/' + this._getURLID() + '/';\n\t\tgcsocial.ajax('GET', url, {\n\t\t\trequireConnections: true\n\t\t}, function (err, response) {\n\t\t\tif (err || !response) {\n\t\t\t\tconsole.log('Unable to retrieve user scores');\n\t\t\t\tcb && cb(err || 'Empty score response');\n\t\t\t} else {\n\t\t\t\tthis._scores.reset(Score.parseScoreResponse(response));\n\t\t\t\tcb && cb(null, this._scores);\n\t\t\t}\n\t\t}.bind(this));\n\n\t\treturn this._scores;\n\t}\n\n\t/**\n\t * Sent a notification to the user.\n\t *\n\t * @method send\n\t * @param {object} data\t\tjson data repsenting data to send\n\t * @param {object} opts\t\t\toptional parameters\n\t */\n\tthis.send = function(data, opts, cb) {\n\t\tvar url = '/users/' + this._getURLID() + '/notifications/';\n\t\tvar callback = cb || function() {};\n\n\t\tgcsocial.ajax('PUT', url, {\n\t\t\tbody: {\n\t\t\t\tdata: data,\t\n\t\t\t\topts: opts\n\t\t\t}\n\t\t}, callback);\n\t}\n\n\t/**\n\t * Represents all possible user connections.\n\t * @property ALL\n\t * @type {number}\n\t */\n\tthis.ALL = 0xFFFFFFFF;\n\t/**\n\t * Represents only connections in the GC network.\n\t * @property IN_NETWORK\n\t * @type {number}\n\t */\n\tthis.IN_NETWORK = 1 << 1;\n\t/**\n\t * Represents connections through a phone's contacts.\n\t * @property PHONE\n\t * @type {number}\n\t */\n\tthis.PHONE = 1 << 2;\n\t/**\n\t * Represents connections through Facebook.\n\t * @property FACEBOOK\n\t * @type {number}\n\t */\n\tthis.FACEBOOK = 1 << 3;\n\t/**\n\t * Represents connections through Twitter.\n\t * @property TWITTER\n\t * @type {number}\n\t */\n\tthis.TWITTER = 1 << 4;\n\t/**\n\t * Represents all server connections, but not phone contacts.\n\t * @property ALL_SERVER\n\t * @type {number}\n\t */\n\tthis.ALL_SERVER = this.ALL & ~this.PHONE;\n});\n\nexports = BaseUser;\n","pre":true},"../../../social/lib/GCSocial/internal/ObservableCollection.js":{"path":"../../../social/lib/GCSocial/internal/ObservableCollection.js","friendlyPath":".internal.ObservableCollection","directory":"../../../social/lib/GCSocial/internal/","filename":"ObservableCollection.js","src":"jsio(\"import lib.PubSub\");\n\n/**\n * An ObservableCollection acts as a (sorted/ordered) set of items.\n * Each item must be represented by a key (typically an \"id\").\n * Upon updating/changing the collection, the following events are emitted:\n * \n * - \"add\": [ item ]  -- an item was added\n * - \"remove\": [ item ]  -- an item was removed\n * - \"change\": [ item ]  -- an item was updated OR added\n * \n * It acts as an array-like object as well.\n * \n * @class ObservableCollection\n * @constructor\n * @param {array} [items] an array of items to initially populate the collection\n * @param {object} [opts]\n * @param {string} [opts.key] the objects' key (default \"id\") to sort by\n * @param {function(item)} [opts.sorter] a function that returns the value to be compared with\n * @param {boolean} [opts.reverse] whether or not to sort the collection in reverse\n */\nvar social_lib_GCSocial_internal_ObservableCollection=__class__;var ObservableCollection = exports=social_lib_GCSocial_internal_ObservableCollection(function social_lib_GCSocial_internal_ObservableCollection(){return this.init&&this.init.apply(this,arguments)},lib.PubSub, function(supr) {\n\n\tthis.init = function(items, opts) {\n\t\tsupr(this, 'init', []);\n\n\t\t// both items and opts are optional\n\t\tif (!opts) {\n\t\t\tif (Array.isArray(items)) {\n\t\t\t\topts = {};\n\t\t\t} else {\n\t\t\t\topts = items;\n\t\t\t\titems = [];\n\t\t\t}\n\t\t}\n\t\tthis._opts = opts = merge(opts, {\n\t\t\tkey: null,\n\t\t\tsorter: null,\n\t\t\treverse: false,\n\t\t\tupdater: null,\n\t\t\tcreator: null,\n\t\t});\n\n\t\tthis.length = 0;\n\t\tthis._byIndex = [];\n\t\tthis._byID = {};\n\n\t\tthis._key = opts.key;\n\t\tthis.setSorter(opts.sorter, opts.reverse);\n\t\t\n\t\tthis.add(items);\n\t};\n\n\t/**\n\t * Add an object (or an array of objects) to this collection. Each\n\t * item must have a key (default \"id\") by which it can be indexed.\n\t * \n\t * @method add\n\t * @param {object|array} item the item/items to add\n\t */\n\tthis.add = function(item, _skipSort) {\n\t\tif (Array.isArray(item)) {\n\t\t\tfor (var i = 0, len = item.length; i < len; ++i) {\n\t\t\t\titem[i] && this.add(item[i], true);\n\t\t\t}\n\t\t\tthis.sort();\n\t\t\t\n\t\t\treturn  item;\n\t\t} else {\n\t\t\tvar id = item[this._key];\n\n\t\t\t// note: not the same as `if (!id) { ... }`\n\t\t\tif (id == null) { return; }\n\n\n\t\t\tif (this._byID[id]) {\n\t\t\t\tfor (var i = 0, _item; _item = this._byIndex[i]; ++i) {\n\t\t\t\t\tif (_item[this._key] == id) {\n\t\t\t\t\t\tif (this._opts.updater) {\n\t\t\t\t\t\t\titem = this._opts.updater.call(this._byIndex[i], item);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis._byID[id] = item;\n\t\t\t\t\t\tthis._byIndex[i] = item;\n\t\t\t\t\t\tthis.emit(\"change\", item);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this._opts.creator) {\n\t\t\t\t\titem = this._opts.creator(item);\n\t\t\t\t}\n\t\t\t\tthis._byID[id] = item;\n\t\t\t\tthis._byIndex[this.length++] = item;\n\t\t\t\tthis.emit(\"add\", item);\n\t\t\t}\n\n\t\t\tif (this._sorter) {\n\t\t\t\titem._sortKey = this._sorter(item);\n\t\t\t}\n\t\t\t\n\t\t\tif (!_skipSort) {\n\t\t\t\tthis.sort();\n\t\t\t}\n\n\t\t\treturn item;\n\t\t}\n\t};\n\t\n\t/**\n\t * Remove an item from the collection, given an ID or object.\n\t * @method remove\n\t * @param {string|object} the object, or ID of an object, to remove\n\t * @return {object|null} the removed object, if found\n\t */\n\tthis.remove = function(id) {\n\t\tif (typeof id == 'object') { id = id[this._key]; }\n\t\tif (id == null) { return; }\n\n\t\tif (this._byID[id]) {\n\t\t\tthis.emit(\"remove\", this._byID[id]);\n\t\t\tdelete this._byID[id];\n\t\t\tfor (var i = 0, item; item = this._byIndex[i]; ++i) {\n\t\t\t\tif (item[this._key] == id) {\n\t\t\t\t\t--this.length;\n\t\t\t\t\treturn this._byIndex.splice(i, 1)[0];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t// Methods that don't change the original array:\n\t\n\t/**\n\t * Same as Array.slice\n\t * @method slice\n\t */\n\t\n\t/**\n\t * Same as Array.indexOf\n\t * @method indexOf\n\t */\n\n\t/**\n\t * Same as Array.forEach\n\t * @method forEach\n\t */\n\n\t/**\n\t * Same as Array.map\n\t * @method map\n\t */\n\n\t/**\n\t * Same as Array.filter\n\t * @method filter\n\t */\n\n\t/**\n\t * Same as Array.some\n\t * @method some\n\t */\n\n\t/**\n\t * Same as Array.reduce\n\t * @method reduce\n\t */\n\n\t/**\n\t * Same as Array.every\n\t * @method every\n\t */\n\n\t/**\n\t * Same as Array.join\n\t * @method join\n\t */\n\n\t/**\n\t * Same as Array.reduceRight\n\t * @method reduceRight\n\t */\n\n\n\t[\"slice\", \"indexOf\", \"forEach\", \"map\", \"filter\", \"some\", \"reduce\",\n\t \"every\", \"join\", \"reduceRight\"].forEach(function (method) {\n\t\tthis[method] = function () {\n\t\t\treturn this._byIndex[method].apply(this._byIndex, arguments);\n\t\t};\n\t}, this);\n\t\n\n\t/**\n\t * Like Array.filter, except that it returns another\n\t * ObservableCollection that automatically updates when its parent\n\t * collection updates. IMPORTANT NOTE: To prevent memory leaks, do\n\t * not call this method multiple times with the same arguments.\n\t * Collections returned from this method are a copy of the original\n\t * collection, but which listen for the parent collection's change\n\t * events. Just save away your collection here and it will be\n\t * automatically updated when the parent collection updates. If\n\t * you need a copy that doesn't update, use .filter() instead.\n\t * @method filterLive\n\t * @param {function(item)} filterFn\n\t * @return {ObservableCollection}\n\t */\n\tthis.filterLive = function(filterFn) {\n\t\tvar ds = new ObservableCollection(this._opts);\n\t\tthis.forEach(function (item) {\n\t\t\tif (filterFn(item)) {\n\t\t\t\tds.add(item);\n\t\t\t}\n\t\t});\n\n\t\tthis.on(\"add\", function (item) {\n\t\t\tif (filterFn(item)) {\n\t\t\t\tds.add(item);\n\t\t\t}\n\t\t});\n\n\t\tthis.on(\"change\", function (item) {\n\t\t\tif (filterFn(item)) {\n\t\t\t\tds.add(item);\n\t\t\t} else {\n\t\t\t\tds.remove(item);\n\t\t\t}\n\t\t});\n\n\t\tthis.on('remove', function (item) {\n\t\t\tds.remove(item);\n\t\t});\n\t\t\n\t\treturn ds;\n\t};\n\n\t/**\n\t * Set the sorter function for this collection. The sorter function should\n\t * return a value used for comparing each item.\n\t * @method setSorter\n\t * @param {function(item)} sorter\n\t * @param {boolean} [reverse] if true, the sorter sorts in reverse\n\t */\n\tthis.setSorter = function(sorter, reverse) {\n\t\tthis._sorter = sorter;\n\t\tif (sorter) {\n\t\t\tfor (var i = 0, item; item = this._byIndex[i]; ++i) {\n\t\t\t\titem._sortKey = sorter(item);\n\t\t\t}\n\t\t}\n\t\tif (reverse !== undefined) {\n\t\t\tthis.setReverse(reverse); // this resorts\n\t\t} else {\n\t\t\tthis.sort();\n\t\t}\n\t\treturn this;\n\t};\n\t\n\t/**\n\t * Set whether or not the sorter sorts in reverse.\n\t * @param {boolean} reverse if true, the sorter sorts in reverse\n\t */\n\tthis.setReverse = function(reverse) {\n\t\tthis._reverse = reverse;\n\t\tthis.sort();\n\t}\n\n\t/**\n\t * Returns true if this collection contains the given item or key.\n\t * @method contains\n\t * @param {string|object} itemOrID\n\t * @return {boolean}\n\t */\n\tthis.contains = function(id) {\n\t\tif (typeof id == 'object') { id = id[this._key]; }\n\t\treturn !!this._byID[id];\n\t};\n\t\n\t/**\n\t * Returns the object for a given key, or null.\n\t * @method get\n\t * @param {string} key\n\t * @return {object|null}\n\t */\n\tthis.get = function(id) {\n\t\treturn this._byID[id] || null;\n\t}\n\n\t/**\n\t * Sort the collection.\n\t * @method sort\n\t * @return null\n\t */\n\tthis.sort = function() {\n\t\tvar reverse = this._reverse;\n\t\tthis._byIndex.sort(function(a, b) {\n\t\t\ta = a._sortKey || a[this._key];\n\t\t\tb = b._sortKey || b[this._key];\n\t\t\tif (a < b) {\n\t\t\t\treturn reverse ? 1 : -1;\n\t\t\t} else if (a > b) {\n\t\t\t\treturn reverse ? -1 : 1;\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}.bind(this));\n\t};\n\n\t/**\n\t * Return a plain-old JavaScript array of the current collection.\n\t * @method toArray\n\t * @return {array}\n\t */\n\tthis.toArray = function() { return this._byIndex.slice(0); }\n\n\t/**\n\t * Reset this collection to the given array of items, or empty it\n\t * if no new items are provided. You'll often use this when you\n\t * get a new array back from a server response.\n\t * @method reset\n\t * @param {array|null} newArray the new items to set the collection to, or null.\n\t */\n\tthis.reset = function(newArray) {\n\t\tnewArray = newArray || [];\n\t\t\n\t\tvar key = this._key;\n\n\t\t// create a key-indexed copy of newArray to run the comparison against\n\t\tvar newItemMap = {};\n\t\tfor (var i = 0, n = newArray.length; i < n; ++i) {\n\t\t\tnewItemMap[newArray[i][key]] = newArray[i];\n\t\t}\n\n\t\t// first, compare all items in the index to newArray\n\t\tvar existingItems = this._byIndex.slice(0);\n\t\tfor (var i = 0, item; item = existingItems[i]; ++i) {\n\t\t\tvar k = item[key];\n\t\t\tif (newItemMap[k]) {\n\t\t\t\tthis.add(newItemMap[k], true);\n\t\t\t\tdelete newItemMap[k];\n\t\t\t} else {\n\t\t\t\tthis.remove(item);\n\t\t\t}\n\t\t}\n\n\t\t// Any remaining items in newItemMap should be added.\n\t\tfor (var k in newItemMap) {\n\t\t\tthis.add(newItemMap[k], true);\n\t\t}\n\n\t\tthis.sort();\n\t}\n\t\n\tthis.toDataSource = function(opts) {\n\t\tvar DataSource = jsio(\"import squill.models.DataSource\");\n\t\t\n\t\topts = merge(opts, {\n\t\t\tkey: this._key,\n\t\t\treverse: this._reverse,\n\t\t\tsorter: this._sorter && function (item) {\n\t\t\t\tvar key = this._sorter(item);\n\t\t\t\tif (typeof key === \"number\") {\n\t\t\t\t\tkey = \"000000000000000\".slice((key+\"\").length) + key;\n\t\t\t\t}\n\t\t\t\treturn key;\n\t\t\t}.bind(this)\n\t\t});\n\n\t\tvar ds = new DataSource(opts);\n\t\t\n\t\tthis.forEach(function (item) {\n\t\t\tds.add(item);\n\t\t});\n\t\t\n\t\tthis.on(\"change\", function (item) {\n\t\t\tds.add(item);\n\t\t});\n\t\t\n\t\tthis.on(\"add\", function (item) {\n\t\t\tds.add(item);\n\t\t});\n\t\t\n\t\tthis.on(\"remove\", function (item) {\n\t\t\tds.remove(item);\n\t\t});\n\t\t\n\t\treturn ds;\n\t}\n});\n","pre":true},"../../../social/lib/GCSocial/Room.js":{"path":"../../../social/lib/GCSocial/Room.js","friendlyPath":".Room","directory":"../../../social/lib/GCSocial/","filename":"Room.js","src":"jsio(\"import lib.PubSub as PubSub\");\njsio(\"import .node.ff as ff\");\n\n/**\n * For managing asynchronous multiplayer room\n * @class Room\n * @constructor\n * @param {object} opts - Initial state of game room\n */\nvar social_lib_GCSocial_Room=__class__;var Room = exports=social_lib_GCSocial_Room(function social_lib_GCSocial_Room(){return this.init&&this.init.apply(this,arguments)},PubSub, function () {\n\n\tthis.init = function (opts) {\n\t\tthis._isUpdating = null;\n\t\tthis._pollHandle = null;\n\t\tthis._opponents = [];\n\t\tthis._keyUpdated = {};\n\t\tvar App = jsio(\"import .App\");\n\t\tthis.id = opts.id;\n\t\tthis.app = opts.app.id == gcsocial.app.getID() ?\n\t\t\t\t\tgcsocial.app :\n\t\t\t\t\tnew App(opts.app);\n\t\tthis.created = opts.created ? new Date(opts.created) : null;\n\t\tthis._update(opts);\n\t}\n\n\t/**\n\t * Update the room when data is retrieved from the server.\n\t * \n\t * @method _update\n\t * @param {object} details - Data to update room\n\t * @private\n\t */\n\tthis._update = function (details) {\n\t\tif (!details.updated) {\n\t\t\tconsole.log(\"Cannot update room without lastupdated\", details);\n\t\t}\n\t\tvar updated = new Date(details.updated);\n\t\tvar User = jsio(\"import .User\");\n\t\tif (details.users) {\n\t\t\tthis._opponents = [];\n\t\t\tthis.users = details.users.map(function (user) {\n\t\t\t\tuser = User.create(user);\n\t\t\t\tif (user.getID() != gcsocial.user.getID()) {\n\t\t\t\t\tthis._opponents.push(user);\n\t\t\t\t}\n\t\t\t\treturn user;\n\t\t\t}.bind(this));\n\t\t}\n\t\tif (details.metadata != null) {\n\t\t\tthis.metadata = details.metadata;\n\t\t}\n\t\tif (details.data != null) {\n\t\t\tthis.data = details.data;\n\t\t}\n\t\tthis.updated = updated;\n\t\tthis.emit('change', this);\n\t}\n\n\t/**\n\t * Get the room's ID.\n\t *\n\t * @method getID\n\t * @return {string} room id\n\t */\n\tthis.getID = function () {\n\t\treturn this.id;\n\t}\n\n\t/**\n\t * Get users in the room.\n\t * \n\t * @method getUsers\n\t * @return {User[]} array of users\n\t */\n\tthis.getUsers = function () {\n\t\treturn this.users;\n\t}\n\n\t/**\n\t * Get the current app\n\t * \n\t * @method getApp\n\t * @return {App}\n\t */\n\tthis.getApp = function () {\n\t\treturn this.app;\n\t}\n\n\t/**\n\t * Get room metadata. The room's metadata is retrieved in room\n\t * lists, in contrast to room data, which is only retrieved when\n\t * querying individual rooms.\n\t * \n\t * @method getMetadata\n\t * @return {object} room metadata\n\t */\n\tthis.getMetadata = function () {\n\t\treturn this.metadata || {};\n\t}\n\n\t/**\n\t * Get room data.\n\t * \n\t * @method getData\n\t * @return {object}\n\t */\n\tthis.getData = function () {\n\t\treturn this.data || {};\n\t}\n\n\t/**\n\t * Get lasted updated date string\n\t * \n\t * @method getUpdated\n\t * @return {Date}\n\t */\n\tthis.getUpdated = function () {\n\t\treturn this.updated;\n\t}\n\n\t/**\n\t * Get current player\n\t * \n\t * @method getMe\n\t * @return {CurrentUser}\n\t */\n\tthis.getMe = function () {\n\t\treturn gcsocial.user;\n\t}\n\t\n\t/**\n\t * Get an array of all opponents.\n\t * \n\t * @method getOpponents\n\t * @return {User[]} array of opponents\n\t */\n\tthis.getOpponents = function () {\n\t\treturn this._opponents;\n\t}\n\t\n\t/**\n\t * Get one opponent (for a two-player game).\n\t * \n\t * @method getOpponent\n\t * @return {User} an opponent\n\t */\n\tthis.getOpponent = function () {\n\t\treturn this._opponents.length && this._opponents[0] || null;\n\t}\n\t\n\t/**\n\t * Refresh the current room with server data.\n\t * \n\t * @method refresh\n\t * @param {function(err)} cb handler called when the refresh completes\n\t * @return {Room} update room (in callback)\n\t */\n\tthis.refresh = function (cb) {\n\t\tif (this._isUpdating) {\n\t\t\treturn cb && cb({error:\"updating\"});\n\t\t}\n\n\t\tvar f = ff(this, function () {\n\t\t\tgcsocial.ajax(\"GET\", \"/apps/:appID/rooms/\" + this.id + \"/data/\", {\n\t\t\t\trequireConnections: true\n\t\t\t}, f());\n\t\t}, function (room) {\n\t\t\tthis._update(room);\n\t\t\tf(this);\n\t\t}).cb(cb || function() {});\n\t}\n\n\t/**\n\t * Return the key for a single room data property\n\t * \n\t * @return {string} key - the property key to fetch\n\t * @param {function(err,object)} cb - the callback with the room key data\n\t */\n\tthis.refreshDataKey = function (key, cb) {\n\t\tif (this._isUpdating) {\n\t\t\treturn cb && cb({error:\"updating\"});\n\t\t}\n\n\t\tvar f = ff(this, function () {\n\t\t\tgcsocial.ajax(\"GET\", \"/apps/:appID/rooms/\" + this.id + \"/data/\" + key, f());\n\t\t}, function (response) {\n\t\t\tvar updatedLocal = this._keyUpdated[key] || this.updated;\n\t\t\tvar updatedServer = new Date(response.updated);\n\t\t\tthis._keyUpdated[key] = updatedServer;\n\t\t\tif (updatedServer > updatedLocal) {\n\t\t\t\tthis.data[key] = response.data;\n\t\t\t\tthis.emit('change', this);\n\t\t\t}\n\t\t\tf(response.data);\n\t\t}).cb(cb);\n\t}\n\n\t/**\n\t * Poll the server for changes to the room.\n\t * \n\t * @method poll\n\t * @return @param {number} frequency - Time in milliseconds between poll\n\t */\n\tthis.poll = function (frequency) {\n\t\tthis.cancelPoll();\n\t\tthis._pollHandle = setInterval(this.refresh.bind(this), frequency);\n\t\tthis.refresh();\n\t}\n\n\t/**\n\t * Cancel polling the server for changes.\n\t * \n\t * @method cancelPoll\n\t */\n\tthis.cancelPoll = function () {\n\t\tif (this._pollHandle) {\n\t\t\tclearInterval(this._pollHandle);\n\t\t}\n\t}\n\n\t/**\n\t * Post an update to the room.\n\t * \n\t * @method update\n\t * @param {object} opts\n\t * @param {object} [opts.metadata] room metadata\n\t * @param {object} [opts.data] room data\n\t * @param {function(err)} cb callback for success or failure\n\t */\n\tthis.update = function (opts, cb) {\n\t\tif (opts instanceof Room) {\n\t\t\treturn; // for compatibility with squill DataSource\n\t\t}\n\t\tif (this._isUpdating) {\n\t\t\treturn cb && cb({error:\"updating\"});\n\t\t}\n\t\tthis._isUpdating = true;\n\t\tvar f = ff(this, function () {\n\t\t\tgcsocial.ajax(\"PUT\", \"/apps/:appID/rooms/\" + this.id + \"/data/\", {\n\t\t\t\tbody: {\n\t\t\t\t\tupdated: this.updated,\n\t\t\t\t\tmetadata: opts.metadata || null,\n\t\t\t\t\tdata: opts.data || null\n\t\t\t\t},\n\t\t\t\trequireConnections: true\n\t\t\t}, f.slotPlain(2));\n\t\t}, function (err, game) {\n\t\t\tif (err && err.code == 409) {\n\t\t\t\tlogger.log('Game out of date; updating with latest info.');\n\t\t\t\tif (err.room) {\n\t\t\t\t\t// TODO: This overwrites the game state you wanted to change.\n\t\t\t\t\tthis._update(err.room); // update the game first\n\t\t\t\t}\n\t\t\t} else if (err) {\n\t\t\t\tlogger.error('Error in updateGame:', JSON.stringify(err));\n\t\t\t} else {\n\t\t\t\tthis._update(game);\n\t\t\t}\n\n\t\t\tthis._isUpdating = false;\n\t\t\tf(err, game);\n\t\t}).cb(cb);\n\t}\n\n\t/**\n\t * Update a single property on the game's data objects\n\t * \n\t * @param  {string}   key   the property to set\n\t * @param  {object|string}   value the value of the property we are setting\n\t * @param  {function(err)} cb  the success or failure callback\n\t */\n\tthis.updateDataKey = function (key, value, cb) {\n\t\tif (this._isUpdating) {\n\t\t\treturn cb && cb({error:\"updating\"});\n\t\t}\n\t\tthis._isUpdating = true;\n\n\t\tvar f = ff(this, function () {\n\t\t\tgcsocial.ajax(\"PUT\", \"/apps/:appID/rooms/\" + this.id + \"/data/\" + key, {\n\t\t\t\tbody: {\n\t\t\t\t\tupdated: this._keyUpdated[key] || this.updated,\n\t\t\t\t\tdata: value\n\t\t\t\t}\n\t\t\t}, f());\n\t\t}, function (response) {\n\t\t\tthis._isUpdating = false;\n\t\t\tthis.updated = this._keyUpdated[key] = new Date(response.updated);\n\t\t\tthis.data[key] = value;\n\t\t\tthis.emit(\"change\", this);\n\t\t}).cb(cb);\n\t}\n\n});\n\nvar _roomCache = {};\n\n/**\n * Create a new Room instance, or return on if we have already created an object for this room\n * \n * @method create\n * @param {object} info - room information from server\n * @static\n */\nRoom.create = function (info) {\n\tvar room = _roomCache[info.id];\n\tif (room && info.id != null) {\n\t\troom._update(info);\n\t} else {\n\t\t_roomCache[info.id] = room = new Room(info);\n\t}\n\treturn room;\n}\n\n/**\n * Parse a multi room server response into an array of room objects.\n * \n * @method parseRoomResponse\n * @static\n * @param {object} response server response for getting rooms\n * @return {Room[]} array of room objects\n * @private\n */\nRoom.parseRoomResponse = function (response) {\n\tresponse.items = response.items || [];\n\treturn response.items.map(function (room) {\n\t\treturn Room.create(room);\n\t});\n}\n","pre":true},"../../../social/lib/GCSocial/CurrentUser.js":{"path":"../../../social/lib/GCSocial/CurrentUser.js","friendlyPath":".CurrentUser","directory":"../../../social/lib/GCSocial/","filename":"CurrentUser.js","src":"jsio(\"import .internal.ObservableCollection as ObservableCollection\");\njsio(\"import .User\");\njsio(\"import .BaseUser\");\njsio(\"import .node.ff as ff\");\njsio(\"import .Score\");\njsio(\"import .Room\");\njsio(\"import .App\");\njsio(\"import .Notification\");\njsio(\"import .internal.ObservableCollection as ObservableCollection\");\n\n/**\n * This class represents the currently-logged-in user.\n * @class CurrentUser\n * @extends BaseUser\n */\nCurrentUser=__class__;var CurrentUser=CurrentUser(function CurrentUser(){return this.init&&this.init.apply(this,arguments)},BaseUser, function (supr) {\n\n\tthis.init = function (userInfo) {\n\t\tsupr(this, 'init', arguments);\n\t\t\n\t\tthis._nativeContacts = [];\n\t\tthis._shimScores = []; // extra scores to add for testing\n\t\tthis._shimConnections = []; // extra users to add for testing\n\t\tthis._shimNotifications = []; // extra notifications to add for testing\n\t\tthis._inviteDeferred = ff.defer();\n\t\t\n\t\tthis._notifications = new ObservableCollection({key: \"_uniqueID\"});\n\n\t\t// update the contacts as applicable\n\t\tgcsocial.on(\"updateContacts\", function (contacts) {\n\t\t\t// TODO: use phone contacts sent from native\n\t\t\tconsole.log(\"Got contacts update events\", contacts.length);\n\t\t\tthis.getConnections(gcsocial.user.PHONE);\n\t\t}.bind(this));\n\n\t\t// this is a fairly private handler.\n\t\tgcsocial.on(\"invite\", function (evt) {\n\t\t\t// evt.invite may be null.\n\t\t\tthis._inviteDeferred(evt.invite ? new Notification(evt.invite) : null);\n\t\t}.bind(this));\n\t\t\n\t\tgcsocial.on(\"close\", function (evt) {\n\t\t\tconsole.log(\"Refreshing social user because the UI closed...\");\n\t\t\tthis.refresh();\n\t\t}.bind(this));\n\t}\n\t\n\tthis._getURLID = function () {\n\t\treturn \"me\";\n\t}\n\t\n\t/**\n\t * @method getInvite\n\t * @param {function(err, invite|null)} cb callback; invite will be null if no invite exists.\n\t */\n\tthis.getInvite = function(cb) {\n\t\tthis._inviteDeferred.cb(cb);\n\t}\n\t\n\t/**\n\t * Return the current social server authentication key.\n\t * @method getAuthKey\n\t * @return {string}\n\t */\n\tthis.getAuthKey = function () {\n\t\treturn gcsocial.key;\n\t}\n\t\n\t/**\n\t * @method getImageURL\n\t */\n\tthis.getImageURL = function () {\n\t\tvar url = supr(this, 'getImageURL', arguments);\n\t\t// TODO: put current user's profile pic from native here\n\t\treturn url;\n\t}\n\n\t/**\n\t * Set the display name of the current user, overriding any default.\n\t * @method setName\n\t * @param {string} name the new display name\n\t * @param {function(err)} cb\n\t */\n\tthis.setName = function (name, cb) {\n\t\tvar f = ff(this, function () {\n\t\t\tgcsocial.ajax('POST', '/users/me/', {\n\t\t\t\tbody: {\n\t\t\t\t\tname: name,\n\t\t\t\t\tnameSource: 'manual'\n\t\t\t\t}\n\t\t\t}, f());\n\t\t}, function (userInfo) {\n\t\t\tthis._update(userInfo);\n\t\t}).cb(cb);\n\t}\n\n\t/**\n\t * Set the status of the current user.\n\t * @method setStatus\n\t * @param {string} name the new status\n\t * @param {function(err)} cb\n\t */\n\tthis.setStatus = function (status, cb) {\n\t\tvar f = ff(this, function () {\n\t\t\tgcsocial.ajax('POST', '/users/me/', {\n\t\t\t\tbody: {\n\t\t\t\t\tstatus: status\n\t\t\t\t}\n\t\t\t}, f());\n\t\t}, function (userInfo) {\n\t\t\tthis._update(userInfo);\n\t\t}).cb(cb);\n\t}\n\n\t/**\n\t * Post a new score for the current user in this app.\n\t * @method postScore\n\t * @param {object} opts\n\t * @param {string} [opts.leaderboard] The leaderboard to use, or \"default\"\n\t * @param {number} opts.score the score to post\n\t * @param {\"max\"|\"latest\"} [opts.method=\"max\"] \"max\" to only save if the score is higher; \"latest\" to replace all previous scores.\n\t * @param {object} [opts.data] arbitrary data (optional)\n\t * @param {function(err)} cb\n\t */\n\tthis.postScore = function (opts, cb) {\n\t\tif (typeof opts == \"function\") {\n\t\t\tcb = opts;\n\t\t\topts = {};\n\t\t}\n\t\tvar leaderboard = opts.leaderboard || Score.defaultLeaderboard;\n\t\tvar url = '/apps/:appID/leaderboards/' + leaderboard + '/scores/me/';\n\t\tgcsocial.ajax('POST', url, {\n\t\t\tbody: {\n\t\t\t\tmethod: opts.method || \"max\",\n\t\t\t\tscore: opts.score,\n\t\t\t\tdata: opts.data || {}\n\t\t\t}\n\t\t}, function (err, response) {\n\t\t\tvar newScore;\n\t\t\tif (err) {\n\t\t\t\tconsole.log('Unable to set high score.', err);\n\t\t\t} else if (response) {\n\t\t\t\tnewScore = new Score(response);\n\t\t\t\tthis._scores.add(newScore);\n\t\t\t}\n\t\t\tcb && cb(err, newScore);\n\t\t}.bind(this));\n\t}\n\n\tthis._scoresForFriends = new ObservableCollection({key: \"id\"});\n\t/**\n\t * Return the top scores for your friends for this app.\n\t * @method getScoresForFriends\n\t * @param {string=} leaderboard The leaderboard to use, or \"default\"\n\t * @param {function(err, data)} cb data = {items: Score[]}\n\t */\n\tthis.getScoresForFriends = function (leaderboard, cb) {\n\t\tif (typeof leaderboard == 'function') {\n\t\t\tcb = leaderboard;\n\t\t\tleaderboard = null;\n\t\t}\n\n\t\tleaderboard = leaderboard || Score.defaultLeaderboard;\n\t\tvar url = '/apps/:appID/leaderboards/' + leaderboard + '/scores/' + this._getURLID() + '/friends/';\n\t\tgcsocial.ajax('GET', url, {\n\t\t\trequireConnections: true\n\t\t}, function (err, response) {\n\t\t\tif (err || !response) {\n\t\t\t\tconsole.log('Unable to retrieve user friends scores');\n\t\t\t\tcb && cb(err || 'Invalid score response');\n\t\t\t} else {\n\t\t\t\tresponse.items = this._shimScores.slice().concat(response.items);\n\t\t\t\tthis._scoresForFriends.reset(Score.parseScoreResponse(response));\n\t\t\t\tcb && cb(null, this._scoresForFriends);\n\t\t\t}\n\t\t}.bind(this));\n\n\t\treturn this._scoresForFriends;\n\t}\n\n\t// note: this is also referenced in gcsocial.app\n\tthis._rooms = new ObservableCollection({key: \"id\"});\n\n\t/**\n\t * Get a list of multiplayer game rooms for this user, or update\n\t * the existing `ObservableCollection`.\n\t * @method getRooms\n\t * @param {function(err, ObservableCollection)} cb\n\t * @return {ObservableCollection} rooms\n\t */\n\tthis.getRooms = function (cb) {\n\t\tvar url = \"/apps/:appID/users/:userID/rooms/\";\n\t\tgcsocial.ajax(\"GET\", url, {\n\t\t\trequireConnections: true\n\t\t}, function (err, response) {\n\t\t\tif (err || !response) {\n\t\t\t\tconsole.log('Unable to retrieve list of rooms for current user');\n\t\t\t\tcb && cb(err || 'Invalid room response');\n\t\t\t} else {\n\t\t\t\tthis._rooms.reset(Room.parseRoomResponse(response));\n\t\t\t\tcb && cb(null, this._rooms);\n\t\t\t}\n\t\t}.bind(this));\n\n\t\treturn this._rooms;\n\t}\n\n\t/**\n\t * Begin updating the user's room list at the given interval.\n\t * @method pollRooms\n\t * @param {number} frequency update interval in milliseconds\n\t */\n\tthis.pollRooms = function (frequency) {\n\t\tif (frequency < 1000) {\n\t\t\tthrow new Error(\"pollRooms takes an interval in milliseconds, not seconds.\");\n\t\t}\n\t\tthis.cancelPollRooms();\n\t\tthis._pollHandle = setInterval(this.getRooms.bind(this), frequency);\n\t\tthis.getRooms();\n\t}\n\n\t/**\n\t * Stop polling for room updates.\n\t * @method cancelPollRooms\n\t */\n\tthis.cancelPollRooms = function () {\n\t\tif (this._pollHandle) {\n\t\t\tclearInterval(this._pollHandle);\n\t\t}\n\t}\n\n\t/**\n\t * Check to see if you're authenticated with the given service.\n\t * Pass no arguments to return whether or not you are currently logged in.\n\t * @method isAuthenticated\n\t * @param {string=|null} the service to search for (or null to check for login).\n\t */\n\tthis.isAuthenticated = function (service) {\n\t\tif (!service) {\n\t\t\treturn !!this.getID();\n\t\t}\n\t\tthis.info.auths = this.info.auths || [];\n\t\tfor (var i = 0; i < this.info.auths.length; i++) {\n\t\t\tvar auth = this.info.auths[i];\n\t\t\tif (auth.service == service) {\n\t\t\t\t// TODO: match this phone number with the native\n\t\t\t\t// phone number so that we can register multiple phones\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tthis._connections = new ObservableCollection({key: \"connectionID\"});\n\tthis._filteredConnections = {};\n\n\tthis._updateFilteredConnections = function (typeFlag) {\n\t\tif (!this._filteredConnections[typeFlag]) {\n\t\t\tthis._filteredConnections[typeFlag] = this._connections.filterLive(function (item) {\n\t\t\t\treturn (item.getTypeFlags() & typeFlag);\n\t\t\t});\n\t\t}\n\t\treturn this._filteredConnections[typeFlag];\t\t\n\t}\n\t\n\t\n\t// When we fetch connections, we want to be able to retrieve\n\t// native phone contacts right away, without waiting for a server\n\t// response. But when we do get a server response, we want the\n\t// User objects already included in the collection to be _updated_\n\t// to match the objects returned from the server. Additionally,\n\t// connections returned from the server won't have an ID most of the\n\t// time. This means that we must key items in the _connections\n\t// collection based on some ID other than the server ID.\n\t// User.getConnectionID() computes an ID for these users based on\n\t// the native contact lookup key, if available, falling back to a\n\t// server ID and a hash of the item when needed. This should\n\t// ensure that the collection works both when connected to the\n\t// server and when offline.\n\t/**\n\t * Get a list of connections matching the given type flags.\n\t * @method getConnections\n\t * @param {number} [typeFlag] An ORed list of flags (User.ALL, etc.).\n\t * @param {function(err, ObservableCollection)} cb\n\t * @return ObservableCollection\n\t */\n\tthis.getConnections = function (typeFlag, cb) {\n\t\tif (!cb) {\n\t\t\tif (typeof typeFlag == \"function\" || typeFlag == null) {\n\t\t\t\tcb = typeFlag;\n\t\t\t\ttypeFlag = gcsocial.user.ALL;\n\t\t\t} else {\n\t\t\t\tcb = null;\n\t\t\t}\n\t\t}\n\n\t\tvar f = ff(this, function () {\n\t\t\tif (gcsocial.isNative && (typeFlag & gcsocial.user.PHONE)) {\n\t\t\t\tgcsocial._phoneConnectionsRequested = true;\n\t\t\t\tgcsocial.callNative(\"getContacts\", f());\n\t\t\t} else {\n\t\t\t\tf([]); // pass empty contact array\n\t\t\t}\n\t\t\tif (typeFlag !== gcsocial.user.PHONE) {\n\t\t\t\t// We must wait for server connections unless we're just querying\n\t\t\t\t// the phone's own contacts.\n\t\t\t\tgcsocial.ajax('GET', '/users/me/connections/', f());\n\t\t\t}\n\t\t}, function (nativeContacts, rsp) {\n\t\t\t// create users from native contacts first since the merging logic\n\t\t\t// in User.create knows how to merge server data with existing\n\t\t\t// native contact only users\n\t\t\tnativeContacts = nativeContacts.map(function (contact) {\n\t\t\t\treturn User.create({\n\t\t\t\t\tid: null,\n\t\t\t\t\tnativeContact: contact,\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tvar connections = this._shimConnections.slice();\n\t\t\tif (rsp) {\n\t\t\t\tconnections = connections.concat(rsp.items);\n\t\t\t}\n\n\t\t\tconnections = connections.map(function (item) {\n\t\t\t\treturn User.create(item);\n\t\t\t});\n\n\t\t\tnativeContacts.forEach(function (contact) {\n\t\t\t\tif (connections.indexOf(contact) === -1) {\n\t\t\t\t\tconnections.push(contact);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tthis._connections.add(connections);\n\t\t\tf(this._updateFilteredConnections(typeFlag));\n\t\t}).cb(cb);\n\n\t\treturn this._updateFilteredConnections(typeFlag);\n\t}\n\n\t/**\n\t * Finds 10 or less users who have the current game installed.\n\t * @method getRecommendations\n\t * @param {function(err, items)} cb where items = {user: ..., reasons: ...}\n\t */\n\tthis.getRecommendations = function (cb) {\n\t\tgcsocial.ajax('GET', '/users/me/recommendations/', {\n\t\t\tparams: {\n\t\t\t\tapp: gcsocial.app.getID()\n\t\t\t}\n\t\t}, function (err, response) {\n\t\t\tif (err || !response) {\n\t\t\t\tlogger.log('Error finding friends:', err);\n\t\t\t}\n\t\t\tcb && cb(err, response && response.items.map(function (item) {\n\t\t\t\titem.user = User.create(item.user);\n\t\t\t\treturn item;\n\t\t\t}));\n\t\t});\n\t}\n\n\t/**\n\t * Returns a list of missions available.\n\t * @method getMissions\n     * @param {function(err, items)} cb\n\t */\n\tthis.getMissions = function (cb) {\n\t\tgcsocial.ajax('GET', '/users/:userID/apps/:appID/missions/', {\n\t\t}, function (err, response) {\n            if (err || !response) {\n\t\t\t\tlogger.log('Error getting missions:', err);\n            }\n\t\t\tcb && cb(err, response && response.items.map(function (item) {\n\t\t\t\treturn item;\n\t\t\t}));\n\t\t});\n\t}\n\t\n\t/**\n\t * Marks a user as your friend, as returned bg getConnections(gcsocial.user.IN_NETWORK).\n\t * @method addFriend\n\t * @param {User} user\n     * @param {function(err, items)} cb\n\t */\n\tthis.addFriend = function (user, cb) {\n\t\tif (!user.getID()) {\n\t\t\treturn cb && cb(\"User is not on the network (must be just a contact)\", null);\n\t\t}\n\t\tgcsocial.ajax('PUT', '/users/me/connections/gc/' + user.getID() + '/', {\n\t\t}, function (err, response) {\n            if (err || !response) {\n\t\t\t\tlogger.log('Error adding friend:', err);\n            }\n\t\t\tcb && cb(err, response);\n\t\t});\n\t}\n\n\t/**\n\t * Removes a user from your list of friends, as returned bg getConnections(gcsocial.user.IN_NETWORK).\n\t * @method removeFriend\n\t * @param {User} user\n     * @param {function(err, items)} cb\n\t */\n\tthis.removeFriend = function (user, cb) {\n\t\tif (!user.getID()) {\n\t\t\treturn cb && cb(\"User is not on the network (must be just a contact)\", null);\n\t\t}\n\t\tgcsocial.ajax('DELETE', '/users/me/connections/gc/' + user.getID() + '/', {\n\t\t}, function (err, response) {\n            if (err || !response) {\n\t\t\t\tlogger.log('Error removing friend:', err);\n            }\n\t\t\tcb && cb(err, response);\n\t\t});\n\t}\n\n\t/**\n\t * Set the user's image (given base64 data).\n\t * @method setImage\n\t * @param {string} base64data image data in PNG format\n\t * @param {function(err)} cb\n\t */\n\tthis.setImage = function (base64data, cb) {\n\t\tgcsocial.ajax('POST', '/users/me/image/', {\n\t\t\tbody: {\n\t\t\t\tmimetype: 'image/png',\n\t\t\t\timageSource: 'manual',\n\t\t\t\tdata: base64data\n\t\t\t}\n\t\t}, function (err, response) {\n\t\t\tif (!err && response) {\n\t\t\t\tthis._update({image: response.url});\n\t\t\t\tlogger.log('Uploaded profile photo:', response.url);\n\t\t\t} else {\n\t\t\t\tlogger.log('Error uploading profile photo:', err);\n\t\t\t}\n\t\t\tcb && cb(err, response);\n\t\t}.bind(this));\n\t}\n\n\t/**\n\t * Set the user's public data. This data is readable and writable\n\t * by all users.\n\t * @method setPublicData\n\t * @param {object} opts the arbitrary game data\n\t * @param {string} [appID] the appID (optional)\n\t * @param {function(err)} cb\n\t */\n\tthis.setPublicData = function (data, appID, cb) {\n\t\tif (typeof appID != 'string') {\n\t\t\tcb = appID;\n\t\t\tappID = gcsocial.app.getID();\n\t\t}\n\t\t\n\t\tgcsocial.ajax('POST', '/users/me/apps/' + appID + '/data/', {\n\t\t\tbody: data\n\t\t}, cb);\n\t}\n\t\n\t/** \n\t * Get the private data (in server-side storage) for this user. \n\t * It is only accessible to the current user.\n\t * @method getPrivateData\n\t * @param {object} [opts]\n\t * @param {string} [opts.appID] the appID from which to retrieve data (optional)\n\t * @param {function(err, data)} cb\n\t */\n\tthis.getPrivateData = function (opts, cb) {\n\t\tif (typeof opts == \"function\") {\n\t\t\tcb = opts;\n\t\t\topts = {};\n\t\t}\n\t\tif (!opts.appID) {\n\t\t\topts.appID = gcsocial.app.getID();\n\t\t}\n\t\tgcsocial.ajax('GET', '/users/' + this._getURLID() + '/apps/' + opts.appID + '/private-data/', cb);\n\t}\n\n\t/**\n\t * Set the user's private data. This data is readable and writable\n\t * by only this user.\n\t * @method setPrivateData\n\t * @param {object} opts the arbitrary game data\n\t * @param {string} [appID] the appID (optional)\n\t * @param {function(err)} cb\n\t */\n\tthis.setPrivateData = function (data, appID, cb) {\n\t\tif (typeof appID != 'string') {\n\t\t\tcb = appID;\n\t\t\tappID = gcsocial.app.getID();\n\t\t}\n\t\t\n\t\tgcsocial.ajax('POST', '/users/me/apps/' + appID + '/private-data/', {\n\t\t\tbody: data\n\t\t}, cb);\n\t}\n\t\n\t/****************************************************************/\n\t// NOTIFICATIONS\n\t\n\t/**\n\t * Disable push notifications temporarily.\n\t * @method disableNotifications\n\t * @param {function(err)} cb\n\t */\n\tthis.disableNotifications = function (cb) {\n\t\tgcsocial.callNative(\"disableNotifications\", cb);\n\t}\n\n\t/**\n\t * Enable push notifications. Push notifications are enabled by\n\t * default, so you only need to call this if you have disabled\n\t * them previously.\n\t * @method enableNotifications\n\t * @param {function(err)} cb\n\t */\n\tthis.enableNotifications = function (cb) {\n\t\tgcsocial.callNative(\"enableNotifications\", cb);\n\t}\n\t\n\t/**\n\t * Cancel a given push notification.\n\t * @method cancelNotification\n\t * @param {number} id the ID of the notification\n\t * @param {function(err)} cb\n\t */\n\tthis.cancelNotification = function (id, cb) {\n\t\tthis._notifications.remove(id);\n\t\tfor (var i = 0; i < this._shimNotifications.length; i++) {\n\t\t\tif (this._shimNotifications[i].getID() == id) {\n\t\t\t\tthis._shimNotifications.splice(i, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tgcsocial.callNative(\"cancelNotification\", {id: id}, cb);\n\t}\n\t\n\t/**\n\t * Remove all notifications from the phone's notification center.\n\t * @method cancelAllNotifications\n\t * @param {function(err)} cb\n\t */\n\tthis.cancelAllNotifications = function (cb) {\n\t\tthis._notifications.reset(); // empty this thing\n\t\tthis._shimNotifications.length = 0;\n\t\tgcsocial.callNative(\"cancelAllNotifications\", cb);\n\t}\n\t\n\t/**\n\t * Show a notification on the phone after a given delay.\n\t * @method showLocalNotification\n\t * @param {object} opts\n\t * @param {string} opts.ticker a message to flash across the top of Android phones\n\t * @param {string} opts.title the title to show in the notification center\n\t * @param {string} opts.message the message to show in the notification center\n\t * @param {number} opts.delay the number of milliseconds to wait before display\n\t * @param {function(err, id)} cb with the push ID to be used with cancelNotification\n\t */\n\t// NOTE: delay is DIFFERENT than an absolute time!!! Change that in games.\n\tthis.showLocalNotification = function (opts, cb) {\n\t\tgcsocial.callNative(\"showLocalNotification\", {\n\t\t\tticker: opts.ticker,\n\t\t\ttitle: opts.title,\n\t\t\tmessage: opts.message,\n\t\t\tdelay: opts.delay,\n\t\t}, cb);\n\t}\n\t\n\t/**\n\t * Show a recurring notification on the phone after a given delay.\n\t * @method showRecurringLocalNotification\n\t * @param {object} opts\n\t * @param {string} opts.ticker a message to flash across the top of Android phones\n\t * @param {string} opts.title the title to show in the notification center\n\t * @param {string} opts.message the message to show in the notification center\n\t * @param {number} opts.delay the delay in milliseconds\n\t * @param {number} opts.repeatInterval the repeat interval in milliseconds (defaults to delay)\n\t * @param {function(err, id)} cb with the push ID to be used with cancelNotification\n\t */\n\t// NOTE: delay is DIFFERENT than an absolute time!!! Change that in games.\n\tthis.showRecurringLocalNotification = function (opts, cb) {\n\t\tgcsocial.callNative(\"showRecurringLocalNotification\", {\n\t\t\tticker: opts.ticker,\n\t\t\ttitle: opts.title,\n\t\t\tmessage: opts.message,\n\t\t\tdelay: opts.delay,\n\t\t\trepeatInterval: opts.repeatInterval || opts.delay,\n\t\t}, cb);\n\t}\n\t\n\t/**\n\t * Get the list of notifications you have not yet cancelled. You\n\t * should call {@link Notification.cancel} once you have handled a notification.\n\t * @method getNotifications\n\t * @return {Notification[]} array of notifications\n\t */\n\tthis.getNotifications = function (cb) {\n\t\tvar n = this._shimNotifications.slice();\n\t\tif (this._notifications.length) {\n\t\t\tn = n.concat(this._notifications);\n\t\t}\n\t\tcb && cb(null, n);\n\t\treturn n;\n\t}\n\n});\n\nexports = CurrentUser;\n\n\n\n","pre":true},"../../../social/lib/GCSocial/Notification.js":{"path":"../../../social/lib/GCSocial/Notification.js","friendlyPath":".Notification","directory":"../../../social/lib/GCSocial/","filename":"Notification.js","src":"jsio(\"import .App\");\njsio(\"import .User\");\n\n/**\n * @class Notification\n */\nvar social_lib_GCSocial_Notification=__class__;var Notification = exports=social_lib_GCSocial_Notification(function social_lib_GCSocial_Notification(){return this.init&&this.init.apply(this,arguments)},function() {\n\t\n\tthis.init = function(opts) {\n\t\tthis._opts = opts;\n\t\t// for use in the data source\n\t\tthis._uniqueID = this.getID() || (this.getCreated() + Math.random());\n\t\t\n\t\tgcsocial.user._notifications.add(this);\n\t}\n\n\t/**\n\t * @method getType\n\t * @return {\"gift\"|\"invite\"|null} the type of the notification\n\t */\n\tthis.getType = function () { return this._opts.type; }\n\t/**\n\t * @method getCreated\n\t * @return {Date}\n\t */\n\tthis.getCreated = function () { return new Date(this._opts.created); }\n\t\n\t/**\n\t * @method getApp\n\t * @return {App}\n\t */\n\tthis.getApp = function () {return App.create(this._opts.app);}\n\t\n\t/**\n\t * @method getSourceUser\n\t * @return {User|null}\n\t */\n\tthis.getSourceUser = function () { return User.create(this._opts.source); }\n\t/**\n\t * @method getData\n\t * @return {object|null}\n\t */\n\tthis.getData = function () { return this._opts.data; }\n\t/**\n\t * @method getID\n\t * @return {string|null}\n\t */\n\tthis.getID = function () { return this._opts.id; }\n\t/**\n\t * @method getVisible\n\t * @return {boolean} whether or not the notification was visible in the status bar.\n\t */\n\tthis.getVisible = function () { return this._opts.visible; }\n\n\t/**\n\t * @method toJSON\n\t * @return {object} the notification as a JSON object\n\t */\n\tthis.toJSON = function () { return this._opts; }\n\t\n\t/**\n\t * Remove this notification from the status bar.\n\t * @method cancel\n\t */\n\tthis.cancel = function() {\n\t\tgcsocial.user._notifications.remove(this._uniqueID);\n\t\tif (this.getID() != null) {\n\t\t\tgcsocial.user.cancelNotification(this.getID());\n\t\t}\n\t}\n});\n","pre":true},"../../../social/lib/GCSocial/internal/CrossDomainLocalStorage.js":{"path":"../../../social/lib/GCSocial/internal/CrossDomainLocalStorage.js","friendlyPath":".internal.CrossDomainLocalStorage","directory":"../../../social/lib/GCSocial/internal/","filename":"CrossDomainLocalStorage.js","src":"jsio(\"import ..node.ff as ff\");\n\n/**\n * The session frame exposes a cross-domain key-value store.\n */\nvar social_lib_GCSocial_internal_CrossDomainLocalStorage=__class__;var CrossDomainLocalStorage = exports=social_lib_GCSocial_internal_CrossDomainLocalStorage(function social_lib_GCSocial_internal_CrossDomainLocalStorage(){return this.init&&this.init.apply(this,arguments)},function () {\n\t\n\tvar FRAME_LOAD_TIMEOUT = 5000; // time for remote iframe to load\n\tvar MESSAGE_TIMEOUT = 100; // time for remote page to reply\n\t\n\tthis.init = function(endpoint) {\n\t\t// Append an iframe for the session frame.\n\t\tthis._withFrame = ff.defer(this);\n\t\t\n\t\tthis._withFrame.timeout(5000);\n\t\t\n\t\t// sometimes it won't work, so fail gracefully.\n\t\tthis.forceLocalStorage = false;\n\t\t\n\t\tif (!(window.document && document.createElement && document.body)) {\n\t\t\tconsole.log(\"On native, forcing localStorage.\");\n\t\t\tthis.forceLocalStorage = true;\n\t\t} else {\n\t\t\tthis._frame = document.createElement('iframe');\n\t\t\tthis._frame.style.cssText = \"position: absolute; top: -10px; left: -10px; \" +\n\t\t\t\t\"width: 1px; height: 1px; border: none; visibility: hidden;\";\n\t\t\tthis._frame.src = endpoint;\n\t\t\tdocument.body.appendChild(this._frame);\n\n\t\t\tthis._frame.onload = this._withFrame;\n\t\t\t\n\t\t\tthis.waitingResponses = {}; // dict of id -> callback\n\t\t\tthis._id = 0; // id for cross-domain communication\n\t\t\t\n\t\t\twindow.addEventListener('message', function (evt) {\n\t\t\t\t// ignore any messages we cant parse\n\t\t\t\tif (!evt.data || evt.data[0] != \"{\" || ! evt.data[evt.data.length-1] != \"}\") {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tvar data = JSON.parse(evt.data || \"{}\") || {};\n\t\t\t\t} catch (e) {\n\t\t\t\t\treturn; // it may have been destined for another handler\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (data.version == 1 && data.id != null) {\n\t\t\t\t\t// handle the return value of a function call\n\t\t\t\t\tvar defer = this.waitingResponses[data.id];\n\t\t\t\t\tdelete this.waitingResponses[data.id];\n\t\t\t\t\tdefer && defer(data.value);\n\t\t\t\t}\n\t\t\t}.bind(this), false);\n\t\t}\n\t}\n\t\n\tthis.call = function(method, args, callback) {\n\t\tif (this.forceLocalStorage) {\n\t\t\tvar value = localStorage[method].apply(localStorage, args);\n\t\t\tcallback && callback(null, value);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tvar cb = function (err, value) {\n\t\t\tif (err) {\n\t\t\t\tif (!this.forceLocalStorage) {\n\t\t\t\t\tthis.forceLocalStorage = true;\n\t\t\t\t\tconsole.log(\"Cross-domain localStorage forceLocalStorage. Using localStorage.\");\n\t\t\t\t}\n\t\t\t\tvalue = localStorage[method].apply(localStorage, args);\n\t\t\t}\n\t\t\tcallback && callback(null, value);\n\t\t}.bind(this);\n\t\t\n\t\tvar id = ++this._id;\n\t\tthis._withFrame\n\t\t\t.success(function() {\n\t\t\t\tthis.waitingResponses[id] = ff.defer().timeout(MESSAGE_TIMEOUT).cb(cb);\n\t\t\t\tthis._frame.contentWindow.postMessage(JSON.stringify({\n\t\t\t\t\tversion: 1,\n\t\t\t\t\tid: id,\n\t\t\t\t\tmethod: method,\n\t\t\t\t\targs: args,\n\t\t\t\t}), '*');\n\t\t\t})\n\t\t\t.error(function(err) {\n\t\t\t\tdelete this.waitingResponses[id];\n\t\t\t\tcb(err);\n\t\t\t});\n\t}\n\t\n\tthis.getItem = function(key, cb) {\n\t\tthis.call('getItem', [key], function (err, item) {\n\t\t\ttry {\n\t\t\t\titem = JSON.parse(item);\n\t\t\t} catch (e) {\n\t\t\t}\n\t\t\tcb(err, item);\n\t\t});\n\t}\n\t\n\tthis.setItem = function(key, value, cb) {\n\t\tthis.call('setItem', [key, JSON.stringify(value)], cb);\n\t}\n\t\n\tthis.removeItem = function(key, cb) {\n\t\tthis.call('removeItem', [key], cb);\n\t}\n});\n","pre":true},"../../../social/lib/GCSocial/internal/tracker.js":{"path":"../../../social/lib/GCSocial/internal/tracker.js","friendlyPath":".internal.tracker","directory":"../../../social/lib/GCSocial/internal/","filename":"tracker.js","src":"\"use import\";\n\njsio(\"import util.ajax\");\njsio(\"import std.uuid\");\njsio(\"import lib.Callback\");\njsio(\"import std.base64\");\njsio(\"import .mixpanel\");\n\nvar isNative = /TeaLeaf/.test(navigator.userAgent);\n\nexports = new (Class(function() {\n\t\n\tvar MAX_EVENTS_TO_QUEUE = 1000;\n\tvar SEND_INTERVAL = 10000;\n\tvar LOCAL_STORAGE_KEY = 'pendingTrackingData';\n\t\n\tthis.init = function() {\n\t\tthis.deviceID = null;\n\t}\n\n\t/**\n\t * Initializes the tracker so that it can begin sending events.\n\t * @method initialize\n\t * @param {GCSocial} gcsocial\n\t */\n\tthis.initialize = function (gcsocial) {\n\t\t// Send a device information event when ready\n\t\tvar nativeInfo = GLOBAL.NATIVE && NATIVE.device && NATIVE.device.info || {};\n\n\t\tthis.track(\"device\", {\n\t\t\t\"version\": window.CONFIG && window.CONFIG.version,\n\t\t\t\"appID\": gcsocial.app.getID(),\n\t\t\t\"userAgent\": navigator.userAgent,\n\t\t\t\"timezone\": (new Date().getTimezoneOffset()),\n\t\t\t\"deviceModel\": nativeInfo.model,\n\t\t\t\"deviceProduct\": nativeInfo.product,\n\t\t});\n\n\t\t// When we've retrieved the deviceID, start tracking.\n\t\tgcsocial.getDeviceID(function (err, deviceID) {\n\t\t\tthis.deviceID = deviceID;\n\t\t\tthis.flush();\n\t\t}.bind(this));\n\t}\n\t\n\t/**\n\t * Tracks an event given a name and optional data map. The event\n\t * will be sent to the server sometime in the future when possible.\n\t * @method track\n\t * @param {string} name the name of the event\n\t * @param {object|null} [data] an optional map of {string->string} pairs\n\t * @param {object|null} [options]\n\t * @param {string} [options.deviceID] the unique ID to be used for tracking (assumes user's deviceID by default; only available for third-party services)\n\t */\n\tthis.track = function (name, data, options, cb) {\n\t\tif (typeof name !== \"string\") {\n\t\t\tthrow new Error(\"The 'name' parameter to gcsocial.track() must be a string.\");\n\t\t}\n\t\tif (data && (isArray(data) || typeof data === \"string\" || typeof data === \"number\")) {\n\t\t\tthrow new Error(\"The 'data' parameter to gcsocial.track() must be an object or null.\");\n\t\t}\n\n\t\toptions = options || {};\n\t\t\n\t\tvar event = {\n\t\t\ttimestamp: +new Date(),\n\t\t\tname: name,\n\t\t\tdata: data\n\t\t};\n\n\t\tgcsocial.getDeviceID(function (err, deviceID) {\n\t\t\t// check for deviceID override\n\t\t\tdeviceID = options.deviceID || deviceID;\n\n\t\t\tif (!isNative) {\n\t\t\t\t// for webflow, only track mixpanel for now\n\t\t\t\tif (window.CONFIG && window.CONFIG.mpMetricsKey) {\n\t\t\t\t\tmixpanel.track(event, deviceID, cb);\n\t\t\t\t} else {\n\t\t\t\t\tcb && cb();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgcsocial.callNative(\"track\", {\n\t\t\t\t\tevent: event,\n\t\t\t\t\tdeviceID: deviceID,\n\t\t\t\t});\n\t\t\t\tcb && cb();\n\t\t\t}\n\t\t}.bind(this));\n\n\t\tthis.enqueue(event);\n\t}\n\t\n\t/**\n\t * Pushes an item or array of items on to the queue of events to send.\n\t * @method enqueue\n\t */\n\tthis.enqueue = function(items) {\n\t\tif (!isArray(items)) { items = [items]; }\n\t\tvar pendingData = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '[]');\n\t\tlocalStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(pendingData.concat(items)));\n\t}\n\n\t/**\n\t * Inserts the item or array of items at the beginning of the queue to send.\n\t * @method unshift\n\t */\n\tthis.unshift = function(items) {\n\t\tif (!isArray(items)) { items = [items]; }\n\t\tvar pendingData = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '[]');\n\t\tlocalStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(items.concat(pendingData)));\n\t}\n\n\t/**\n\t * Sends all pending events to the server. If the number of\n\t * pending events is greater than MAX_EVENTS_TO_QUEUE, older\n\t * messages are discarded. That should rarely, if ever, happen.\n\t * @method flush\n\t */\n\tthis.flush = function() {\n\t\tclearTimeout(this._flushTimeout);\n\t\tthis._flushTimeout = setTimeout(bind(this, 'flush'), SEND_INTERVAL);\n\t\tif (this._sending) { return; } // don't send multiple requests simultaneously\n\n\t\tvar pendingData = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '[]');\n\n\t\tif (pendingData.length) {\n\t\t\t\n\t\t\t// If we have too many events pending, discard the oldest ones. We don't want\n\t\t\t// to overflow their disk or anything terrible like that.\n\t\t\tif (pendingData.length > MAX_EVENTS_TO_QUEUE) {\n\t\t\t\tpendingData = pendingData.slice(pendingData.length - MAX_EVENTS_TO_QUEUE);\n\t\t\t}\n\t\t\t\n\t\t\ttry {\n\t\t\t\tlocalStorage.removeItem(LOCAL_STORAGE_KEY);\n\n\t\t\t\tthis._sending = true;\n\t\t\t\tgcsocial.ajax(\"POST\", \"/logs/\", {\n\t\t\t\t\tbody: JSON.stringify(pendingData),\n\t\t\t\t\tparams: {\n\t\t\t\t\t\tdevice: this.deviceID\n\t\t\t\t\t}\n\t\t\t\t}, bind(this, function(err, response) {\n\t\t\t\t\tthis._sending = false;\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\t// If there was a problem sending the logs, try again later.\n\t\t\t\t\t\tthis.unshift(pendingData); // put them at the beginning\n\t\t\t\t\t}\n\t\t\t\t}));\n\t\t\t} catch(e) {\n\t\t\t\tlogger.error(\"Error sending data:\", e);\n\t\t\t}\n\t\t}\n\t}\n\n}))();\n","pre":true},"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/util/ajax.js":{"path":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/util/ajax.js","friendlyPath":"util.ajax","directory":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/util/","filename":"ajax.js","src":"jsio(\"import std.uri as URI\");\n\nvar SIMULTANEOUS = 4;\nvar _inflight = 0;\n\nvar doc;\nexports.getDoc = function() {\n\tif (doc) { return doc; }\n\ttry {\n\t\tdoc = window.ActiveXObject && new ActiveXObject('htmlfile');\n\t\tif (doc) {\n\t\t\tdoc.open().write('<html></html>');\n\t\t\tdoc.close();\n\t\t\twindow.attachEvent('onunload', function() {\n\t\t\t\ttry { doc.body.innerHTML = ''; } catch(e) {}\n\t\t\t\tdoc = null;\n\t\t\t});\n\t\t}\n\t} catch(e) {}\n\t\n\tif (!doc) { doc = document; }\n\treturn doc;\n};\n\nvar ctor = function() {\n\tvar win = window,\n\t\tdoc = exports.getDoc();\n\t//if (doc.parentWindow) { win = doc.parentWindow; }\n\t\n\treturn new (ctor = win.XMLHttpRequest ? win.XMLHttpRequest\n\t\t: function() { return win.ActiveXObject && new win.ActiveXObject('Msxml2.XMLHTTP') || null; });\n};\n\nexports.createXHR = function() { return new ctor(); }\n\nexports.post = function(opts, cb) {\n\treturn exports.get(merge({method: 'POST'}, opts), cb);\n}\n\nRequest=__class__;var Request=Request(function Request(){return this.init&&this.init.apply(this,arguments)},function() {\n\tvar _UID = 0;\n\t\n\tthis.init = function(opts, cb) {\n\t\tif (!opts || !opts.url) { logger.error('no url provided'); return; }\n\t\t\n\t\tthis.method = (opts.method || 'GET').toUpperCase();\n\t\tthis.url = opts.url;\n\t\tthis.type = opts.type;\n\t\tthis.async = opts.async;\n\t\tthis.timeout = opts.timeout;\n\t\tthis.id = ++_UID;\n\t\tthis.headers = {};\n\t\tthis.cb = cb;\n\t\t\n\t\tif (opts.headers) {\n\t\t\tfor (var key in opts.headers) if (opts.headers.hasOwnProperty(key)) {\n\t\t\t\tvar value = opts.headers[key];\n\t\t\t\tthis.headers[key] = value;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar isObject = opts.data && typeof opts.data == 'object';\n\t\t\n\t\tif (this.method == 'GET' && opts.data) {\n\t\t\tthis.url = new URI(this.url).addQuery(isObject ? opts.data : URI.parseQuery(opts.data)).toString();\n\t\t}\n\t\t\n\t\ttry {\n\t\t\tthis.data = (this.method != 'GET' ? (isObject ? JSON.stringify(opts.data) : opts.data) : null);\n\t\t} catch(e) {\n\t\t\tcb && cb({invalidData: true}, null, '');\n\t\t\treturn;\n\t\t}\n\t}\n});\n\nvar _pending = [];\n\nexports.get = function(opts, cb) {\n\tvar request = new Request(opts, cb);\n\t\n\tif (_inflight >= SIMULTANEOUS) {\n\t\t_pending.push(request);\n\t} else {\n\t\t_send(request);\n\t}\n}\n\nfunction _sendNext() {\n\t//logger.log('====INFLIGHT', _inflight, SIMULTANEOUS, 'might send next?');\n\tif (_inflight < SIMULTANEOUS) {\n\t\tvar request = _pending.shift();\n\t\tif (request) {\n\t\t\t_send(request);\n\t\t}\n\t}\n}\n\nfunction _send(request) {\n\t++_inflight;\n\t//logger.log('====INFLIGHT', _inflight, 'sending request', request.id);\n\t\n\tvar xhr = exports.createXHR();\n\txhr.open(request.method, request.url, !(request.async == false));\n\tvar setContentType = false;\n\tfor (var key in request.headers) {\n\t\tif (key.toLowerCase() == 'content-type') { setContentType = true; }\n\t\txhr.setRequestHeader(key, request.headers[key]);\n\t}\n\n\tif (!setContentType) {\n\t\txhr.setRequestHeader('Content-Type', 'text/plain');\n\t}\n\t\n\txhr.onreadystatechange = bind(this, onReadyStateChange, request, xhr);\n\tif (request.timeout) {\n\t\trequest.timeoutRef = setTimeout(bind(this, cancel, xhr, request), request.timeout);\n\t\t//logger.log('==== setting timeout for', request.timeout, request.timeoutRef, '<<');\n\t}\n\t\n\trequest.ts = +new Date();\n\txhr.send(request.data || null);\n}\n\nfunction cancel(xhr, request) {\n\t--_inflight;\n\t// logger.log('====INFLIGHT', _inflight, 'timeout (cancelled)', request.id);\n\tif (request.timedOut) {\n\t\tlogger.log('already timed out?!');\n\t}\n\t\n\txhr.onreadystatechange = null;\n\trequest.timedOut = true;\n\tif (xhr.readyState >= xhr.HEADERS_RECEIVED) {\n\t\ttry {\n\t\t\tvar headers = xhr.getAllResponseHeaders();\n\t\t} catch (e) {}\n\t}\n\t\n\trequest.cb && request.cb({timeout: true}, null, headers);\n}\n\nfunction onReadyStateChange(request, xhr) {\n\tif (xhr.readyState != 4) { return; }\n\t\n\tif (request.timedOut) { throw 'Unexpected?!'; }\n\t\n\t--_inflight;\n\t\n\t// logger.log('====INFLIGHT', _inflight, 'received response', request.ts, request.id, (+new Date() - request.ts) / 1000);\n\tsetTimeout(_sendNext, 0);\n\t\n\tvar cb = request.cb;\n\tif ('timeoutRef' in request) {\n\t\t// logger.log('==== AJAX CLEARING TIMEOUT', request.id);\n\t\tclearTimeout(request.timeoutRef);\n\t\trequest.timeoutRef = null;\n\t}\n\t\n\t// only fire callback once\n\tif (!cb || request.handled) { return; }\n\trequest.handled = true;\n\t\n\t// .status will be 0 when requests are filled via app cache on at least iOS 4.x\n\tif (xhr.status != 200 && xhr.status != 0) {\n\t\tvar response = xhr.response;\n\t\tif (xhr.getResponseHeader('Content-Type') == 'application/json') {\n\t\t\ttry {\n\t\t\t\tresponse = JSON.parse(response);\n\t\t\t} catch(e) {\n\t\t\t}\n\t\t}\n\t\tcb({status: xhr.status, response: response}, null, xhr.getAllResponseHeaders());\n\t} else {\n\t\tvar data = xhr.responseText;\n\t\tif (request.type == 'json') {\n\t\t\tif (!data) {\n\t\t\t\tcb({status: xhr.status, response: xhr.response}, null, xhr.getAllResponseHeaders());\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tdata = JSON.parse(data);\n\t\t\t\t} catch(e) {\n\t\t\t\t\tcb({status: xhr.status, response: xhr.response, parseError: true}, null, xhr.getAllResponseHeaders());\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcb(null, data, xhr.getAllResponseHeaders());\n\t}\n}\n","pre":true},"../../../social/lib/GCSocial/internal/mixpanel.js":{"path":"../../../social/lib/GCSocial/internal/mixpanel.js","friendlyPath":".mixpanel","directory":"../../../social/lib/GCSocial/internal/","filename":"mixpanel.js","src":"jsio(\"import util.ajax\");\njsio(\"import std.uuid\");\n\n// base64 encoding from and for Mixpanel\nfunction base64Encode(data) {\n    var b64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n    var o1, o2, o3, h1, h2, h3, h4, bits, i = 0, ac = 0, enc=\"\", tmp_arr = [];\n\n    if (!data) {\n        return data;\n    }\n\n\t// convert data to utf-8 via http://ecmanaut.blogspot.com/2006/07/encoding-decoding-utf8-in-javascript.html\n\tdata = unescape( encodeURIComponent( data ) );\n\n    do { // pack three octets into four hexets\n        o1 = data.charCodeAt(i++);\n        o2 = data.charCodeAt(i++);\n        o3 = data.charCodeAt(i++);\n\n        bits = o1<<16 | o2<<8 | o3;\n\n        h1 = bits>>18 & 0x3f;\n        h2 = bits>>12 & 0x3f;\n        h3 = bits>>6 & 0x3f;\n        h4 = bits & 0x3f;\n\n        // use hexets to index into b64, and append result to encoded string\n        tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);\n    } while (i < data.length);\n\n    enc = tmp_arr.join('');\n\n    switch( data.length % 3 ){\n    case 1:\n        enc = enc.slice(0, -2) + '==';\n        break;\n    case 2:\n        enc = enc.slice(0, -1) + '=';\n        break;\n    }\n\n    return enc;\n};\n\n\nexports.track = function (event, deviceID, cb) {\n\t// extract the important bits\n\tvar name = event.name;\n\tvar data = event.data;\n\tvar timestamp = event.timestamp;\n\t\n\tdata.token = window.CONFIG.mpMetricsKey;\n\tdata.time = timestamp / 1000 | 0;\n\tdata.distinct_id = deviceID;\n\t\n\tvar jsonData = JSON.stringify({\n\t\tevent: name,\n\t\tproperties: data\n\t});\n\n\tvar query = {\n\t\t'data': base64Encode(jsonData),\n\t\t'ip': 1,\n\t\t'_': new Date().getTime().toString()\n\t};\n\n\tvar queryArray = [];\n\tfor(var key in query) {\n\t\tvar encodedKey = encodeURIComponent(key);\n\t\tvar encodedVal = encodeURIComponent(query[key]);\n\n\t\tqueryArray[queryArray.length] = encodedKey + '=' + encodedVal;\n\t}\n\tvar queryString = queryArray.join('&');\n\n\tvar mixpanelEndpoint = \"http://api.mixpanel.com/track/?\" + queryString;\n\tlogger.log(\"track - starting mixpanel send event [\" + name + \n\t\t\t   \"] to: \" + mixpanelEndpoint + \" data: \" + jsonData);\n\n\tutil.ajax.get({\n\t\turl: mixpanelEndpoint,\n\t\tasync: true,\n\t\ttimeout: 5000,\n\t}, function(err, response) {\n\t\t// nothing to do.\n\t\tlogger.log(\"track - finished mixpanel send event [\" + name + \n\t\t\t\t   \"] response: \" + response);\n\t\tcb && cb(err, response);\n\t});\n}","pre":true},"../../../social/lib/GCSocial/internal/connection.js":{"path":"../../../social/lib/GCSocial/internal/connection.js","friendlyPath":".internal.connection","directory":"../../../social/lib/GCSocial/internal/","filename":"connection.js","src":"jsio(\"import lib.PubSub\");\n\njsio(\"import ..node.ff as ff\");\n\n/**\n * Maintains an accurate online/offline/connecting status for mobile\n * devices. The phone may report \"online\" even if the API server\n * cannot be reached.\n */\nvar social_lib_GCSocial_internal_connection=__class__;var Connection = exports=social_lib_GCSocial_internal_connection(function social_lib_GCSocial_internal_connection(){return this.init&&this.init.apply(this,arguments)},lib.PubSub, function (supr) {\n\n\tvar OFFLINE = \"offline\";\n\tvar CONNECTING = \"connecting\";\n\tvar ONLINE = \"online\";\n\t\n\tvar RECONNECT_INTERVAL_ON_UNREACHABLE = 2000;   // the phone is probably offline\n\tvar RECONNECT_INTERVAL_ON_SERVER_ERROR = 30000; // let the server heal\n\t\n\tthis.init = function () {\n\t\tsupr(this, 'init', arguments);\n\t\tthis._state = OFFLINE;\n\t\tthis._reconnectTimer = null;\n\t\t\n\t\twindow.addEventListener('online', function() {\n\t\t\tlogger.log(\"(online event)\");\n\t\t\tthis.connect();\n\t\t}.bind(this), false);\n\n\t\twindow.addEventListener('offline', function () {\n\t\t\tlogger.log(\"(offline event)\");\n\t\t\tthis.disconnect();\n\t\t}.bind(this), false);\n\t\t\n\t\tgcsocial.on('success', this.onXHRSuccess.bind(this));\n\t\tgcsocial.on('error', this.onXHRError.bind(this));\n\n\t\tif (window.onLine) {\n\t\t\tthis.connect();\n\t\t}\n\t\t\n\t\tthis.on('change', function (newState, oldState) {\n\t\t\tconsole.log(\"Connection.state:\", newState, \"[ was\", oldState, \"]\");\n\t\t});\n\t}\n\t\n\tthis.connect = function () {\n\t\tthis._reconnectTimer = null;\n\t\tif (this._state == ONLINE) { return; }\n\t\t\n\t\tthis.setState(CONNECTING);\n\n\t\tvar f = ff(this, function() {\n\t\t\tgcsocial.ajax(\"GET\", \"/\", f());\n\t\t}).success(function () {\n\t\t\tthis.setState(ONLINE);\n\t\t}).error(function(){\n\t\t\t// go unhandled\n\t\t});\n\t}\n\t\n\tthis.disconnect = function () {\n\t\tthis.setState(OFFLINE);\n\t}\n\t\n\tthis.getState = function () {\n\t\t\n\t}\n\t\n\tthis.setState = function (state) {\n\t\tvar oldState = this._state;\n\t\tthis._state = state;\n\t\tif (oldState != state) {\n\t\t\tthis.emit('change', state, oldState);\n\t\t}\n\t}\n\n\t// called on every successful request\n\tthis.onXHRSuccess = function (reqOpts, res) {\n\t\tthis.setState(ONLINE);\n\t}\n\t\n\t// called when an XHR fails\n\tthis.onXHRError = function (xhr) {\n\t\tvar status = 0;\n\t\ttry {\n\t\t\tstatus = xhr.status; // throws if not in a valid state (timeout)\n\t\t} catch (e) {\n\t\t}\n\t\t\t\t\t\t\t \n\t\tif (status == 0 && this._state != CONNECTING) {\n\t\t\tconsole.log(\"Connection failed with error \" + status + \".\");\n\t\t\tthis._state = CONNECTING;\n\t\t\tif (!this._reconnectTimer) {\n\t\t\t\tthis._reconnectTimer = setTimeout(this.connect.bind(this), \n\t\t\t\t\t\t\t\t\t\t\t\t  status >= 500 ? \n\t\t\t\t\t\t\t\t\t\t\t\t  RECONNECT_INTERVAL_ON_SERVER_ERROR :\n\t\t\t\t\t\t\t\t\t\t\t\t  RECONNECT_INTERVAL_ON_UNREACHABLE);\n\t\t\t}\n\t\t}\n\t}\n\t\n});\n","pre":true},"../../../social/lib/GCSocial/internal/generator.js":{"path":"../../../social/lib/GCSocial/internal/generator.js","friendlyPath":".internal.generator","directory":"../../../social/lib/GCSocial/internal/","filename":"generator.js","src":"var creatures = [\"urchin\", \"cucumber\", \"dolphin\", \"shark\", \"whale\", \"otter\", \"starfish\", \"coral\", \"eel\", \"goldfish\", \"manatee\", \"salmon\", \"trout\", \"bass\", \"halibut\", \"clam\", \"oyster\", \"shrimp\", \"tuna\", \"plankton\", \"seaweed\", \"algae\", \"ocotopus\", \"squid\", \"mantaray\", \"stingray\", \"walrus\"];\n\nvar adjectives = [\"fuming\", \"melancholy\", \"scheming\", \"hyper\", \"happy\", \"sad\", \"confused\", \"wired\", \"engergized\", \"smug\", \"cool\", \"sleepy\", \"party\", \"sick\", \"down-to-earth\", \"droopy-eyed\", \"dopey\", \"mopey\", \"desperate\", \"envious\", \"somber\", \"panicked\", \"alarmed\", \"impatient\", \"tense\", \"jealous\", \"irate\", \"jealous\", \"warped\", \"zealous\", \"livid\", 'undersized', 'prismatic', 'uppity', 'polygot', 'renascent', 'nonliving', 'contrapuntal', 'demonstrable', 'sanguine', 'raspiest', 'cracklier', 'presumptive', 'standoffish', 'wartier', 'nethermost', 'upstream', 'placating', 'localized', 'specked', 'aluminum', 'singled', 'ingested', 'ostensible', 'seventeen', 'bonded', 'quantitative', 'lettered', 'pickled', 'stolid', 'dignifying', 'marred'];\n\nvar colors = [\"red\", \"green\", \"orange\", \"blue\", \"rainbow\", \"yellow\", \"white\", \"zebra\", \"chartreuse\", \"magenta\", \"turqouise\", \"cyan\", \"steel\", \"forest\"];\n\nvar nouns = ['option', 'numeracy', 'freeloading', 'minivan', 'wastepaper', 'junketeer', 'harmlessness', 'actuator', 'carnelian', 'perfectionism', 'sleepwalker', 'brewer', 'cadmium', 'reformist', 'condemner', 'metalworking', 'growler', 'honorer', 'campanologist', 'overcoat', 'knob', 'abrasive', 'pebbling', 'perennial', 'logger', 'landslide', 'housework', 'nightfall', 'tricycle', 'tameness'];\n\nexports.pick = function() {\n\tvar list = Array.prototype.concat.apply(arguments[0], Array.prototype.slice.call(arguments, 1));\n\treturn list[Math.random() * list.length | 0];\n}\n\nexports.gameName = function() {\n\treturn exports.pick(adjectives) + ' ' + exports.pick(nouns);\n}\n\nexports.username = function() {\n\treturn exports.pick(adjectives) + ' ' + exports.pick(creatures);\n}\n\nexports.name = function() {\n\treturn exports.pick(nouns, creatures);\n}\n\nfunction merge() { return Array.prototype.concat.apply(arguments[0], Array.prototype.slice.call(arguments, 1)); }\n\nexports.tautogram = function() {\n\twhile (true) {\n\t\tvar name = exports.name(),\n\t\t\tletter = name.charAt(0),\n\t\t\ta = merge(adjectives, colors).filter(function(a) { return a.charAt(0) == letter; });\n\t\tif (a.length) {\n\t\t\treturn exports.pick(a) + ' ' + name;\n\t\t}\n\t}\n}\n","pre":true},"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/math/array.js":{"path":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/math/array.js","friendlyPath":"math.array","directory":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/math/","filename":"array.js","src":"jsio('import math.util as util');\n\n/**\n * @package math.array;\n *\n * Functions to manipulate one or more arrays in tandem.\n */\n\n/**\n * Returns the weighted average\n */ \n\nexports.weightedAverage = function (a, w, n) {\n\tn = n || a.length;\n\tvar s = 0;\n\tfor (var i = n - 1; i >= 0; --i) {\n\t\ts += a[i] * w;\n\t}\n\treturn s / n;\n}\n\n/**\n * Subtract two arrays, (a - b)\n */\n\nexports.subtract = function (a, b) {\n\tvar length = a.length,\n\t\t\tdiff = new Array(length);\n\tfor (var i = 0; i < length; ++i) {\n\t\tdiff[i] = a[i] - b[i];\n\t}\n\treturn diff;\n};\n\n/**\n * Average an array.\n */\n\nexports.average = function (a, n) {\n\tn = n || a.length;\n\tvar s = 0;\n\tfor (var i = n - 1; i >= 0; --i) {\n\t\ts += a[i];\n\t}\n\treturn s / n;\n}\n\n/**\n * Return the standard deviation of an array.\n */\n\nexports.stddev = function (a, n) {\n\tvar avg = exports.average(a, n);\n\tn = n || a.length;\n\tvar s = 0;\n\tfor (var i = n - 1; i >= 0; --i) {\n\t\tvar diff = (a[i] - avg);\n\t\ts += diff * diff;\n\t}\n\treturn Math.sqrt(s / (n - 1));\n}\n\n/**\n * Shuffle an array. Takes an optional random seed.\n */\n\nexports.shuffle = function(a, randGen) {\n\tvar len = a.length;\n\tfor (var i = 0; i < len; ++i) {\n\t\tvar j = util.random(i, len, randGen),\n\t\t\ttemp = a[j];\n\t\ta[j] = a[i];\n\t\ta[i] = temp;\n\t}\n\treturn a;\n}\n\n/**\n * Rotate an array's elements left.\n */\n\nexports.rotate = function(a, count) {\n\tvar len = a.length,\n\t\tb = new Array(len),\n\t\tj = count % len;\n\t\n\tif (j < 0) {\n\t\tj = j % len;\n\t\tif (j) { j += len; }\n\t}\n\t\n\tfor (var i = 0; i < len; ++i) {\n\t\tb[i] = a[j];\n\t\tj = (j + 1) % len;\n\t}\n\t\n\treturn b;\n}\n","pre":true},"../../../../sdk/_api/client/Application.js":{"path":"../../../../sdk/_api/client/Application.js","friendlyPath":".Application","directory":"../../../../sdk/_api/client/","filename":"Application.js","src":"jsio(\"import device\");\n\nif (device.simulatingMobileNative) {\n\tGC.isNative = true;\n\tvar nativeShim = 'import .nativeShim';\n\tjsio(nativeShim);\n}\n\njsio(\"import ui.StackView\");\njsio(\"import ui.Engine\");\njsio(\"import lib.PubSub\");\njsio(\"import lib.Callback\");\n\n\nvar sdk__api_client_Application=__class__;exports=sdk__api_client_Application(function sdk__api_client_Application(){return this.init&&this.init.apply(this,arguments)},ui.StackView, function (supr) {\n\tthis._settings = {};\n\t\n\tthis.constructor.start = function (app, entry) {\n\t\tentry = entry || 'launchUI';\n\n\t\tapp.run();\n\t\tapp.initUI();\n\n\t\tvar settings = app.getSettings();\n\t\tvar preload = settings.preload;\n\t\tvar autoHide = CONFIG.preload && (CONFIG.preload.autoHide !== false);\n\t\tif (preload && preload.length) {\n\t\t\tvar cb = new lib.Callback();\n\t\t\tfor (var i = 0, group; group = preload[i]; ++i) {\n\t\t\t\tGC.resources.preload(group, cb.chain());\n\t\t\t}\n\t\t\t\n\t\t\t// note that hidePreloader takes a null cb argument to avoid\n\t\t\t// forwarding the preloader result as the callback\n\t\t\tif (autoHide) { cb.run(GC, 'hidePreloader', null); }\n\t\t\tcb.run(app, entry);\n\t\t} else {\n\t\t\tif (autoHide) { GC.hidePreloader(); }\n\t\t\tapp[entry]();\n\t\t}\n\t};\n\n\tthis.getSettings = function () { return this._settings; }\n\n\tthis.init = function (opts) {\n\t\tsupr(this, 'init');\n\n\t\tvar settings = this._settings;\n\n\t\tif (!settings.noTimestep) {\n\t\t\tthis.engine = new ui.Engine(merge(opts, {view: this}));\n\t\t\tthis.view = this;\n\t\t}\n\t}\n\t\n\t// user override these methods:\n\tthis.initUI = \n\tthis.launchSinglePlayerGame = \n\tthis.launchMultiPlayerGame = \n\t\tfunction() {}\n\t\n\tthis.launchUI = function() {\n\t\tif (GC.isNative) {\n\t\t\tthis.launchNative && this.launchNative();\n\t\t} else {\n\t\t\tthis.launchBrowser && this.launchBrowser();\n\t\t}\n\t}\n\t\n\tthis.getCanvas = function() { return this.engine.getCanvas(); }\n\t\n\tthis.run = function() {\n\t\tthis.engine.show();\n\t\tthis.engine.startLoop();\n\t}\n\t\n\tthis.onPause = this.onResume = function() {}\n});\n\n\n/*`\n\tthis.getDocument = function() { return this._doc; }\n\t\n\tvar baseImageViews = {};\n\tthis.showImage = function(img, opts) {\n\t\topts = JS.merge(opts);\n\n\t\tvar view = baseImageViews[img];\n\t\tif (!view) {\n\t\t\tview = baseImageViews[img] = new ui.ImageView({image: img, autoSize: true});\n\t\t\tview.style.opacity = 0;\n\t\t}\n\n\t\tview.doOnLoad(this, function() {\n\t\t\tvar mainView = this.getApp().getView();\n\t\t\tview.setStyle({\n\t\t\t\tx: (mainView.style.width - view.style.width) / 2,\n\t\t\t\ty: (mainView.style.height - view.style.height) / 2,\n\t\t\t\tzIndex: -1\n\t\t\t});\n\n\t\t\tmainView.addSubview(view);\n\t\t\tAnimate(view).then({opacity: 'opacity' in opts ? opts.opacity : 1});\n\t\t});\n\t}\n\n\tthis.hideImage = function(img) {\n\t\tvar view = baseImageViews[img];\n\t\tif (view) {\n\t\t\tAnimate(view).then({opacity: 0}).then(bind(view, 'removeFromSuperview'));\n\t\t}\n\t}\n\t\n\tthis.addBackgroundImage = function(url) {\n\t\tjsio(\"import ui.ImageView\");\n\t\t\n\t\tvar view = new ui.ImageView({\n\t\t\tzIndex: -999,\n\t\t\timage: url,\n\t\t\tautoSize: true\n\t\t});\n\n\t\tapp.getView().addSubview(view);\n\n\t\treturn view;\n\t}\n});\n\n*/\n","pre":true},"../../../../sdk/_api/client/UI.js":{"path":"../../../../sdk/_api/client/UI.js","friendlyPath":"_api.client.UI","directory":"../../../../sdk/_api/client/","filename":"UI.js","src":"jsio(\"from util.browser import $\");\njsio(\"import std.uri\");\njsio(\"import std.js as JS\");\njsio(\"import lib.Iterator\");\njsio(\"import lib.Callback\");\njsio(\"import device\");\njsio(\"import ui.widget.Spinner as Spinner\"); \n\nvar config = window.CONFIG;\n\nlogger.log(\"ITS \", GLOBAL.HTMLCanvasElement);\nvar uiExports = {\n\tGCView: function() {\n\t\tjsio(\"import ui.View\");\n\t\treturn ui.View;\n\t},\n\tGCImage: function() {\n\t\tjsio(\"import ui.resource.Image\");\n\t\treturn ui.resource.Image;\n\t},\n\tGCImageView: function() {\n\t\tjsio(\"import ui.ImageView\");\n\t\treturn ui.ImageView;\n\t},\n\tGCCanvas: getCanvasCtor,\n\tGCSprite: function() {\n\t\tjsio(\"import ui.SpriteView\");\n\t\treturn ui.SpriteView;\n\t},\n\tGCResources: function() { // deprecated\n\t\tjsio(\"import ui.resource.loader\");\n\t\treturn ui.resource.loader;\n\t}\n};\n\nvar sdk__api_client_UI=__class__;exports=sdk__api_client_UI(function sdk__api_client_UI(){return this.init&&this.init.apply(this,arguments)},function() {\n\tvar loader = null;\n\tthis.cssFile = function(path, cb) {\n\t\t//if (!loader) { loader = jsio('import squill.cssLoad'); }\n\n\t\t// load from cache\n\t\tvar textContent = CACHE[path];\n\t\tif (textContent) {\n\t\t\t$({tag: 'style', text: textContent, parent: document.getElementsByTagName('head')[0]});\n\t\t\tsetTimeout(cb, 0);\n\t\t}\n\t\t\n\t\t//loader.get(path, cb);\n\t}\n\t\n\tthis._spinnerCounter = 0;\n\n\tjsio(\"import device\");\n\n\tvar baseScale;\n\tif (navigator.displayMetrics) {\n\t\tbaseScale = navigator.displayMetrics.densityDpi / 160;\n\t} else if (!CONFIG.scaleDPR && device.isMobileBrowser) {\n\t\tbaseScale = 1;\n\t} else {\n\t\tbaseScale = window.devicePixelRatio || 1;\n\t}\n\n\tthis._scale = baseScale;\n\n\tthis.setTargetDensity = function (target) {\n\t\tswitch (target) {\n\t\t\tcase 'high':\n\t\t\t\tthis._scale = baseScale * 0.5;\n\t\t\t\tbreak;\n\t\t\tcase 'medium':\n\t\t\t\tthis._scale = baseScale * 0.75;\n\t\t\t\tbreak;\n\t\t\tcase 'low':\n\t\t\tdefault:\n\t\t\t\tthis._scale = baseScale;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tlogger.log('scale:', this._scale);\n\t}\n\n\tthis.getScale = function () {\n\t\treturn this._scale;\n\t}\n\n\tthis.getIntValue = function (val) {\n\t\treturn Math.round(val * this._scale) / this._scale;\n\t}\n\n\tthis.showSpinner = function() {\n\t\tif (this._spinnerCounter) {\n\t\t\t++this._spinnerCounter;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tvar parent = GC.app.view;\n\t\tif (!parent) { return; }\n\t\t\n\t\t++this._spinnerCounter;\n\t\t\n\t\tif (!this._spinner) {\n\t\t\tvar dim = device.screen.devicePixelRatio * 50;\n\t\t\tthis._spinner = new Spinner({\n\t\t\t\twidth: dim,\n\t\t\t\theight: dim,\n\t\t\t\tx: parent.style.width / 2 - dim / 2,\n\t\t\t\ty: parent.style.height / 2 - dim / 2,\n\t\t\t\tparent: parent\n\t\t\t});\n\t\t} else {\n\t\t\tparent.addSubview(this._spinner);\n\t\t}\n\t}\n\t\n\tthis.hideSpinner = function() {\n\t\t--this._spinnerCounter;\n\t\tif (this._spinnerCounter <= 0) {\n\t\t\tthis._spinnerCounter = 0;\n\t\t\t\n\t\t\tthis._spinner && this._spinner.removeFromSuperview();\n\t\t}\n\t}\n\t\n\t// this.showDisplayNameDialog = function() {\n\t// \tthis.getDisplayNameDialog().show();\n\t// }\n\t\n\t// this.showAcceptInviteDialog = function(cb) {\n\t// \tGC.getConnection().withHandshake(this, function(err) {\n\t// \t\tif (err) { cb(err); return; }\n\t\t\t\n\t// \t\t// TODO: conn.getLoginDetails()\n\t// \t\tlogger.warn('put some real details in here');\n\n\t// \t\tvar details = {\n\t// \t\t\tfrom: 'Martin',\n\t// \t\t\tgame: 'Chess',\n\t// \t\t\tsummary: 'chess, 15 min, rated'\n\t// \t\t};\n\t\t\t\n\t// \t\tvar dialog = this.getAcceptInviteDialog();\n\t// \t\tdialog.setDetails(details);\n\t// \t\tdialog.delegate = function(action) {\n\t// \t\t\tswitch (action) {\n\t// \t\t\t\tcase 'accept':\n\t// \t\t\t\t\tGC.app.launchMultiplayerGame();\n\t// \t\t\t\t\tbreak;\n\t// \t\t\t\tcase 'decline':\n\t// \t\t\t\tdefault:\n\t// \t\t\t\t\tcb(action);\n\t// \t\t\t\t\tbreak;\n\t// \t\t\t}\n\t// \t\t};\n\t\t\t\n\t// \t\tdialog.show();\n\t\t\t\n\t// \t\tcb && cb('opened');\n\t// \t});\n\t// }\n\t\n\t// this.showChat = function() {\n\t// \tif (!this._chatMenu) {\n\t// \t\timport GCMenus.Chat;\n\t// \t\tthis._chatMenu = new GCMenus.Chat();\n\t// \t}\n\t\t\n\t// \tvar menuController = this.getMenuController();\n\t// \tif (menuController.isVisible()) {\n\t// \t\tmenuController.push(this._chatMenu);\n\t// \t} else {\n\t// \t\tmenuController.push(this._chatMenu, true);\n\t// \t\tmenuController.fadeIn();\n\t// \t\tthis._chatMenu.subscribeOnce('BeforeHide', this, function() {\n\t// \t\t\tmenuController.fadeOut();\n\t// \t\t});\n\t// \t}\n\t// }\n\t\n\t// this.alert = function(msg) {\n\t// \tthis.showDialog({title: '', message: msg});\n\t// }\n\t\n\t// this.showError = function(opts) {\n\t// \tthis.showDialog(merge(opts, {title: 'Error:', message: \"Sorry!\"}));\n\t// }\n\t\n\t// this.showDialog = function(opts) {\n\t// \timport GCDialogs.AlertDialog;\n\t// \tvar dialog = new GCDialogs.AlertDialog(opts);\n\t// \tdialog.show();\n\t// \treturn dialog;\n\t// }\n\t\n\t// this.getAcceptInviteDialog = function() {\n\t// \tif (!this._acceptInviteDialog) {\n\t// \t\timport GCDialogs.AcceptInviteDialog;\n\t// \t\tthis._acceptInviteDialog = new GCDialogs.AcceptInviteDialog();\n\t// \t}\n\t\t\n\t// \treturn this._acceptInviteDialog;\n\t// }\n\t\n\t// this.getDisplayNameDialog = function() {\n\t// \tif (!this._displayNameDialog) {\n\t// \t\timport GCDialogs.DisplayNameDialog;\n\t// \t\tthis._displayNameDialog = new GCDialogs.DisplayNameDialog();\n\t// \t}\n\t\t\n\t// \treturn this._displayNameDialog;\n\t// }\n\t\n\t// this.getParentNode = function() {\n\t// \tif (!this._parentNode) {\n\t// \t\timport timestep.doc;\n\t// \t\tthis._parentNode = timestep.doc.getElement();\n\t// \t}\n\t// \treturn this._parentNode;\n\t// }\n\t\n\t// this.showMainMenu = function(opts) {\n\t// \topts = merge(opts, {\n\t// \t\tfade: true,\n\t// \t\tbackToGame: false\n\t// \t});\n\t\t\n\t// \tvar controller = this.getMenuController();\n\t// \tvar mainMenu = this.getMainMenu();\n\t// \tmainMenu.setGameRunning(opts.backToGame);\n\t// \tcontroller.push(mainMenu);\n\t// \tif (opts.fade) { controller.fadeIn(); }\n\t// }\n\t\n\t// this.fadeOutMenus = function() { this.getMenuController().fadeOut(); }\n\t// this.fadeInMenus = function() { this.getMenuController().fadeIn(); }\n\t\n\t// this.getMenuController = function() {\n\t// \tif (!this._menuController) {\n\t// \t\timport GCMenus.MainMenu;\n\t// \t\timport squill.MenuController;\n\t// \t\tthis._menuController = new squill.MenuController({\n\t// \t\t\tcontroller: this,\n\t// \t\t\tparent: this.getParentNode(),\n\t// \t\t\tdelegate: GCMenus.MainMenu.delegate,\n\t// \t\t\tid: 'mainMenuController'\n\t// \t\t});\n\t// \t}\n\t\t\n\t// \treturn this._menuController;\n\t// }\n\t\n\t// this.getMainMenu = function() {\n\t// \tif (!this._mainMenu) {\n\t// \t\timport GCMenus.MainMenu;\n\t// \t\tthis._mainMenu = new GCMenus.MainMenu(merge(this._mainMenuOpts, {\n\t// \t\t\tsupports: {} //MANIFEST.supports\n\t// \t\t}));\n\t// \t}\n\t\t\n\t// \treturn this._mainMenu;\n\t// }\n\t\n\t// this.setMainMenuOpts = function(opts) {\n\t// \tthis._mainMenu = null;\n\t// \tthis._mainMenuOpts = merge(opts, {\n\t// \t\ttitle: 'Welcome!',\n\t// \t\timgLogo: 'resources/images/logo.png',\n\t// \t\timgSingle: 'resources/images/btnSingle.png',\n\t// \t\timgMulti: 'resources/images/btnMulti.png',\n\t// \t\tshowInvites: true,\n\t// \t\tshowGames: true,\n\t// \t\tquitGameOnShow: false\n\t// \t});\n\t\t\n\t// \treturn this;\n\t// }\n\t\n\t// this.getMainMenuOpts = function() { return this._mainMenuOpts; }\n\t\n\t// this.hideCursor = function() {\n\t// \tvar el = GC.app.getCanvas().getElement();\n\t// \tif (el) { el.style.cursor = 'none'; }\n\t// }\n\t\n\t// this.showCursor = function(name) {\n\t// \tvar el = GC.app.getCanvas().getElement();\n\t// \tif (el) { el.style.cursor = name || 'default'; }\n\t// }\n});\n\nvar cache = {};\nfor (var key in uiExports) {\n\tvar getter = bind(GLOBAL, function(key) {\n\t\t\treturn cache[key] || (cache[key] = uiExports[key]());\n\t\t}, key);\n\t\n\tif (GLOBAL.__defineGetter__) {\n\t\tGLOBAL.__defineGetter__(key, getter);\n\t} else {\n\t\tif (Object.defineProperty) {\n\t\t\tObject.defineProperty(GLOBAL, key, {get: getter});\n\t\t}\n\t}\n}\n\nfunction AsyncImageLoader(url, callback) {\n\tvar img = new ui.resource.Image({url: url});\n\timg.doOnLoad(function(success) { callback(img); });\n}\n\nfunction getCanvasCtor() {\n\tjsio(\"import device\");\n\tvar ctor = device.get('Canvas');\n\treturn ctor;\n}\n","pre":true},"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/lib/Iterator.js":{"path":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/lib/Iterator.js","friendlyPath":"lib.Iterator","directory":"/Users/arnovandervegt/gameclosure/basil/sdk/jsio/lib/","filename":"Iterator.js","src":"\"use import\";\n\n/**\n * Summary: Provides an object for iterating over the keys and values of\n * an object or array.  \n * Methods: \n *  - init(src) - src is the object to iterate over\n *  - next(): returns the current value and advances the iterator to the next value\n *  - loop(cb): iterate over all items immediately, calling cb with each item\n *  - asyncLoop(cb): iterate over all items asynchronously.  First argument to\n *     the callback is the item.  Second argument is a function `nextItem` that, \n *     when called, will cause the iterator to advance to the next element and \n *     call cb again.\n * Usage notes: asyncLoop is implemented to not be vulnerable to stack overflows.\n *     If cb immediately calls the nextItem function, it will not immediately \n *     result in a call to cb -- the stack will unwind to the asyncLoop call \n *     before continuing.\n */\n\njsio(\"import std.js as JS\");\n\nvar Users_arnovandervegt_gameclosure_basil_sdk_jsio_lib_Iterator=__class__;exports=Users_arnovandervegt_gameclosure_basil_sdk_jsio_lib_Iterator(function Users_arnovandervegt_gameclosure_basil_sdk_jsio_lib_Iterator(){return this.init&&this.init.apply(this,arguments)},function() {\n\tthis.init = function(src) {\n\t\tthis._src = src;\n\t\tthis._i = 0;\n\t\t\n\t\t// a call count prevents a stack overflow if the callback in\n\t\t// an aysncloop is called repeatedly for large arrays\n\t\tthis._calls = 0;\n\t\tif (JS.isArray(src)) {\n\t\t\tthis._isArray = true;\n\t\t} else if (Object.keys) {\n\t\t\tthis._keys = Object.keys(src);\n\t\t} else {\n\t\t\tvar k = this._keys = [];\n\t\t\tfor (var i in src) { if (src.hasOwnProperty(i)) { k.push(i); } }\n\t\t}\n\t}\n\t\n\tthis.nextKey = function() {\n\t\treturn this._keys[this._i++];\n\t}\n\t\n\tthis.next = function() {\n\t\tif (this._isArray) {\n\t\t\treturn this._src[this._i++] || exports.END_OF_LOOP;\n\t\t} else {\n\t\t\tvar key = this._keys[this._i++];\n\t\t\treturn key ? this._src[key] : exports.END_OF_LOOP;\n\t\t}\n\t}\n\t\n\tthis.loop = function(cb) {\n\t\tif (arguments.length > 1) { cb = bind.apply(this, arguments); }\n\t\tvar next;\n\t\tif (this._isArray) {\n\t\t\twhile((next = this.next())) {\n\t\t\t\tcb(next);\n\t\t\t}\n\t\t} else {\n\t\t\twhile((next = this.nextKey())) {\n\t\t\t\tcb(this._src[next], next);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tthis.asyncLoop = function(cb) {\n\t\tif (arguments.length > 1) { cb = bind.apply(this, arguments); }\n\t\tthis._next = bind(this, '_onReturn', cb);\n\t\tthis._calls++;\n\t\tthis._asyncLoop(cb);\n\t}\n\t\n\tthis._asyncLoop = function(cb) {\n\t\tthis._inLoop = true;\n\t\twhile (this._calls) {\n\t\t\t--this._calls;\n\t\t\tcb(this.next(), this._next);\n\t\t}\n\t\tthis._inLoop = false;\n\t}\n\t\n\tthis._onReturn = function(cb) {\n\t\tthis._calls++;\n\t\tif (!this._inLoop) { this._asyncLoop(cb); }\n\t}\n});\n\nexports.END_OF_LOOP = new Error('jsio.Iterator.END_OF_LOOP');\n","pre":true},"../../../../sdk/timestep/ui/widget/Spinner.js":{"path":"../../../../sdk/timestep/ui/widget/Spinner.js","friendlyPath":"ui.widget.Spinner","directory":"../../../../sdk/timestep/ui/widget/","filename":"Spinner.js","src":"/**\n * @class ui.widget.Spinner;\n */\n\njsio(\"import ui.layout.LinearView as LinearView\");\n\nvar sdk_timestep_ui_widget_Spinner=__class__;exports=sdk_timestep_ui_widget_Spinner(function sdk_timestep_ui_widget_Spinner(){return this.init&&this.init.apply(this,arguments)},LinearView, function (supr) {\n\n\tvar defaults = {\n\t\tcycles: 0.5,\n\t\tradius: 10,\n\t\tspokes: 20,\n\t\tthickness: 2,\n\t\ttrail: 10,\n\t\tcolor: '#ffffff',\n\t\tbackgroundColor: 'rgba(0, 0, 0, 0.5)'\n\t};\n\t\n\tthis.tag = 'spinner';\n\tthis._t = 0;\n\t\n\tthis.init = function (opts) {\n\t\tthis._opts = merge(opts, defaults);\n\t\t\n\t\tthis._step = 2 * Math.PI / this._opts.spokes;\n\t\t\n\t\tsupr(this, 'init', [this._opts]);\n\t};\n\t\n\tthis.tick = function(dt) {\n\t\tthis._t += dt;\n\t\t\n\t\tvar r = (this._t / 1000 % (1 / this._opts.cycles)) * Math.PI;\n\t\t\n\t\tvar oldR = this._r;\n\t\tthis._r = r - (r % this._step);\n\t\t\n\t\tif (oldR != r) {\n\t\t\tthis.needsRepaint();\n\t\t}\n\t}\n\t\n\tthis.render = function(ctx) {\n\t\tctx.fillStyle = this._opts.backgroundColor;\n\t\t\n\t\tvar w = this.style.width,\n\t\t\t\th = this.style.height,\n\t\t\t\tradius = this._opts.radius,\n\t\t\t\ttrail = this._opts.trail,\n\t\t\t\tthickness = this._opts.thickness,\n\t\t\t\tx, y, i, j;\n\t\t\n\t\tfor (y = 0; y < radius; ++y) {\n\t\t\tj = y + 1;\n\t\t\tx = Math.round(radius - Math.sqrt(2 * j * radius - j * j));\n\t\t\tctx.fillRect(x, y, w - 2 * x, 1);\n\t\t}\n\t\t\n\t\ty = h - radius;\n\t\tctx.fillRect(0, radius, w, y - radius);\n\t\t\n\t\tfor (i = 0; i < radius; ++i) {\n\t\t\tj = radius - i;\n\t\t\tx = Math.round(radius - Math.sqrt(2 * j * radius - j * j));\n\t\t\tctx.fillRect(x, y + i, w - 2 * x, 1);\n\t\t}\n\t\t\n\t\tctx.fillStyle = this._opts.color;\n\t\tctx.translate(w / 2, h / 2);\n\t\tw /= 2;\n\t\tctx.rotate(this._r);\n\t\t\n\t\tfor (i = 0; i < this._opts.spokes; ++i) {\n\t\t\tctx.rotate(this._step);\n\t\t\tctx.globalAlpha = Math.max(0.1, (i - trail) / trail);\n\t\t\tctx.fillRect(10, -thickness / 2, w - 15, thickness);\n\t\t}\n\t}\n});\n","pre":true},"../../../../sdk/timestep/ui/SpriteView.js":{"path":"../../../../sdk/timestep/ui/SpriteView.js","friendlyPath":"ui.SpriteView","directory":"../../../../sdk/timestep/ui/","filename":"SpriteView.js","src":"/**\n * @class ui.SpriteView\n * SpriteView pulls out sprited images and renders them at a given FPS\n * interval. A sprite consists of multiple *animations* (walk, run,\n * etc) which themselves consist of multiple *frames*.\n *\n * The sprite system pulls images from a given source format. Given\n * images like the following:\n *\n *     someFolder/spriteName-animationName-0001.png\n *     someFolder/spriteName-animationName-0002.png\n *\n * You'd instantiate a Sprite like so:\n * \n *     var mySprite = new SpriteView({url: \"someFolder/spriteName\"})\n * \n * The SpriteView class automatically find the images associated with that\n * sprite and generates the configuration for each of the animations.\n *\n * Then you would call this to start an animation:\n *\n *     mySprite.startAnimation(\"animationName\");\n *\n * @doc http://doc.gameclosure.com/api/ui-spriteview.html\n * @docsrc https://github.com/gameclosure/doc/blob/master/api/ui/spriteview.md\n */\n\njsio(\"import ui.ImageView as ImageView\");\njsio(\"import ui.resource.Image as Image\");\njsio(\"import ui.resource.loader\");\n\nvar sdk_timestep_ui_SpriteView=__class__;var SpriteView = exports=sdk_timestep_ui_SpriteView(function sdk_timestep_ui_SpriteView(){return this.init&&this.init.apply(this,arguments)},\"SpriteView\", ImageView, function (logger, supr) {\n\t\n\tthis.defaults = {\n\t\turl: null, // specified as a filename prefix, without an animation name or frame count\n\t\tgroupID: \"default\",\n\t\tframeRate: 15,\n\t\temitFrameEvents: false,\n\t\tautoStart: false,\n\t\tloop: true\n\t};\n\n\tvar GROUPS = {};\n\n\tthis.init = function(opts) {\n\t\tthis._opts = opts = merge(opts, this.defaults);\n\t\topts.visible = false;\n\t\tsupr(this, 'init', [opts]);\n\t\tthis.resetAllAnimations(opts);\n\t};\n\n\tthis.resetAllAnimations = function(opts) {\n\t\tthis.stopAnimation();\n\n\t\tthis._opts = opts = merge(opts, this.defaults);\n\n\t\tvar animations = SpriteView.allAnimations[opts.url];\n\t\t\n\t\tthis.groupID = opts.groupID;\n\t\tthis.frameRate = opts.frameRate;\n\t\t\n\t\tif (!GROUPS[this.groupID]) {\n\t\t\tGROUPS[this.groupID] = new Group();\n\t\t}\n\n\t\tthis._animations = {};\n\t\tvar autoSizeWidth = null;\n\t\tvar autoSizeHeight = null;\n\n\t\tfor (var animName in animations) {\n\t\t\tif (!this._opts.defaultAnimation) {\n\t\t\t\tthis._opts.defaultAnimation = animName;\n\t\t\t}\n\t\t\tthis.addAnimation(animName, animations[animName]);\n\t\t\tvar frameImages = this._animations[animName].frames;\n\t\t\tif (!autoSizeWidth && frameImages[0]) {\n\t\t\t\tautoSizeWidth = frameImages[0].getWidth();\n\t\t\t\tautoSizeHeight = frameImages[0].getHeight();\n\t\t\t}\n\t\t}\n\n\t\tif (opts.autoSize) {\n\t\t\tthis.style.width = autoSizeWidth;\n\t\t\tthis.style.height = autoSizeHeight;\n\t\t}\n\n\t\topts.autoStart && this.startAnimation(this._opts.defaultAnimation);\n\t};\n\n\tthis.addAnimation = function(animName, frameData) {\n\t\tif ( ! isArray(frameData) ) {\n\t\t\tframeData = SpriteView.allAnimations[frameData][animName];\n\t\t}\n\t\tvar frameImages = [];\n\t\tfor (var i = 0, frame; frame = frameData[i]; i++) {\n\t\t\tframeImages.push(new Image({url: frame.url}));\n\t\t}\n\t\tthis._animations[animName] = {\n\t\t\tframes: frameImages\n\t\t};\n\t};\n\t\n\t/** Returns a ui.resource.Image for the given animation's frame. */\n\tthis.getFrame = function(animName, index) {\n\t\treturn this._animations[animName].frames[index];\n\t};\n\n\t/** Returns the number of frames in a given animation. */\n\tthis.getFrameCount = function(animName) {\n\t\treturn this._animations[animName].frames.length;\n\t};\n\n\tthis.getGroup = function(groupID) {\n\t\treturn GROUPS[groupID || this.groupID];\n\t};\n\n\t/**\n\t * Starts an animation. Default options:\n\t *     loop: false\n\t *     iterations: 1\n\t *     callback: null (called at the end of the animation)\n\t *     frame: 0 (frame to start on)\n\t *     randomFrame: false (start on a random frame of the animation)\n\t */\n\tthis.startAnimation = function (name, opts) {\n\t\topts = opts || {};\n\n\t\tif ( opts.randomFrame === true && opts.frame == null ) {\n\t\t\topts.frame = Math.random() * this._animations[name].frames.length | 0;\n\t\t}\n\n\t\tif (opts.loop === true) { opts.iterations = Infinity; }\n\n\t\tthis._iterationsLeft = opts.iterations || 1;\n\t\tthis._callback = opts.callback || null;\n\t\tthis._currentAnimationName = name;\n\t\tthis._currentFrame = opts.frame || 0;\n\t\tthis._dt = 0;\n\n\t\tif (!this._animations[name]) {\n\t\t\tthrow new Error(\"Animation \" + name + \" does not exist: \" + this._opts.url + \".\");\n\t\t}\n\n\t\tif (!this.isPlaying) {\n\t\t\tGC.app.engine.subscribe('Tick', this, '_tickSprite');\n\t\t\tGROUPS[this.groupID].add(this);\n\t\t\tthis.isPlaying = this.running = true;\n\t\t\tthis.style.visible = true;\n\t\t}\n\n\t\t// align the image for the first time\n\t\tthis._tickSprite(0);\n\t};\n\n\t/** Stops the current animation. This will make the sprite invisible. */\n\tthis.stopAnimation = function() {\n\t\tif (this.isPlaying) {\n\t\t\tthis.style.visible = false;\n\t\t\tGC.app.engine.unsubscribe('Tick', this, '_tickSprite');\n\t\t\tthis.isPlaying = this.running = false;  //use isPlaying, this.running is deprecated\n\t\t\tthis.isPaused = this._isPaused = false; //use isPaused instead, _isPaused is deprecated\n\t\t\tGROUPS[this.groupID].remove(this.uid);\n\t\t}\n\t};\n\n\t/**\n\t * If this animation doesn't loop, stops the animation entirely.\n\t * Otherwise restarts the default animation. For instance, if you\n\t * had a default animation \"idle\", you could call\n\t *\n\t *     startAnimation('walk', {iterations: 2});\n\t *\n\t * and after 2 iterations of the 'walk' animation, it would go\n\t * back to the 'walk' animation.\n\t */\n\tthis.resetAnimation = function() {\n\t\tif (!this._opts.loop) {\n\t\t\tthis.stopAnimation();\n\t\t} else {\n\t\t\tthis.startAnimation(this._opts.defaultAnimation);\n\t\t}\n\t};\n\n\tthis.setFramerate = function(fps) {\n\t\tthis.frameRate = fps || 0.00001;\n\t};\n\n\tthis.pause = function() {\n\t\tthis.isPaused = this._isPaused = true;\n\t};\n\n\tthis.resume = function() {\n\t\tthis.isPaused = this._isPaused = false;\n\t};\n\n\tthis._tickSprite = function(dt) {\n\t\tif (this.isPaused) { return; }\n\n\t\tdt += this._dt;\n\n\t\tvar anim = this._animations[this._currentAnimationName];\n\t\tvar stepTime = (1000 / this.frameRate);\n\t\tvar frameSteps = dt / stepTime | 0;\n\t\tvar prevFrame = this._currentFrame;\n\t\tthis._dt = dt - frameSteps * stepTime;\n\t\tthis._currentFrame = (this._currentFrame + frameSteps) % anim.frames.length;\n\n\t\tif (this._currentFrame < 0) {\n\t\t\tthis._currentFrame += anim.frames.length;\n\t\t}\n\t\t\n\t\tif (frameSteps !== 0 || dt === 0) {\n\t\t\tvar image = this._animations[this._currentAnimationName].frames[this._currentFrame];\n\t\t\tthis.setImage(image);\n\n\t\t\tif (this._opts.emitFrameEvents) {\n\t\t\t\tfor (var i = 0; i < frameSteps; i++) {\n\t\t\t\t\tvar frame = (prevFrame + i) % anim.frames.length;\n\t\t\t\t\tthis.publish(this._currentAnimationName + '_' + frame);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar iterationsCompleted = (prevFrame + frameSteps) / anim.frames.length | 0;\n\t\tif (iterationsCompleted) {\n\t\t\tif (--this._iterationsLeft <= 0) {\n\t\t\t\tvar cb = this._callback;\n\t\t\t\tthis._callback = null;\n\n\t\t\t\tthis.resetAnimation();\n\t\t\t\tif (cb) cb();\n\t\t\t}\n\t\t}\n\t};\n});\n\nSpriteView.allAnimations = {};\nSpriteView.getGroup = SpriteView.prototype.getGroup;\n\n(function loadAnimations() {\n\t// build the animation frame map\n\tvar resourceMap = ui.resource.loader.getMap();\n\tvar allAnimations = SpriteView.allAnimations;\n\n\t// Generate the animations from the filenames in resourceMap.\n\t// These names must be sorted ascending so that the frames end up\n\t// in the correct order.\n\tvar filenames = Object.keys(resourceMap);\n\tfilenames.sort();\n\n\t// Based on the filenames, add each image to an animation map (where applicable).\n\tfor (var i in filenames) {\n\t\tvar k = filenames[i];\n\t\t// split a filename like this: /resources/images/creature-walking-0001.png\n\t\t//       into parts like this: '    animKey     '  name  ' anim  ' #  '\n\t\tvar match = /((?:.*)\\/.*?)[-_ ](.*?)[-_ ](\\d+)/.exec(k);\n\t\tif (match) {\n\t\t\tvar animKey = match[1];\n\t\t\tvar name = match[2];\n\t\t\tvar frameNumber = match[3];\n\t\t\tvar anim = (allAnimations[animKey] || (allAnimations[animKey] = {}));\n\t\t\tvar frameList = (anim[name] || (anim[name] = []));\n\t\t\tvar info = resourceMap[k];\n\t\t\tinfo.url = k;\n\t\t\tframeList.push(info);\n\t\t}\n\t}\n})();\n\n\n/**\n * Group class\n */\nGroup=__class__;var Group=Group(function Group(){return this.init&&this.init.apply(this,arguments)},jsio.__filename, function(logger) {\n\n\tthis.init = function() {\n\t\tthis.sprites = {};\n\t};\n\n\tthis.add = function(sprite) {\n\t\tthis.sprites[sprite.uid] = sprite;\n\t};\n\n\tthis.remove = function(uid) {\n\t\tdelete this.sprites[uid];\n\t};\n\n\tthis.pause = function() {\n\t\tthis._forEachSprite('pause');\n\t};\n\n\tthis.resume = function() {\n\t\tthis._forEachSprite('resume');\n\t};\n\n\tthis.stopAnimation = function() {\n\t\tthis._forEachSprite('stopAnimation');\n\t};\n\n\tthis.resetAnimation = function() {\n\t\tthis._forEachSprite('resetAnimation');\n\t};\n\n\tthis._forEachSprite = function(method) {\n\t\tfor (var i in this.sprites) {\n\t\t\tthis.sprites[i][method]();\n\t\t}\n\t};\n});\n","pre":true},"../../../../sdk/_api/client/OverlayAPI.js":{"path":"../../../../sdk/_api/client/OverlayAPI.js","friendlyPath":".OverlayAPI","directory":"../../../../sdk/_api/client/","filename":"OverlayAPI.js","src":"var sdk__api_client_OverlayAPI=__class__;var OverlayAPI = exports=sdk__api_client_OverlayAPI(function sdk__api_client_OverlayAPI(){return this.init&&this.init.apply(this,arguments)},function() {\n\tthis.init = function(env) {\n\t\tlogger.log('env', env);\n\t\tswitch (env) {\n\t\t\tcase 'browser':\n\t\t\t\tthis.delegate = new BrowserDelegate(this);\n\t\t\t\tbreak;\n\t\t\tcase 'ios':\n\t\t\tcase 'android':\n\t\t\t\tlogger.log('adding an overlay for android or iphone');\n\t\t\t\tthis.delegate = new IOSDelegate(this);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tthis.setController = function(controller) {\n\t\tif (this.controller) { this.controller.onBeforeClose(); }\n\t\tthis.controller = controller;\n\t}\n\t\n\tthis.send = function(data) {\n\t\tthis.delegate.send(data);\n\t}\n\t\n\tthis.show = function() {\n\t\tlogger.log('showing overlay');\n\n\t\tif (this.controller.pauseTimestep()) {\n\t\t\tjsio(\"import ui.Engine\");\n\t\t\tui.Engine.get().pause();\n\t\t}\n\n\t\tthis.controller.onShow();\n\t\tthis.delegate.show();\n\t}\n\n\tthis.hide = function() {\n\t\tlogger.log('hiding overlay');\n\n\t\tif (this.controller.pauseTimestep()) {\n\t\t\tjsio(\"import ui.Engine\");\n\t\t\tui.Engine.get().resume();\n\t\t}\n\t\t\n\t\tthis.controller.onHide();\n\t\tthis.delegate.hide();\n\t}\n\t\n\tthis.pushMenu = function(name) {\n\t\tthis.delegate.send({type: 'ui', target: name, method: 'push'});\n\t}\n\t\n\tthis.popMenu = function() {\n\t\tthis.delegate.send({type: 'ui', method: 'pop'});\n\t}\n\t\n\tthis.popToMenu = function(name) {\n\t\tthis.delegate.send({type: 'ui', target: name, method: 'pop'});\n\t}\n\n\tthis.showDialog = function(name) {\n\t\tthis.delegate.send({type: 'ui', target: name, method: 'show'});\n\t}\n\t\n\tthis.hideDialog = function(name) {\n\t\tthis.delegate.send({type: 'ui', target: name, method: 'hide'});\n\t}\n\t\n\tthis.load = function(name, opts) { \n\t\tif (!/^[a-zA-Z0-9]+$/.test(name)) {\n\t\t\tlogger.error('Invalid name for overlay! (only letters and numbers please)');\n\t\t\treturn;\n\t\t}\n\n\t\tvar ctor = jsio('import overlay.' + name);\n\t\tthis.setController(new ctor(opts));\n\t\tthis.delegate.load(name);\n\t\treturn this.controller;\n\t}\n});\n\nexports.prototype.BaseOverlay=__class__;exports.prototype.BaseOverlay=exports.prototype.BaseOverlay(function exports_prototype_BaseOverlay(){return this.init&&this.init.apply(this,arguments)},function() {\n\tthis.pauseTimestep = function() { return true; }\n\t\n\tthis.onEvent = \n\tthis.onShow = \n\tthis.onHide = \n\tthis.onBeforeClose =\n\t\tfunction() {}\n});\n\nBrowserDelegate=__class__;var BrowserDelegate=BrowserDelegate(function BrowserDelegate(){return this.init&&this.init.apply(this,arguments)},function() {\n\tthis.init = function(api) {\n\t\tjsio(\"from util.browser import $\");\n\t\tjsio(\"import device\");\n\t\t\n\t\tthis._api = api;\n\t\tthis._removeListener = $.onEvent(window, 'message', this, '_onMessage');\n\t}\n\t\n\tthis.destroy = function() {\n\t\tif (this._removeListener) {\n\t\t\tthis._removeListener();\n\t\t\tthis._removeListener = null;\n\t\t}\n\t}\n\t\n\tthis.load = function(name) {\n\t\tjsio(\"import .doc\");\n\t\tjsio(\"import std.uri\");\n\t\t\n\t\tif (!this._el) {\n\t\t\tthis._el = $({\n\t\t\t\tsrc: 'javascript:var d=document;d.open();d.close()',\n\t\t\t\ttag: 'iframe',\n\t\t\t\tparent: doc.getElement(),\n\t\t\t\tstyle: {\n\t\t\t\t\tborder: 0,\n\t\t\t\t\twidth: '100%',\n\t\t\t\t\tminHeight: '100%',\n\t\t\t\t\theight: '100%',\n\t\t\t\t\tposition: 'absolute',\n\t\t\t\t\ttop: '0px',\n\t\t\t\t\tleft: '0px'\n\t\t\t\t},\n\t\t\t\tattrs: {\n\t\t\t\t\tborder: 'no',\n\t\t\t\t\tallowTransparency: 'yes'\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\t$.hide(this._el);\n\t\t}\n\t\t\n\t\tvar src = new std.uri('overlay/' + name + '.html');\n\t\tif (device.simulating) {\n\t\t\tsrc.addHash({simulate: encodeURIComponent(device.simulating)});\n\t\t}\n\t\t\n\t\tif (device.isMobileBrowser) {\n\t\t\tsrc.addHash({mobileBrowser: 1});\n\t\t\tvar removeListener = $.onEvent(this._el, 'load', function(evt) {\n\t\t\t\tremoveListener();\n\t\t\t\tdevice.hideAddressBar(false);\n\t\t\t\tsetTimeout(bind(device, 'hideAddressBar', false), 0);\n\t\t\t});\n\t\t}\n\t\t\n\t\tthis._el.src = src;\n\t}\n\t\n\tthis._onMessage = function(e) {\n\t\tvar data = e.data;\n\t\tif (data.substring(0, 8) == 'OVERLAY:') {\n\t\t\ttry {\n\t\t\t\tvar evt = JSON.parse(e.data.substring(8));\n\t\t\t} catch(e) {}\n\t\t\t\n\t\t\tif (evt) {\n\t\t\t\tthis._api.controller.onEvent(evt);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tthis.send = function(data) {\n\t\tvar win = this._el.contentWindow;\n\t\twin.postMessage('OVERLAY:' + JSON.stringify(data), '*');\n\t}\n\t\n\tthis.show = function() {\n\t\tthis.send({type: 'show'});\n\t\t$.show(this._el);\n\t\tdevice.hideAddressBar();\n\t}\n\t\n\tthis.hide = function(data) {\n\t\tthis.send({type: 'hide'});\n\t\t$.hide(this._el);\n\t\tdevice.hideAddressBar();\n\t}\n});\n\nIOSDelegate=__class__;var IOSDelegate=IOSDelegate(function IOSDelegate(){return this.init&&this.init.apply(this,arguments)},function() {\n\tthis.init = function(api) {\n\t\tthis._api = api;\n\t}\n\t\n\tthis.load = function(name) {\n\t\tlogger.log('loading', name);\n\t\tNATIVE.overlay.load('/overlay/' + name + '.html?' + (+new Date()));\n\t\tif (!this._subscribed) {\n\t\t\tlogger.log('subscribing to ', NATIVE.overlay.delegate);\n\t\t\tNATIVE.overlay.delegate.subscribe('message', this, '_onMessage');\n\t\t\tthis._subscribed = true;\n\t\t}\n\t}\n\t\n\tthis._onMessage = function(data) {\n\t\tlogger.log('got a message', data);\n\t\tthis._api.controller.onEvent(data);\n\t}\n\t\n\tthis.show = function() {\n\t\tNATIVE.overlay.show();\n\t}\n\t\n\tthis.hide = function() {\n\t\tNATIVE.overlay.hide();\n\t}\n\t\n\tthis.send = function(data) {\n\t\tlogger.log('doing native.overlay.send');\n\t\tNATIVE.overlay.send(JSON.stringify(data));\n\t}\n});\n","pre":true},"../../../../sdk/_api/client/doc.js":{"path":"../../../../sdk/_api/client/doc.js","friendlyPath":".doc","directory":"../../../../sdk/_api/client/","filename":"doc.js","src":"/**\n * Initializes the browser Document by enlarging the viewport and responding\n * to resize and scaling events.\n *\n * Required by GC.Application to initialize the Application Engine into the\n * document body.\n */\n\njsio(\"import lib.PubSub\");\njsio(\"import lib.Enum as Enum\");\njsio(\"import std.js as JS\");\njsio(\"from util.browser import $\");\n\njsio(\"import device\");\n\nvar SCALING = Enum('FIXED', 'RESIZE', 'MANUAL');\nvar defaultScalingMode = device.isMobileBrowser || device.simulating ? SCALING.RESIZE : SCALING.FIXED;\n\n/**\n * @extends lib.PubSub\n */\nDocument=__class__;var Document=Document(function Document(){return this.init&&this.init.apply(this,arguments)},lib.PubSub, function() {\n\tthis.init = function() {\n\t\tif (!$) { return; }\n\t\t\n\t\tvar doc = GLOBAL.document,\n\t\t\tbody = doc && doc.body;\n\t\t\n\t\tthis._el = $({\n\t\t\tparent: body,\n\t\t\tstyle: {\n \t\t\t\tposition: 'absolute',\n\t\t\t\toverflow: 'hidden',\n\t\t\t\twidth: '100%',\n\t\t\t\theight: '100%'\n\t\t\t}\n\t\t});\n\t\t\n\t\tdevice.screen.subscribe('Resize', this, 'onResize');\n\t\t\t\t\t\t\n\t\tif (exports.postCreateHook) { exports.postCreateHook(this); }\n\t\tthis.setScalingMode(defaultScalingMode);\n\t}\n\t\n\tthis.unsubscribeResize = function() { device.screen.unsubscribe('Resize', this, 'onResize'); }\n\t\n\tthis.setApp = function(app) {\n\t\tif (app == this._app) { return; }\n\t\t\n\t\tthis._app = app;\n\t\tthis._canvas = this._app.getCanvas();\n\n\t\tthis.appendChild(this._canvas);\n\n\t\tvar ctx = this._canvas.getContext('2d');\n\t\tif (ctx.setParentNode) { ctx.setParentNode(this._el); }\n\t}\n\t\n\tthis.getElement = function() { return this._el; }\n\t\n\tthis.setScalingMode = function(scalingMode, opts) {\n\t\tthis._scalingMode = scalingMode;\n\t\t\n\t\tvar el = this._el,\n\t\t\ts = el.style;\n\t\t\n\t\tswitch (scalingMode) {\n\t\t\tcase SCALING.FIXED:\n\t\t\t\topts = merge(opts, {\n\t\t\t\t\t\twidth: device.width,\n\t\t\t\t\t\theight: device.height\n\t\t\t\t\t});\n\t\t\t\ts.width = opts.width + 'px';\n\t\t\t\ts.height = opts.height + 'px';\n\t\t\t\tbreak;\n\t\t\tcase SCALING.RESIZE:\n\t\t\t\topts = merge(opts, {\n\t\t\t\t\t\tresizeCanvas: true\n\t\t\t\t\t});\n\t\t\t\t// fall through:\n\t\t\tcase SCALING.MANUAL:\n\t\t\t\ts.margin = '0px';\n\t\t\t\ts.width = '100%';\n\t\t\t\ts.height = '100%';\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\tthis._scalingOpts = opts;\n\t\tthis.onResize();\n\t\tsetTimeout(bind(this, 'onResize'), 1000);\n\t}\n\t\n\tthis.onResize = function() {\n\t\tvar el = this._el;\n\t\tvar s = this._el.style;\n\t\t\n\t\tel.className = device.screen.orientation;\n\t\tlogger.log('resize', device.width, device.height);\n\t\t\n\t\tvar width = device.width;\n\t\tvar height = device.height;\n\t\tvar mode = this._scalingMode;\n\t\tvar opts = this._scalingOpts;\n\t\t\n\t\tif (mode == SCALING.FIXED) {\n\t\t\twidth = opts.width;\n\t\t\theight = opts.height;\n\t\t}\n\t\t\n\t\t// enforce maxWidth/maxHeight\n\t\t// if maxWidth/maxHeight is met, switch a RESIZE scaling mode to FIXED (center the document on the screen)\n\t\tif (opts.maxWidth && width > opts.maxWidth) {\n\t\t\twidth = opts.maxWidth;\n\t\t\tif (mode == SCALING.RESIZE) { mode = SCALING.FIXED; }\n\t\t}\n\t\t\n\t\tif (opts.maxHeight && height > opts.maxHeight) {\n\t\t\theight = opts.maxHeight;\n\t\t\tif (mode == SCALING.RESIZE) { mode = SCALING.FIXED; }\n\t\t}\n\t\t\n\t\tswitch (mode) {\n\t\t\tcase SCALING.MANUAL:\n\t\t\t\tbreak; // do nothing\n\t\t\tcase SCALING.FIXED:\n\t\t\t\t// try to center the container\n\t\t\t\tel.style.top = Math.round(Math.max(0, (window.innerHeight - height) / 2)) + 'px';\n\t\t\t\tel.style.left = Math.round(Math.max(0, (window.innerWidth - width) / 2)) + 'px';\n\t\t\t\t\n\t\t\t\ts.width = width + 'px';\n\t\t\t\ts.height = height + 'px';\n\t\t\t\tbreak;\n\t\t\tcase SCALING.RESIZE:\n\t\t\t\t// if we have a canvas element, scale it\n\t\t\t\tif (opts.resizeCanvas && this._canvas\n\t\t\t\t\t\t&& (this._canvas.width != width || this._canvas.height != height)) {\n\t\t\t\t\tthis._canvas.width = width;\n\t\t\t\t\tthis._canvas.height = height;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ts.width = width + 'px';\n\t\t\t\ts.height = height + 'px';\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\t// make sure to force a render immediately (should we use needsRepaint instead?)\n\t\tthis._setDim(width, height);\n\t\tif (this._app) { this._app.render(); }\n\t}\n\t\n\tthis._setDim = function(width, height) {\n\t\tif (this.width != width || this.height != height) {\n\t\t\tthis.width = width;\n\t\t\tthis.height = height;\n\t\t\tthis.publish('Resize', width, height);\n\t\t}\n\t}\n\t\n\tthis.setColors = function(bgColor, appColor) {\n\t\tif (this._el) {\n\t\t\tthis._el.style.background = appColor;\n\t\t\tdocument.documentElement.style.background = document.body.style.background = bgColor;\n\t\t}\n\t}\n\t\n\tthis.appendChild = function(el) {\n\t\tthis._el.appendChild(el);\n\t}\n\t\n\tthis.getOffset = function() {\n\t\treturn {\n\t\t\tx: this._el.offsetLeft,\n\t\t\ty: this._el.offsetTop\n\t\t};\n\t}\n});\n\n/**\n * Create the document singleton.\n */\n\nexports = new Document();\n\nexports.SCALING = SCALING;\n\n/**\n * Set prerequisite document styles to make the page full-screen.\n */\n\nexports.setDocStyle = function() {\n\tvar doc = GLOBAL.document,\n\t\tbody = doc && doc.body;\n\t\n\tif (body) {\n\t\tvar docStyle = {\n\t\t\theight: '100%',\n\t\t\tmargin: '0px',\n\t\t\tpadding: '0px'\n\t\t};\n\t\n\t\t$.style(document.documentElement, docStyle);\n\t\t$.style(document.body, docStyle);\n\t}\n};\n\nexports.defaultParent = null;\nexports.postCreateHook = null;\n","pre":true},"./src/Application.js":{"path":"./src/Application.js","friendlyPath":"src.Application","directory":"./src/","filename":"Application.js","baseMod":"src","basePath":".","src":"jsio(\"import ui.TextView as TextView\");\njsio(\"import ui.ScrollView as ScrollView\");\n\njsio(\"import ui.View as View\");\n\nTabs=__class__;var Tabs=Tabs(function Tabs(){return this.init&&this.init.apply(this,arguments)},View, function (supr) {\n\tthis.init = function (opts) {\n\t\topts = merge(opts, {layout: \"linear\"});\n\n\t\tsupr(this, \"init\", [opts]);\n\n\t\tthis._position = opts.position || \"top\";\n\t\tthis._buttonSize = opts.buttonSize || 30;\n\n\t\tthis._panes = {};\n\t\tthis._index = 0;\n\n\t\tvar buttonsOpts = merge(opts.buttonsOpts, {superview: this, tag: \"buttons\"});\n\t\tthis._buttons = new ScrollView(buttonsOpts);\n\t\tthis._buttons.getContentView().updateOpts({layout: \"linear\", direction: \"horizontal\"});\n\t\tvar contentOpts = merge(opts.contentOpts, {superview: this, flex: 1, layout: \"linear\", direction: \"vertical\", tag: \"content\"});\n\t\tthis._content = new View(contentOpts);\n\n\t\tthis._opts.buttonOpts = merge(this._opts.buttonOpts, {flex: 1});\n\n\t\tthis.setButtonPosition(this._position);\n\t};\n\n\tthis.addPane = function (button, child) {\n\t\tvar index = button;\n\n\t\tif (typeof button === \"string\") {\n\t\t\tthis._opts.buttonOpts.text = button;\n\t\t\tthis._opts.buttonOpts.tag = button;\n\t\t\tbutton = new TextView(this._opts.buttonOpts);\n\t\t} else {\n\t\t\tthis._index++;\n\t\t\tindex = this._index.toString();\n\t\t}\n\n\t\tthis._panes[index] = child;\n\t\tthis._buttons.addSubview(button);\n\n\t\tchild.style.visible = !this._content.getSubviews().length;\n\t\tthis._content.addSubview(child);\n\n\t\treturn index;\n\t};\n\n\tthis.getPane = function (child) {\n\n\t};\n\n\tthis.getPaneByTitle = function (title) {\n\n\t};\n\n\tthis.removePane = function (child) {\n\n\t};\n\n\tthis.removePaneByTitle = function (title) {\n\n\t};\n\n\tthis.selectPane = function (child) {\n\n\t};\n\n\tthis.selectPaneByTitle = function (title) {\n\n\t};\n\n\tthis.getButton = function (title) {\n\n\t};\n\n\tthis.setButtonPosition = function (position) {\n\t\tthis.removeSubview(this._buttons);\n\t\tthis.removeSubview(this._content);\n\n\t\tthis._position = position;\n\n\t\tthis._content.updateOpts({width: undefined, height: undefined});\n\n\t\tconsole.log(this._position);\n\t\tvar views = [];\n\t\tswitch (this._position) {\n\t\t\tcase \"top\":\n\t\t\t\tviews = [this._buttons, this._content];\n\t\t\t\tthis.updateOpts({direction: \"vertical\"});\n\t\t\t\tthis._buttons.getContentView().updateOpts({direction: \"horizontal\", width: undefined, height: this._buttonSize});\n\t\t\t\tthis._buttons.updateOpts({width: undefined, height: this._buttonSize});\n\t\t\t\tthis._content.updateOpts({direction: \"vertical\"});\n\t\t\t\tbreak;\n\n\t\t\tcase \"bottom\":\n\t\t\t\tviews = [this._content, this._buttons];\n\t\t\t\tthis.updateOpts({direction: \"vertical\"});\n\t\t\t\tthis._buttons.getContentView().updateOpts({direction: \"horizontal\", width: undefined, height: this._buttonSize});\n\t\t\t\tthis._buttons.updateOpts({width: undefined, height: this._buttonSize});\n\t\t\t\tthis._content.updateOpts({direction: \"vertical\"});\n\t\t\t\tbreak;\n\n\t\t\tcase \"left\":\n\t\t\t\tviews = [this._buttons, this._content];\n\t\t\t\tthis.updateOpts({direction: \"horizontal\"});\n\t\t\t\tthis._buttons.getContentView().updateOpts({direction: \"vertical\"});\n\t\t\t\tthis._buttons.getContentView().updateOpts({width: this._buttonSize, height: undefined});\n\t\t\t\tthis._buttons.updateOpts({width: this._buttonSize, height: undefined});\n\t\t\t\tthis._content.updateOpts({direction: \"horizontal\"});\n\t\t\t\tbreak;\n\n\t\t\tcase \"right\":\n\t\t\t\tviews = [this._content, this._buttons];\n\t\t\t\tthis.updateOpts({direction: \"horizontal\"});\n\t\t\t\tthis._buttons.getContentView().updateOpts({direction: \"vertical\"});\n\t\t\t\tthis._buttons.getContentView().updateOpts({width: this._buttonSize, height: undefined});\n\t\t\t\tthis._buttons.updateOpts({width: this._buttonSize, height: undefined});\n\t\t\t\tthis._content.updateOpts({direction: \"horizontal\"});\n\t\t\t\tbreak;\n\t\t}\n\n\t\tconsole.log(this._buttons._opts);\n\t\tthis.addSubview(views[0]);\n\t\tthis.addSubview(views[1]);\n\t};\n});\n\n\nvar src_Application=__class__;exports=src_Application(function src_Application(){return this.init&&this.init.apply(this,arguments)},GC.Application, function () {\n\n\tthis._settings = {\n\t\tlogsEnabled: window.DEV_MODE,\n\t\tshowFPS: window.DEV_MODE,\n\t\tclearEachFrame: true,\n\t\talwaysRepaint: true,\n\t\tpreload: []\n\t};\n\n\tthis.initUI = function () {\n\t\tvar test = 0;\n\n\t\tthis._tabs = new Tabs({\n\t\t\tsuperview: this,\n\t\t\tx: 10,\n\t\t\ty: 10,\n\t\t\twidth: 300,\n\t\t\theight: 300,\n\t\t\tbuttonsOpts: {\n\t\t\t\tbackgroundColor: \"#00FF00\"\n\t\t\t},\n\t\t\tcontentOpts: {\n\t\t\t\tbackgroundColor: \"#FF0000\"\n\t\t\t}\n\t\t});\n\n\t\tvar pane1 = new TextView({\n\t\t\ttext: \"Donec fringilla tempor odio quis tincidunt. Aenean ultricies dictum aliquet. Duis convallis nisl in est pretium pharetra.\",\n\t\t\tflex: 1,\n\t\t\twrap: true,\n\t\t\thorizontalAlign: \"left\",\n\t\t\thorizontalPadding: 20,\n\t\t\tverticalAlign: \"top\",\n\t\t\tverticalPadding: 20,\n\t\t\ttag: \"pane1\"\n\t\t});\n\t\tvar pane2 = new TextView({\n\t\t\ttext: \"Curabitur quis velit eget lectus vestibulum sagittis. Sed et leo mauris, nec consequat urna. Praesent lorem nisi, fermentum eu posuere nec, aliquam quis risus. Donec faucibus erat ac nibh imperdiet vulputate. Sed ornare vulputate pellentesque.\",\n\t\t\tflex: 1,\n\t\t\twrap: true,\n\t\t\thorizontalAlign: \"left\",\n\t\t\thorizontalPadding: 20,\n\t\t\tverticalAlign: \"top\",\n\t\t\tverticalPadding: 20,\n\t\t\ttag: \"pane2\"\n\t\t});\n\t\tthis._tabs.addPane(\"Hello\", pane1);\n\t\tthis._tabs.addPane(\"World\", pane2);\n\n\t\tthis._button = new View({\n\t\t\tsuperview: this,\n\t\t\tx: 10,\n\t\t\ty: 370,\n\t\t\twidth: 100,\n\t\t\theight: 30,\n\t\t\tbackgroundColor: \"#888888\"\n\t\t}).onInputSelect = bind(\n\t\t\tthis,\n\t\t\tfunction() {\n\t\t\t\ttest = (test + 1) & 3;\n\t\t\t\tthis._tabs.setButtonPosition([\"top\", \"bottom\", \"left\", \"right\"][test]);\n\t\t\t}\n\t\t);\n\t};\n\n\tthis.launchUI = function () {};\n});\n","pre":true},"../../../../sdk/timestep/ui/ScrollView.js":{"path":"../../../../sdk/timestep/ui/ScrollView.js","friendlyPath":"ui.ScrollView","directory":"../../../../sdk/timestep/ui/","filename":"ScrollView.js","src":"/**\n * @class ui.ScrollView;\n *\n * @doc http://doc.gameclosure.com/api/ui-scrollview.html\n * @docsrc https://github.com/gameclosure/doc/blob/master/api/ui/scrollview.md\n */\n\njsio(\"import ui.layout.LinearView as LinearView\");\n\njsio(\"import device\");\n\njsio(\"import event.input.dispatch as input\");\njsio(\"import event.input.InputEvent as InputEvent\");\n\njsio(\"import math.geom.Rect as Rect\");\njsio(\"import math.geom.Point as Point\");\njsio(\"import math.geom.Circle as Circle\");\njsio(\"import math.geom.intersect as intersect\");\njsio(\"import animate\");\n\njsio(\"import ui.backend.ReflowManager as ReflowManager\");\nvar _reflowMgr = ReflowManager.get();\n\n\nvar DEBUG = true;\nvar USE_CLIPPING = false;\n// var USE_CLIPPING = !device.useDOM && !device.isMobile;\n\nif (DEBUG) {\n\tvar _debug = {\n\t\tbounds: []\n\t};\n}\n/*function customEaseOut(x) {\n\tvar x = (1 - x);\n\tx *= x;\n\treturn 1 - x * x;\n}*/\n\n/**\n * @extends timestep.View\n */\nvar sdk_timestep_ui_ScrollView=__class__;exports=sdk_timestep_ui_ScrollView(function sdk_timestep_ui_ScrollView(){return this.init&&this.init.apply(this,arguments)},LinearView, function(supr) {\n\n\tthis.tag = \"ScrollView\";\n\n\tif (USE_CLIPPING) {\n\n\t\t// extend the default backing ctor\nthis.BackingCtor=__class__;\t\tthis.BackingCtor=this.BackingCtor(function this_BackingCtor(){return this.init&&this.init.apply(this,arguments)},View.prototype.BackingCtor, function () {\n\n\t\t\tfunction clippedWrapRender(contentView, backing, ctx, opts) {\n\t\t\t\tif (!backing.visible) { return; }\n\n\t\t\t\tif (!backing.__firstRender) { _reflowMgr.add(backing._view); }\n\n\t\t\t\t// non-native case only\n\t\t\t\tif (backing._needsSort) { backing._needsSort = false; backing._subviews.sort(); }\n\n\t\t\t\tctx.save();\n\t\t\t\tctx.translate(backing.x + backing.anchorX, backing.y + backing.anchorY);\n\n\t\t\t\tif (backing.r) { ctx.rotate(backing.r); }\n\n\t\t\t\t// clip this render to be within its view;\n\t\t\t\tif (backing.scale != 1) { ctx.scale(backing.scale, backing.scale); }\n\t\t\t\tif (backing.opacity != 1) { ctx.globalAlpha *= backing.opacity; }\n\n\t\t\t\tctx.translate(-backing.anchorX, -backing.anchorY);\n\n\t\t\t\t// if (backing._circle) { ctx.translate(-backing.width / 2, -backing.height / 2); }\n\n\t\t\t\tif (backing.clip) { ctx.clipRect(0, 0, backing.width, backing.height); }\n\t\t\t\t// var filters = this.getFilters();\n\t\t\t\t// ctx.setFilters(filters);\n\n\t\t\t\ttry {\n\t\t\t\t\tif (backing.backgroundColor) {\n\t\t\t\t\t\tctx.fillStyle = backing.backgroundColor;\n\t\t\t\t\t\tctx.fillRect(0, 0, backing.width, backing.height);\n\t\t\t\t\t}\n\n\t\t\t\t\tbacking._view.render && backing._view.render(ctx, opts);\n\n\t\t\t\t\tvar viewport = opts.viewport;\n\t\t\t\t\tvar subviews = backing._subviews;\n\n\t\t\t\t\tvar i = 0, subview;\n\t\t\t\t\twhile (subview = subviews[i++]) {\n\t\t\t\t\t\tif (subview == contentView) {\n\t\t\t\t\t\t\tclippedWrapRender(contentView, subview.__view, ctx, opts);\n\n\t\t\t\t\t\t\t// restore the old viewport it was changed\n\t\t\t\t\t\t\topts.viewport = viewport;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvar pos = subview.getPosition(viewport.src);\n\t\t\t\t\t\t\tgetBoundingRectangle(pos);\n\n\t\t\t\t\t\t\tif (intersect.isRectAndRect(pos, viewport)) {\n\t\t\t\t\t\t\t\tclippedWrapRender(contentView, subview.__view, ctx, opts);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (DEBUG) {\n\t\t\t\t\t\t\t\t_debug.bounds.push(pos);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t \tlogger.error(backing._view, e.message, e.stack);\n\t\t\t\t} finally {\n\t\t\t\t\t// ctx.clearFilters();\n\t\t\t\t\tctx.restore();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.wrapRender = function (ctx, opts) {\n\n\t\t\t\tclippedWrapRender(this._view._contentView, this, ctx, opts);\n\n\t\t\t\tif (DEBUG) {\n\t\t\t\t\tvar viewport = opts.viewport;\n\n\t\t\t\t\tctx.save();\n\t\t\t\t\tctx.translate(this.x + this.anchorX, this.y + this.anchorY);\n\t\t\t\t\tif (this.r) { ctx.rotate(this.r); }\n\t\t\t\t\tif (this.scale != 1) { ctx.scale(this.scale, this.scale); }\n\t\t\t\t\tctx.translate(-this.anchorX, -this.anchorY);\n\n\t\t\t\t\tctx.fillStyle = 'rgba(255, 0, 0, 0.2)';\n\t\t\t\t\tctx.fillRect(viewport.x, viewport.y, viewport.width, viewport.height);\n\n\t\t\t\t\tctx.translate(-viewport.x, -viewport.y);\n\n\t\t\t\t\tctx.fillStyle = 'rgba(255, 255, 255, 0.2)';\n\t\t\t\t\tfor (var i = 0, bounds; (bounds = _debug.bounds[i]); ++i) {\n\t\t\t\t\t\tctx.fillRect(bounds.x, bounds.y, bounds.width, bounds.height);\n\t\t\t\t\t}\n\t\t\t\t\t_debug.bounds = [];\n\t\t\t\t\tctx.restore();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n\n\tvar defaults = {\n\t\t\toffsetX: 0,\n\t\t\toffsetY: 0,\n\t\t\tscrollY: true,\n\t\t\tscrollX: true,\n\t\t\tclip: true,\n\t\t\tbounce: true,\n\t\t\tdrag: true,\n\t\t\tinertia: true,\n\t\t\tdragRadius: 10,\n\t\t\tsnapPixels: undefined,\n\t\t\tuseLayoutBounds: true\n\t\t};\n\n\tthis.init = function (opts) {\n\n\t\topts = merge(opts, defaults);\n\n\t\tthis._acceleration = 15;\n\n\t\tthis._animState = {\n\t\t\toffset: 0,\n\t\t\tlastDelta: 0,\n\t\t\toffset: 0\n\t\t};\n\n\t\tthis._snapPixels = 1;\n\n\t\tthis._scrollBounds = merge(opts.scrollBounds, {\n\t\t\tminX: -Number.MAX_VALUE,\n\t\t\tminY: -Number.MAX_VALUE,\n\t\t\tmaxX: Number.MAX_VALUE,\n\t\t\tmaxY: Number.MAX_VALUE\n\t\t});\n\n\t\tthis._contentView = new LinearView({\n\t\t\tx: opts.offsetX,\n\t\t\ty: opts.offsetY,\n\t\t\tinfinite: true,\n\t\t\ttag: \"ContentView\",\n\t\t\tlayout: 'box',\n\t\t\tlayoutWidth: '100%',\n\t\t\tlayoutHeight: '100%'\n\t\t});\n\n\t\tthis._viewport = new Rect();\n\t\tthis._viewport.src = this._contentView;\n\n\t\tsupr(this, 'init', [opts]);\n\t\tsupr(this, 'addSubview', [this._contentView]);\n\n\t\t// this.__layout = this._contentView.__layout;\n\t}\n\n\tthis.updateOpts = function (opts) {\n\t\tsupr(this, 'updateOpts', arguments);\n\n\t\tif ('useLayoutBounds' in opts) {\n\t\t\tif (opts.useLayoutBounds) {\n\t\t\t\tthis.subscribe('LayoutResize', this, '_updateLayoutBounds');\n\n\t\t\t\tif (this.style.layout == 'linear') {\n\t\t\t\t\tthis._updateLayoutBounds(this.__layout.getSize());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.unsubscribe('LayoutResize', this, '_updateLayoutBounds');\n\t\t\t}\n\t\t}\n\n\t\treturn opts;\n\t};\n\n\tthis._updateLayoutBounds = function (size) {\n\t\tif (size == undefined || this.style.layout != 'linear') { return; }\n\n\t\tvar bounds = this._scrollBounds;\n\t\tif (this.__layout.getDirection() == 'vertical') {\n\t\t\tbounds.minY = 0;\n\t\t\tbounds.maxY = size;\n\t\t} else {\n\t\t\tbounds.minX = 0;\n\t\t\tbounds.maxX = size;\n\t\t}\n\t};\n\n\tthis.buildView = function () {\n\t\tthis._snapPixels = this._opts.snapPixels || 1 / this.getPosition().scale;\n\t};\n\n\tthis.addSubview = function (view) { return this._contentView.addSubview(view); };\n\tthis.removeSubview = function (view) { return this._contentView.removeSubview(view); };\n\n\tthis.addFixedView = function (view) { return supr(this, 'addSubview', [view]); };\n\tthis.removeFixedView = function (view) { return supr(this, 'removeSubview', [view]); };\n\n\tvar BOUNCE_MAX_DIST = 50;\n\tvar PI_2 = Math.PI / 2;\n\n\tthis.getStyleBounds = function() {\n\t\tvar bounds = bounds = this._scrollBounds;\n\t\tvar minY = -bounds.maxY;\n\t\tvar maxY = -bounds.minY < minY ? minY : -bounds.minY;\n\t\tvar minX = -bounds.maxX;\n\t\tvar maxX = -bounds.minX < minX ? minX : -bounds.minX;\n\t\treturn {\n\t\t\tminY: Math.min(minY + this.style.height, maxY),\n\t\t\tmaxY: maxY,\n\t\t\tminX: Math.min(minX + this.style.width, maxX),\n\t\t\tmaxX: maxX\n\t\t};\n\t};\n\n\tthis.getOffset = function() { return new Point(this._contentView.style); };\n\tthis.getOffsetX = function () { return this._contentView.style.x; };\n\tthis.getOffsetY = function () { return this._contentView.style.y; };\n\n\tthis.setOffset = function(x, y) {\n\t\tvar style = this._contentView.style,\n\t\t\tdelta = {\n\t\t\t\tx: 0,\n\t\t\t\ty: 0\n\t\t\t};\n\n\t\tvar bounds = this.getStyleBounds();\n\n\t\tif (typeof x == 'number') {\n\t\t\tif (this._isBouncing) {\n\t\t\t\t// do nothing\n\t\t\t} else if (this._canBounce) {\n\t\t\t\tif (x < bounds.minX) {\n\t\t\t\t\tvar delta = (bounds.minX - x) / BOUNCE_MAX_DIST;\n\t\t\t\t\tx = bounds.minX - Math.atan(delta) * BOUNCE_MAX_DIST / PI_2;\n\t\t\t\t}\n\n\t\t\t\tif (x > bounds.maxX) {\n\t\t\t\t\tvar delta = (x - bounds.maxX) / BOUNCE_MAX_DIST;\n\t\t\t\t\tx = bounds.maxX + Math.atan(delta) * BOUNCE_MAX_DIST / PI_2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (x < bounds.minX) { x = bounds.minX; }\n\t\t\t\tif (x > bounds.maxX) { x = bounds.maxX; }\n\t\t\t}\n\n\t\t\tif (x != style.x) {\n\t\t\t\tdelta.x = x - style.x;\n\t\t\t\tstyle.x = (x / this._snapPixels | 0) * this._snapPixels;\n\t\t\t}\n\t\t}\n\n\t\tif (typeof y == 'number') {\n\t\t\tif (this._isBouncing) {\n\t\t\t\t// do nothing\n\t\t\t} else if (this._canBounce) {\n\t\t\t\tif (y < bounds.minY) {\n\t\t\t\t\tvar delta = (bounds.minY - y) / BOUNCE_MAX_DIST;\n\t\t\t\t\ty = bounds.minY - Math.atan(delta) * BOUNCE_MAX_DIST / PI_2;\n\t\t\t\t}\n\n\t\t\t\tif (y > bounds.maxY) {\n\t\t\t\t\tvar delta = (y - bounds.maxY) / BOUNCE_MAX_DIST;\n\t\t\t\t\ty = bounds.maxY + Math.atan(delta) * BOUNCE_MAX_DIST / PI_2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (y < bounds.minY) { y = bounds.minY; }\n\t\t\t\tif (y > bounds.maxY) { y = bounds.maxY; }\n\t\t\t}\n\n\t\t\tif (y != style.y) {\n\t\t\t\tdelta.y = y - style.y;\n\t\t\t\tstyle.y = (y / this._snapPixels | 0) * this._snapPixels;\n\t\t\t}\n\t\t}\n\n\t\tthis.publish('Scrolled', delta);\n\t};\n\n\tthis.isScrolling = function() { return this.isDragging() || this._anim && this._anim.hasFrames(); };\n\n\tthis.stopScrolling = function() {\n\t\tthis._anim && this._anim.now({}, 1);\n\t};\n\n\tthis.onInputStart = function(evt, pt) {\n\t\tif (this._opts.drag) {\n\t\t\tthis.startDrag({radius: this._opts.dragRadius * this._snapPixels});\n\n\t\t\tif (this._anim && this._anim.hasFrames()) {\n\t\t\t\tthis._anim.clear();\n\t\t\t\tevt.cancel();\n\t\t\t}\n\t\t}\n\t};\n\n\tthis.onDragStart = function(dragEvt) {\n\t\tinput.clearOverState(dragEvt.id);\n\n\t\tthis._contentView.getInput().blockEvents = true;\n\t\tthis._startBounce();\n\t\tthis._animState.offset = this.getOffset();\n\t\tthis._anim = animate(this._animState).clear();\n\t};\n\n\tthis.onDrag = function(dragEvt, moveEvt, delta) {\n\t\tvar state = this._animState;\n\t\tstate.dt = delta.t;\n\t\tstate.lastDelta = delta;\n\n\t\tif (!this._opts.scrollY) { delta.y = 0; }\n\t\tif (!this._opts.scrollX) { delta.x = 0; }\n\n\t\tthis.setOffset(state.offset.x += delta.x, state.offset.y += delta.y);\n\t\tmoveEvt.cancel();\n\t};\n\n\tthis.onDragStop = function(dragEvt, selectEvt) {\n\t\tthis._contentView.getInput().blockEvents = false;\n\n\t\tif (this._opts.inertia){\n\t\t\tvar delta = new Point(this._animState.lastDelta).scale(this._acceleration);\n\t\t\tvar offset = this._animState.offset;\n\t\t\tvar distance = delta.getMagnitude();\n\n\t\t\t// if we overshot the bounds, don't waste time animating the acceleration.\n\t\t\tvar bounds = this.getStyleBounds();\n\t\t\tvar target = new Point(offset).add(delta);\n\t\t\tif (target.y < bounds.minY - BOUNCE_MAX_DIST) {\n\t\t\t\tif (offset.y < bounds.minY) {\n\t\t\t\t\tdistance = 0;\n\t\t\t\t} else {\n\t\t\t\t\tdelta.y += (bounds.minY - BOUNCE_MAX_DIST - target.y);\n\t\t\t\t\tdistance = delta.getMagnitude();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (target.y > bounds.maxY + BOUNCE_MAX_DIST) {\n\t\t\t\tif (offset.y > bounds.maxY) {\n\t\t\t\t\tdistance = 0;\n\t\t\t\t} else {\n\t\t\t\t\tdelta.y -= (target.y - (bounds.maxY - BOUNCE_MAX_DIST));\n\t\t\t\t\tdistance = delta.getMagnitude();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (distance) {\n\t\t\t\tthis._anim.now(bind(this, function(tt, t) {\n\t\t\t\t\tthis.setOffset(\n\t\t\t\t\t\toffset.x + delta.x * tt,\n\t\t\t\t\t\toffset.y + delta.y * tt);\n\t\t\t\t}), 100 * Math.log((distance + 1) * 100), animate.easeOut).then(bind(this, function() {\n\t\t\t\t\tthis._endBounce(offset);\n\t\t\t\t}));\n\t\t\t} else {\n\t\t\t\tthis._endBounce(offset);\n\t\t\t}\n\t\t}\n\t};\n\n\t\n\tthis._startBounce = function() {\n\t\tthis._isBouncing = false;\n\t\tif (this._opts.inertia && this._opts.bounce) {\n\t\t\tthis._canBounce = true;\n\t\t}\n\t};\n\n\tthis._endBounce = function() {\n\t\tvar offset = this.getOffset();\n\t\tvar bounds = this.getStyleBounds();\n\n\t\tvar dx = 0;\n\t\tvar dy = 0;\n\n\t\tvar ty = offset.y, tx = offset.x;\n\t\tif (offset.y < bounds.minY) {\n\t\t\tty = bounds.minY;\n\t\t} else if (offset.y > bounds.maxY) {\n\t\t\tty = bounds.maxY;\n\t\t}\n\n\t\tif (offset.x < bounds.minX) {\n\t\t\ttx = bounds.minX;\n\t\t} else if (offset.x > bounds.maxX) {\n\t\t\ttx = bounds.maxX;\n\t\t}\n\n\t\tdy = ty - offset.y;\n\t\tdx = tx - offset.x;\n\n\t\tif (dy === 0 && dx === 0) { return; }\n\n\t\tthis._isBouncing = true;\n\t\tthis._anim.now(bind(this, function(tt, t) {\n\t\t\tthis.setOffset(\n\t\t\t\toffset.x + dx * tt,\n\t\t\t\toffset.y + dy * tt);\n\t\t}), 500, animate.easeInOut).then(bind(this, function() {\n\t\t\tthis._canBounce = false;\n\t\t\tthis._isBouncing = false;\n\t\t}));\n\t};\n\n\tthis.setScrollBounds = function(bounds) { this._scrollBounds = bounds; }\n\tthis.getScrollBounds = function() { return this._scrollBounds; }\n\n\tthis.addOffset = function(x, y) {\n\t\tthis.setOffset(\n\t\t\t\tx != undefined && x != null && (this._contentView.style.x + x),\n\t\t\t\ty != undefined && y != null && (this._contentView.style.y + y)\n\t\t\t);\n\t}\n\t\n\tthis.getContentView = function() { return this._contentView; }\n\n\t/* @deprecated */\n\tthis.getFullWidth = function() { return this._contentView.style.width; }\n\t/* @deprecated */\n\tthis.getFullHeight= function() { return this._contentView.style.height; }\n\t\n\tfunction getBoundingRectangle(pos) {\n\t\tif (!pos.r) { return; }\n\n\t\tvar w = pos.width;\n\t\tvar h = pos.height;\n\t\tvar cr = Math.cos(pos.r);\n\t\tvar sr = Math.sin(pos.r);\n\n\t\tvar x1 = pos.x;\n\t\tvar y1 = pos.y;\n\n\t\tvar x = w;\n\t\tvar y = 0;\n\n\t\tvar x2 = x1 + x * cr - y * sr;\n\t\tvar y2 = y1 + x * sr + y * cr;\n\n\t\ty += h;\n\n\t\tvar x3 = x1 + x * cr - y * sr;\n\t\tvar y3 = y1 + x * sr + y * cr;\n\n\t\tx -= w;\n\n\t\tvar x4 = x1 + x * cr - y * sr;\n\t\tvar y4 = y1 + x * sr + y * cr;\n\n\t\tpos.x = Math.min(x1, x2, x3, x4);\n\t\tpos.y = Math.min(y1, y2, y3, y4);\n\n\t\tpos.width = Math.max(x1, x2, x3, x4) - pos.x;\n\t\tpos.height = Math.max(y1, y2, y3, y4) - pos.y;\n\t\tpos.r = 0;\n\t};\n\n\tfunction intersect(viewport, prevViewport) {\n\t\tvar pos = viewport.src.getPosition(prevViewport.src);\n\n\t\tpos.x = (prevViewport.x - pos.x) / pos.scale;\n\t\tpos.y = (prevViewport.y - pos.y) / pos.scale;\n\t\tpos.width = prevViewport.width / pos.scale;\n\t\tpos.height = prevViewport.height / pos.scale;\n\t\tpos.r = -pos.r;\n\n\t\tgetBoundingRectangle(pos);\n\n\t\tviewport.intersectRect(pos);\n\t};\n\n\tthis.render = function (ctx, opts) {\n\t\tvar s = this.style;\n\t\tvar cvs = this._contentView.style;\n\n\t\tvar viewport = this._viewport;\n\n\t\tvar x = viewport.x;\n\t\tvar y = viewport.y;\n\t\tvar width = viewport.width;\n\t\tvar height = viewport.height;\n\n\t\tviewport.x = -cvs.x;\n\t\tviewport.y = -cvs.y;\n\n\t\t// TODO: does flooring versus rounding hurt us?\n\t\t// NOTE: + 0.5 | 0 for rounding DOES NOT work for negative numbers\n\t\tviewport.width = s.width * s.scale | 0;\n\t\tviewport.height = s.height * s.scale | 0;\n\n\t\tif (opts.viewport) {\n\t\t\tintersect(viewport, opts.viewport);\n\t\t}\n\n\t\topts.viewport = viewport;\n\n\t\treturn viewport.x != x || viewport.y != y || viewport.width != width || viewport.height != height;\n\t};\n\n\tthis.onInputScroll = function(evt) {\n\t\tif (this._opts.scrollY && evt.scrollAxis == input.VERTICAL_AXIS) {\n\t\t\tthis.addOffset(undefined, evt.scrollDelta * 40);\n\t\t} else if (this._opts.scrollX) {\n\t\t\tthis.addOffset(evt.scrollDelta * 40);\n\t\t}\n\t};\n\n\tthis.scrollTo = function(x, y, duration, cb) {\n\t\tduration = (duration == null ? 500 : duration);\n\t\tvar bounds = this.getStyleBounds();\n\n\t\tx = x < bounds.minX ? bounds.minX : x;\n\t\tx = x > bounds.maxX ? bounds.maxX : x;\n\t\ty = y < bounds.minY ? bounds.minY : y;\n\t\ty = y > bounds.maxY ? bounds.maxY : y;\n\n\t\tvar anim = animate(this._contentView).now({ x: x, y: y }, duration, animate.easeOut);\n\n\t\tif (cb) {\n\t\t\tanim.then(cb);\n\t\t}\n\t};\n});\n","pre":true}});; jsio('import runtimeBrowser.launchClient');